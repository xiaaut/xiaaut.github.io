[{"title":"ES6模块化与异步编程高级用法","url":"/2021/11/07/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/","content":"1. ES6 模块化1. 1 什么是 ES6 模块化规范ES6 模块化规范是浏览器端与服务器端通用的模块化开发规范。它的出现极大的降低了前端开发者的模块化学 习成本，开发者不需再额外学习 AMD、CMD 或 CommonJS 等模块化规范。\nES6 模块化规范中的定义：\n\n 每个 js 文件都是一个独立的模块\n导入其它模块成员使用 import 关键字\n向外共享模块成员使用 export 关键字\n\n1.2 在 node.js 中体验 ES6 模块化node.js 中默认仅支持 CommonJS 模块化规范，若想基于 node.js 体验与学习 ES6 的模块化语法，可以按照 如下两个步骤进行配置：\n\n确保安装了 v14.15.1 或更高版本的 node.js\n在 package.json 的根节点中添加 “type”: “module” 节点\n\n1.3 ES6 模块化的基本语法ES6 的模块化主要包含如下 3 种用法：\n\n默认导出与默认导入\n按需导出与按需导入\n直接导入并执行模块中的代码\n\n1.3.1 默认导出默认导出的语法： export default 默认导出的成员\nlet n1 = 10 // 定义模块私有成员 n1let n2 = 20 // 定义模块私有成员 n2 (外界访问不到 n2, 因为它没有被共享出去)function show() &#123;&#125; // 定义模块私有方法 showexport default &#123; // 使用 export default 默认导出语法，向外共享 n1 和 show 两个成员  n1,  show&#125;\n\n1.3.1 默认导入默认导入的语法： import 接收名称 from ‘模块标识符‘\n// 从上个模块中导入 export default 向外共享的成员// 并使用 m1 成员进行接收import m1 from &#x27;./01.默认导出.js&#x27;// 打印输出的结果为：// &#123;n1: 10, show: [Function: show]&#125;console.log(m1)\n\n1.3.1 默认导出的注意事项每个模块中，只允许使用唯一的一次 export default，否则会报错！\n","categories":["黑马前端"]},{"title":"HTML和CSS面试知识点","url":"/2021/05/04/HTML%E5%92%8CCSS%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"1. HTML题1.1 什么是 HTML 语义化\n让人更容易读懂代码（增加代码可读性）\n让搜索引擎更容易读懂（SEO）\n\n\n\n非语义化：&lt;div&gt;标题&lt;/div&gt;&lt;div&gt;    &lt;div&gt;一段文字&lt;/div&gt;    &lt;div&gt;        &lt;div&gt;列表1&lt;/div&gt;        &lt;div&gt;列表2&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;------------------------------------------语义化：&lt;div&gt;标题&lt;/div&gt;&lt;div&gt;    &lt;p&gt;一段文字&lt;/p&gt;    &lt;ul&gt;        &lt;li&gt;列表1&lt;/li&gt;        &lt;li&gt;列表2&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;\n\n1.2 块状元素 &amp; 内联元素\ndisplay: block/table; 有：div h1 h2… table ul ol p 等\ndisplay:inline/inline-block; 有：span img input button 等\n\n2. CSS题2.1 布局2.1.1 盒子模型宽度的计算&lt;!-- 如下代码，请问 div1 的 offsetWidth 是多大？ --&gt;&lt;style&gt;    #div1 &#123;        width: 100px;        padding: 10px;        border: 1px solid #ccc;        margin: 10px;    &#125;&lt;/style&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;\n\n\noffsetWidth = （内容宽度 + 内边距 + 边框），无外边距\n\n答案：122px\n\n如何让 offsetWidth 等于 100px?\n\n答案：在 div1 属性中添加“ box-sizing: border-box;”\n\n\n2.1.2 margin 纵向重叠问题&lt;!-- 如下代码，AAA 和 BBB 之间的距离是多少？ --&gt;&lt;style type=&quot;text/css&quot;&gt;    p &#123;        font-size: 16px;        line-height: 1;        margin-top: 10px;        margin-bottom: 15px;    &#125;&lt;/style&gt;    &lt;p&gt;AAA&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;BBB&lt;/p&gt;\n\n答案：15px\n\n相邻元素的 margin-top 和 margin-bottom 会发生重叠\n空白内容的 p 标签也会重叠\n大数值覆盖小数值\n\n2.1.3 margin 负值问题\nmargin-top 和 margin-left 负值，元素向上、向左移动\n\n\n\nmargin-right 负值，右侧元素左移，自身不受影响\n\n\n\nmargin-bottom 负值，下方元素上移，自身不受影响\n\n\n2.1.4 BFC 理解与应用什么是 BFC ？如何应用？\n\nBlock format context，块级格式化上下文\n\n一块独立渲染区域，内部元素的渲染不会影响边界以外的元素\n\n\n形成 BFC 的常见条件\n\nfloat 不是 none\nposition 是 absolute 或 fixed\noverflow 不是 visible\ndisplay 是 flex inline-block 等\n\nBFC 的常见应用\n\n清除浮动\n\n&lt;style type=&quot;text/css&quot;&gt;    .container &#123;        background-color: #f1f1f1;\t&#125;    .left &#123;        float: left;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;imgsrc=&quot;&quot; class=&quot;left&quot; style=&quot;magin-right: 10px;&quot;/&gt;        &lt;p&gt;某一段文字……&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;\n\n\n&lt;style type=&quot;text/css&quot;&gt;    .container &#123;        background-color: #f1f1f1;\t&#125;    .left &#123;        float: left;    &#125;    .bfc &#123;        overflow: hidden; /* 触发元素 BFC */     &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;container bfc&quot;&gt;        &lt;img src=&quot;https://www.imooc.com/static/img/index/logo.png&quot; class=&quot;left&quot; style=&quot;magin-right: 10px;&quot;/&gt;        &lt;p class=&quot;bfc&quot;&gt;某一段文字……&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;\n\n\n2.1.5 float 布局\n如何实现圣杯布局和双飞翼布局\n手写 clearfix\n\n圣杯布局和双飞翼布局的目的\n\n三栏布局，中间一栏最先加载和渲染（内容最重要）\n两侧内容固定，中间内容随着宽度自适应\n一般用于 PC 网页\n\n圣杯布局和双飞翼布局的技术总结\n\n使用 float 布局\n两侧使用 margin 负值，以便和中间内容横向重叠\n防止中间内容被两侧覆盖，一个用 padding 留白（圣杯布局），一个用 margin 留白（双飞翼布局）\n\n手写 clearfix\n.clearfix:after&#123;    content: &#x27;&#x27;;    display: table;    clear: both;&#125;.clearfix &#123;    *zoom: 1; /* 兼容 IE 低版本 */&#125;\n\n2.1.6 flex 布局flex 实现一个三点的色子\n常用语法\n\nflex-direction  主轴的方向（横向或者纵向）\njustify-content  主轴的对齐方式（两端对齐，居中对齐等）\nalign-items  交叉轴对齐方式（和主轴垂直的轴。开始，结束，居中对齐等）\nflex-wrap  换行\nalign-self  子元素在交叉轴的对齐方式（开始，结束，居中对齐等）  \n\n/* flex 画三个点的色子 */&lt;style&gt;.box &#123;    display: flex;    /* flex 布局*/    justify-content: space-between;    /* 两端对齐 */&#125;.item &#123;    /* 背景色、大小、边框等 */&#125;.item:nth-child(2) &#123;    align-self: center;    /* 第二项居中对齐 */&#125;.item:nth-child(3) &#123;    align-self: flex-end;    /* 第三项尾对齐 */&#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;    &lt;span class=&quot;item&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;item&quot;&gt;&lt;/span&gt;    &lt;span class=&quot;item&quot;&gt;&lt;/span&gt;&lt;/div&gt;\n\n2.2 定位2.2.1 absolute 和 relative 分别依据什么定位\nrelative 依据自身定位\nabsolute 依据最近一层的定位元素定位\n\n/* 子绝父相 */.relative &#123;    position: relative;    width: 400px;    height: 200px;    border: 1px solid #ccc;    top: 20px;    left: 50px;&#125;.absolute &#123;    position: absolute;    width: 200px;    height: 100px;    border: 1px solid blue;    top: 20px;    left: 50px;&#125;\n\n定位元素\n\nabsolute    relative    fixed\nbody\n\n2.2.2 居中对齐有哪些实现方式水平居中\n\ninline 元素：text-align: center\n\n.container-1 &#123;    text-align: center;&#125;\n\n\nblock 元素：margin: auto\n\n.container-2 .item &#123;    width: 500px;    margin: auto;&#125;\n\n\nabsolute 元素：left: 50% + margin-left 负值\n\n.container-3 &#123;    position: relative;    height: 100px;&#125;.container-3 .item &#123;    width: 300px;    height: 100px;    position: absolute;    left: 50%;    margin-left: -150px;&#125;\n\n垂直居中\n\ninline 元素：line-height 的值等于 height 值\n\n.container-1&#123;    text-align: center;    line-height: 200px;    height: 200px;&#125;\n\n\nabsolute 元素：top: 50% + margin-top 负值\n\n.container-2 &#123;    position: relative;&#125;.container-2 .item &#123;    width: 300px;    height: 100px;    position: absolute;    left: 50%;    margin-left: -150px;    top: 50%;    margin-top: -50px;&#125;\n\n\nabsolute 元素：transform(-50%, -50%) \n\n.container-3 &#123;    position: relative;&#125;.container-3 .item &#123;    width: 200px;    height: 80px;    position: absolute;    left: 50%; // 使用transform 需要设置（left、top）此两项    top: 50%;    transform: translate(-50%, -50%)&#125;\n\n\nabsolute 元素：top, left, bottom, right = 0 + margin: auto\n此方法适用于保证兼容性，子元素尺寸是未知的\n\n.container-4 &#123;    position: relative;&#125;.container-4 .item &#123;    width: 100px;    height: 50px;    position: absolute;    top: 0;    left: 0;    bottom: 0;    right: 0;    margin: auto;&#125;\n\n2.3 图文样式line-height 如何继承&lt;!-- 如下代码，p 标签的行高将会是多少？ --&gt;&lt;style&gt;    body &#123;        font-size: 20px;        line-height: 200%;    &#125;    p &#123;        font-size: 16px;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;p&gt;这是一行文字&lt;/p&gt;&lt;/body&gt;\n\n答案：p 标签的行高是40.    (20px*200%)\n\n写具体数值，如 30px，则继承该值\n写比例，如 2 / 1.5，则继承该比例  （子元素的 font-size * 该比例）\n写百分比，如 200%，则继承计算出来的值  （父元素的 font-size * 该百分比）\n\n2.4 响应式2.4.1 rem 是什么rem 是一个长度单位\n\npx，绝对长度单位，最常用\nem，相对长度单位，相对于父元素，不常用\nrem，相对长度单位，相对于根元素，常用于响应式布局\n\n&lt;style&gt;    html &#123;        font-size: 100px;    &#125;    div &#123;        background-color: #ccc;        margin-top: 10px;        font-size: 0.16rem;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;p style=&quot;font-size: 0.1rem&quot;&gt;rem 1&lt;/p&gt;    &lt;p style=&quot;font-size: 0.2rem&quot;&gt;rem 1&lt;/p&gt;    &lt;div style=&quot;width: 1rem;&quot;&gt;        this is div1    &lt;/div&gt;    &lt;div style=&quot;width: 2rem;&quot;&gt;        this is div2    &lt;/div&gt;&lt;/body&gt;\n\n2.4.2 响应式布局的常见方案\nmedia-query，根据不同的屏幕宽度设置根元素 font-size\nrem，基于根元素的相对单位\n\n&lt;style&gt;    @media only screen and (max-width: 374px) &#123;        /* iphone5 或者更小的尺寸，以 iphone5 的宽度（320px）比例设置 font-size */        html &#123;            font-size: 86px;        &#125;    &#125;    @media only screen and (min-width: 375px) and (max-width: 413px) &#123;        /* iphone6/7/8 和 iphone x */        html &#123;            font-size: 100px;        &#125;    &#125;    @media only screen and (min-width: 414px) &#123;        /* iphone6p 或者更大的尺寸，以 iphone6p 的宽度（414px）比例设置 font-size */        html &#123;            font-size: 110px;        &#125;    &#125;    body &#123;        font-size: 0.16rem;    &#125;    #div1 &#123;        width: 1rem;        background-color: #ccc;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div id=&quot;div1&quot;&gt;        this is div    &lt;/div&gt;&lt;/body&gt;\n\n2.4.5 vw/vh\nrem 的弊端：阶梯性\n网页视口尺寸\nwindow.screen.height    // 屏幕高度\nwindow.innerHeight    // 网页视口高度\ndoucument.body.clientHeight    // body高度\n\n\nvw/vh\nvh 网页视口高度的 1/100\nvm 网页视口宽度的 1/100\nvmax 取两者最大值；vmin 取两者最小值\n\n\n\n&lt;style&gt;    #container &#123;        background-color: red;        width: 10vw;        height: 10vh;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div id=&quot;container&quot;&gt;    &lt;/div&gt;    &lt;script&gt;        // window.innerHeight === 100vh        // window.innerWidth === 100vw    &lt;/script&gt;&lt;/body&gt;\n\n\n\n","tags":["面试题"]},{"title":"HTTP协议","url":"/2021/04/29/HTTP%E5%8D%8F%E8%AE%AE/","content":""},{"title":"JS-Web-API","url":"/2021/04/29/JS-Web-API/","content":""},{"title":"JS基础面试知识点","url":"/2021/04/29/JS%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"1. 变量类型和计算1.1 值类型和引用类型// 值类型let a = 100;let b = a;a = 200;console.log(b)\t// 100\n\n\n\n\n// 引用类型let a = &#123; age: 20 &#125;;let b = a;b.age = 21;console.log(a.age)\t// 21\n\n\n常见的值类型\nlet a; // undefinedconst s = &#x27;abc&#x27;;const n = 100;const b = true;const s = Symbol(&#x27;s&#x27;);\n\n常见的引用类型\nconst obj = &#123; x:100 &#125;;const arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]const n = null\t// 特殊的引用类型，指针指向为空的地址function fn() &#123;&#125;\t// 特殊的引用类型，但不用于存储数据，所以没有“拷贝、复制函数”这种说法\n\n1.2 typeof 运算符\n识别所有值类型\n\nlet a;    \t\t\t\t  typeof a  // &#x27;undefined&#x27;const s = &#x27;abc&#x27;;\t\t  typeof str  //  &#x27;string&#x27;const n = 100;\t\t\t  typeof n  // &#x27;number&#x27;const b = true;\t\t\t  typeof b  // &#x27;boolean&#x27;const s = Symbol(&#x27;s&#x27;);\t  typeof s  // &#x27;symbol&#x27;\n\n\n识别函数\n\ntypeof console.log  // &#x27;function&#x27;typeof function () &#123;&#125;  // &#x27;function&#x27;\n\n\n判断是否是引用类型（不可再细分）\n\ntypeof null  // &#x27;object&#x27;typeof [&#x27;a&#x27;, &#x27;b&#x27;]  // &#x27;object&#x27;typeof &#123; x: 100 &#125;  // &#x27;object&#x27;\n\n1.3 深拷贝const obj1 = &#123;    age: 20,    name: &#x27;xxx&#x27;,    address: &#123;        city: &#x27;beijing&#x27;    &#125;,    arr: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&#125;const obj2 = deepClone(obj1)obj2.address.city = &#x27;shanghai&#x27;obj2.arr[0] = &#x27;a1&#x27;console.log(obj1.address.city)console.log(obj1.arr[0])/** * 深拷贝 * @param &#123;Object&#125; obj 要拷贝的对象 */function deepClone(obj = &#123;&#125;) &#123;    if (typeof obj !== &#x27;object&#x27; || obj == null) &#123;        // obj 是 null ，或者不是对象和数组，直接返回        return obj    &#125;    // 初始化返回结果    let result    if (obj instanceof Array) &#123;        result = []    &#125; else &#123;        result = &#123;&#125;    &#125;    for (let key in obj) &#123;        // 保证 key 不是原型的属性        if (obj.hasOwnProperty(key)) &#123;            // 递归调用！！！            result[key] = deepClone(obj[key])        &#125;    &#125;    // 返回结果    return result&#125;\n\n1.4 变量计算 - 类型转换\n字符串拼接\n\nconst a = 100 + 10\t\t// 100const b = 100 + &#x27;10&#x27;\t// &#x27;10010&#x27;const c = true + &#x27;10&#x27;\t// &#x27;true10&#x27;\n\n\n== 运算符\n\n100 == &#x27;100&#x27;\t\t// true0 == &#x27;&#x27;\t\t\t\t// true0 == false\t\t\t// truefalse == &#x27;&#x27;\t\t\t// truenull == undefined\t// true\n\n// 除了 == null 之外，其他一律用 === ，例如：const obj = &#123; x: 100 &#125;if (obj.a == null) &#123;&#125;// 相当于：// if (obj.a === null || obj.a === undefined) &#123;&#125;\n\n\nif 语句和逻辑运算符\ntruly 变量：!!a === true 的变量\nfalsely 变量：!!a === false 的变量\n\n\n\n// 以下是 falsely 变量。除此以外都是 truly 变量!!0 === false!!NaN === false!!&#x27;&#x27; === false!!null === false!!undefined === false!!false === false\n\n\nif 语句\n\n// truly 变量const a = trueif (a) &#123;    // ... 执行 if 里面的代码&#125;const b = 100if (b) &#123;    // ... 执行 if 里面的代码&#125;// falsely 变量const c = &#x27;&#x27;if (c) &#123;    // ... 不执行 if 里面的代码&#125;const d = nullif (d) &#123;    // ... 不执行 if 里面的代码&#125;let eif (e) &#123;    // ... 不执行 if 里面的代码&#125;\n\n\n逻辑判断\n\nconsole.log(10 &amp;&amp; 0)\t// 0console.log(&#x27;&#x27; || &#x27;abc&#x27;)\t// &#x27;abc&#x27;console.log(!window.abc)\t// true\n\n2. 原型和原型链2.1 class// 类class Student &#123;    constructor(name, number) &#123;        this.name = name        this.number = number    &#125;    sayHi() &#123;        console.log(            `姓名 $&#123;this.name&#125; ，学号 $&#123;this.number&#125;`        )    &#125;&#125;// 通过类 new 对象/实例const xialuo = new Student(&#x27;夏洛&#x27;, 100)console.log(xialuo.name)console.log(xialuo.number)xialuo.sayHi()\n\n2.2 继承\nextends\nsuper\n扩展或重写方法\n\n// 父类class People &#123;    constructor(name) &#123;        this.name = name    &#125;    eat() &#123;        console.log(`$&#123;this.name&#125; eat something`)    &#125;&#125;// 子类class Student extends People &#123;    constructor(name, number) &#123;        super(name)        this.number = number    &#125;    sayHi() &#123;        console.log(`姓名 $&#123;this.name&#125; 学号 $&#123;this.number&#125;`)    &#125;&#125;// 子类class Teacher extends People &#123;    constructor(name, major) &#123;        super(name)        this.major = major    &#125;    teach() &#123;        console.log(`$&#123;this.name&#125; 教授 $&#123;this.major&#125;`)    &#125;&#125;// 实例const xialuo = new Student(&#x27;夏洛&#x27;, 100)console.log(xialuo.name)console.log(xialuo.number)xialuo.sayHi()xialuo.eat()// 实例const wanglaoshi = new Teacher(&#x27;王老师&#x27;, &#x27;语文&#x27;)console.log(wanglaoshi.name)console.log(wanglaoshi.major)wanglaoshi.teach()wanglaoshi.eat()\n\n类型判断 - instanceof\nxialuo instanceof Student\t// truexialuo instanceof People\t// truexialuo instanceof Object\t// true[] instanceof Array\t\t// true[] instanceof Object\t\t// true&#123;&#125; instanceof Object\t\t// true\n\n2.3 原型// class 实际上是函数，可见是语法糖typeof People\t\t// &#x27;function&#x27;typeof Student\t\t// &#x27;function&#x27;// 隐式原型和显示原型console.log( xialuo.__proto__)\t\t// 隐式原型console.log( Student.prototype )\t// 显示原型console.log( xialuo.__proto__ === Student.prototype)\n\n\n\n原型关系\n\n每个 class 都有显示原型 prototype\n每个实例都有隐式原型 __ proto__\n实例的 __ proto__ 指向对应的 class 的 prototype\n\n基于原型的执行规则\n\n获取属性 xialuo.name 或执行方法 xialuo.sayhi() 时\n先在自身属性和方法寻找\n如果找不到则自动去 __ proto__ 中查找\n\n2.4 原型链console.log( Student.prototype.__proto__)console.log( People.prototype )console.log( People.prototype === Student.prototype.__proto__)\n\n\n\nxialuo.hasOwnProperty(&#x27;eat&#x27;)\t\t\t// falsexialuo.hasOwnProperty(&#x27;hasOwnProperty&#x27;)\t// false\n\n2.5 instanceofinstanceof 运算符用来判断一个构造函数的 prototype 属性所指向的对象是否存在另外一个要检测对象的原型链上\nxialuo instanceof Array\t\t// false\n\n3. 原型相关的题目3.1 如何准确判断一个变量是数组a instanceof Array\n\n3.2 class 原型的本质\n原型和原型链的图示\n属性和方法的执行规则\n\n3.3 手写简易 jQuery 考虑插件和扩展性代码演示class jQuery &#123;    constructor(selector) &#123;        const result = document.querySelectorAll(selector)        const length = result.length        for (let i = 0; i &lt; length; i++) &#123;            this[i] = result[i]        &#125;        this.length = length        this.selector = selector    &#125;    get(index) &#123;        return this[index]    &#125;    each(fn) &#123;        for (let i = 0; i &lt; this.length; i++) &#123;            const elem = this[i]            fn(elem)        &#125;    &#125;    on(type, fn) &#123;        return this.each(elem =&gt; &#123;            elem.addEventListener(type, fn, false)        &#125;)    &#125;    // 扩展很多 DOM API&#125;// 插件jQuery.prototype.dialog = function (info) &#123;    alert(info)&#125;// “造轮子”class myJQuery extends jQuery &#123;    constructor(selector) &#123;        super(selector)    &#125;    // 扩展自己的方法    addClass(className) &#123;    &#125;    style(data) &#123;            &#125;&#125;// const $p = new jQuery(&#x27;p&#x27;)// $p.get(1)// $p.each((elem) =&gt; console.log(elem.nodeName))// $p.on(&#x27;click&#x27;, () =&gt; alert(&#x27;clicked&#x27;))\n\n4. 作用域和闭包4.1 作用域\n\n全局作用域\n函数作用域\n块级作用域（ES6 新增）\n\n// ES6 块级作用域if (true) &#123;    let x = 100;&#125;console.log(x)\t\t// 报错\n\n4.2 自由变量\n一个变量在当前作用域没有定义，但被使用了\n向上级作用域，一层一层依次寻找，直至找到为止\n如果到全局作用域都没找到，则报错 xx is not defined\n\n4.3 闭包\n作用域应用的特殊情况，有两种表现：\n函数作为参数被传递\n函数作为返回值被返回\n\n\n\n// 函数作为返回值function create() &#123;    let a = 100    return function () &#123;        console.log(a)    &#125;&#125;let fn = create()let a = 200fn()\t\t// 100\n\n// 函数作为参数function print(fn) &#123;    let a = 200    fn()&#125;let a = 100function fn() &#123;    console.log(a)&#125;print(fn)\t\t// 100\n\n\n所有的自由变量的查找，是在函数定义的地方，向上级作用域查找\n不是在执行的地方\n\n4.4 this\n作为普通函数\n使用 call apply bind\n作为对象方法被调用\n在 class 方法中调用\n箭头函数\n\nthis 取什么样的值是在函数执行的时候确定的，不是在函数定义的时候确定的\nfunction fn1() &#123;    console.log(this)&#125;fn1()\t\t// windowfn1.call(&#123; x: 100 &#125;)\t\t// &#123; x: 100 &#125;const fn2 = fn1.bind(&#123; x: 200 &#125;)fn2()\t\t// &#123; x: 200 &#125;\n\nconst zhangsan = &#123;    name: &#x27;张三&#x27;,    sayHi() &#123;        // this 即当前的对象        console.log(this)    &#125;,    wait() &#123;        setTimeout(function() &#123;            // this === window            console.log(this)        &#125;)    &#125;&#125;\n\nconst zhangsan = &#123;    name: &#x27;张三&#x27;,    sayHi() &#123;        // this 即当前的对象        console.log(this)    &#125;,    waitAgain() &#123;        setTimeout(() =&gt; &#123;            // this 即当前的对象            console.log(this)        &#125;    &#125;&#125;// 箭头函数里 this 的取值是取它上级作用域里的值\n\nclass People &#123;    constructor(name) &#123;        this.name = name        this.age = 20    &#125;    sayHi() &#123;        console.log(this)    &#125;&#125;const zhangsan = new People(&#x27;张三&#x27;)zhangsan.sayHi()\t\t// zhangsan 对象\n\n5. 作用域相关的题目5.1 this的不同应用场景，如何取值\n当做普通函数被调用        返回 window\n使用 call apply bind        传入什么返回什么\n作为对象方法调用        返回对象本身\n在 class 方法中的调用        返回当前实例本身\n箭头函数        返回上级作用域的 this 值        \n\n5.2 手写 bind 函数// 模拟 bindFunction.prototype.bind1 = function () &#123;    // 将参数拆解为数组    const args = Array.prototype.slice.call(arguments)    // 获取 this（数组第一项）    const t = args.shift()    // fn1.bind(...) 中的 fn1    const self = this    // 返回一个函数    return function () &#123;        return self.apply(t, args)    &#125;&#125;function fn1(a, b, c) &#123;    console.log(&#x27;this&#x27;, this)    console.log(a, b, c)    return &#x27;this is fn1&#x27;&#125;const fn2 = fn1.bind1(&#123;x: 100&#125;, 10, 20, 30)const res = fn2()console.log(res)\n\n5.3 实际开发中闭包的应用\n隐藏数据\n\n// 闭包隐藏数据，只提供 APIfunction createCache() &#123;    const data = &#123;&#125; // 闭包中的数据，被隐藏，不被外界访问    return &#123;        set: function (key, val) &#123;            data[key] = val        &#125;,        get: function (key) &#123;            return data[key]        &#125;    &#125;&#125;const c = createCache()c.set(&#x27;a&#x27;, 100)console.log( c.get(&#x27;a&#x27;) )\n\n\n做一个简单的 cache 工具\n\n5.4 创建 10 个 &lt; a &gt;,点击弹出序号let afor (let i = 0; i &lt; 10; i++) &#123;    a = document.createElement(&#x27;a&#x27;)    a.innerHTML = i + &#x27;&lt;br&gt;&#x27;    a.addEventListener(&#x27;click&#x27;, function (e) &#123;        e.preventDefault()        alert(i)    &#125;)    document.body.appendChild(a)&#125;\n\n6. 异步6.1 单线程和异步\nJS 是单线程语言，只能同时做一件事\n浏览器和 nodejs 已经支持 JS 启动进程，如 Web Worker\nJS 和 DOM 渲染共用同一个线程，因为 JS 可以修改 DOM 结构\n\n\n\n遇到等待（网络请求，定时任务）不能卡住\n需要异步\n基于回调 callback 函数形式调用\n\n// 异步 （callback 回调函数）console.log(100)setTimeout(() =&gt; &#123;    console.log(200)&#125;, 1000)console.log(300)console.log(400)// 显示顺序 100,300,400，200\n\n// 同步console.log(100)alert(200)console.log(300)// 弹出200后，如不点击确认，则不会显示300\n\n\n基于 JS 是单线程语言\n异步不会阻塞代码执行\n同步会阻塞代码执行\n\n6.2 异步的应用场景\n网络请求，如 Ajax 图片加载\n\n// ajaxconsole.log(&#x27;start&#x27;)$.get(&#x27;./data1.json&#x27;, function (data1)&#123;    console.log(data1)&#125;)console.log(&#x27;end&#x27;)\n\n\n定时任务，如 setTimeout\n\n// 图片加载console.log(&#x27;start&#x27;)let img = document.createElement(&#x27;img&#x27;)img.onload = function () &#123;  console.log(&#x27;loaded&#x27;);&#125;img.src = &#x27;/xxx.png&#x27;console.log(&#x27;end&#x27;);// start，end，loaded\n\n6.3 callback hell// 获取第一份数据$.get(url1,(data1) =&gt; &#123;    console.log(data1)        // 获取第二份数据    $.get(url2,(data2) =&gt; &#123;        console.log(data2)                // 获取第三份数据        $.get(url3,(data3) =&gt; &#123;            console.log(data3)                        // 还可能获取更多的数据        &#125;)    &#125;)&#125;)\n\n6.4 Promisefunction getData(url) &#123;    return new Promise((resolve, reject) =&gt; &#123;        $.ajax(&#123;            url,            success(data) &#123;                resolve(data)            &#125;,            error(err) &#123;                reject(err)            &#125;        &#125;)    &#125;)&#125;const url1 = &#x27;/data1.json&#x27;const url2 = &#x27;/data2.json&#x27;const url3 = &#x27;/data3.json&#x27;getData(url).then(data1 =&gt; &#123;    console.log(data1)    return getData(url2)&#125;).then(data2 =&gt; &#123;    console.log(data2)    return getData(url3)&#125;).then(data3 =&gt; &#123;    console.log(data3)&#125;).catch(err =&gt; console.error(err))\n\n7. 异步相关的面试题7.1 同步和异步的区别是什么？\n基于 JS 是单线程语言\n异步不会阻塞代码执行\n同步会阻塞代码执行\n\n7.2 手写 Promise 加载一张图片？function loadImg(src) &#123;    const p = new Promise(        (resolve, reject) =&gt; &#123;            const img = document.createElement(&#x27;img&#x27;)            img.onload = () =&gt; &#123;                resolve(img)            &#125;            img.onerror = () =&gt; &#123;                const err = new Error(`图片加载失败 $&#123;src&#125;`)                reject(err)            &#125;            img.src = src        &#125;    )    return p&#125;const url1 = &#x27;https://img.mukewang.com/5a9fc8070001a82402060220-140-140.jpg&#x27;const url2 = &#x27;https://img3.mukewang.com/5a9fc8070001a82402060220-100-100.jpg&#x27;loadImg(url1).then(img1 =&gt; &#123;    console.log(img1.width)    return img1 // 普通对象&#125;).then(img1 =&gt; &#123;    console.log(img1.height)    return loadImg(url2) // promise 实例&#125;).then(img2 =&gt; &#123;    console.log(img2.width)    return img2&#125;).then(img2 =&gt; &#123;    console.log(img2.height)&#125;).catch(ex =&gt; console.error(ex))\n\n7.3前端使用异步的场景有哪些？\n网络请求，如 Ajax 图片加载\n定时任务，如 setTimeout\n\n7.4 setTimeout 笔试题console.log(1)setTimeout(function () &#123;    console.log(2)&#125;, 1000)console.log(3)setTimeout(function () &#123;    console.log(4)&#125;, 0)console.log(5)// 答案：1,3,5,4,2\n\n\n\n\n\n\n\n\n\n\n\n","tags":["面试题"]},{"title":"JS异步-进阶面试知识点","url":"/2021/04/29/JS%E5%BC%82%E6%AD%A5-%E8%BF%9B%E9%98%B6%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"1. event loop（事件循环/事件轮询）\nJS 是单线程运行的\n异步要基于回调来实现\nevent loop 就是异步回调的实现原理\n\n\n\n1.1 JS 如何执行\n从前到后，一行一行执行\n如果某一行执行报错，则停止下面代码的执行\n先把同步代码执行完，再执行异步\n\nconsole.log(&#x27;Hi&#x27;)setTimeout(function cb1() &#123;    console.log(&#x27;cb1&#x27;)\t\t// cb 即 callback&#125;, 5000)console.log(&#x27;Bye&#x27;)// 结果：Hi, Bye, cb1\n\n1.2 event loop 过程\n\n同步代码，一行一行放在 Call Stack 执行\n遇到异步，会先“记录”下，等待时机（定时、网络请求等）\n时机到了，就移动到 Callback Queue\n如果 Callback Stack 为空（即同步代码执行完）Event Loop 开始工作\n轮询查找 Callback Queue，如果有则移动到 Callback Stack 执行\n然后继续轮询查找（像永动机一样）\n\n1.4 DOM 事件和 event loop&lt;button id=&quot;btn1&quot;&gt;提交&lt;/button&gt;&lt;script&gt;console.log(&#x27;Hi&#x27;)$(&#x27;#btn1&#x27;).click(function (e) &#123;    console.log(&#x27;button clicked&#x27;)&#125;)console.log(&#x27;Bye&#x27;)&lt;/script&gt;\n\n\nJS 是单线程的\n异步（setTimeout，Ajax 等）使用回调，基于 event loop\nDOM 事件也使用回调，基于 event loop\n\n2. Promise2.1 三种状态\npending resolved rejected\npending —&gt; resolved 或 pending —&gt; rejected\n变化不可逆\n\n2.2 状态的变化// 刚定义时，状态默认为 pendingconst p1 = new Promise((resolve, reject) =&gt; &#123;&#125;)// 执行 resolve() 后，状态变成 resolvedconst p2 = new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;        resolve()    &#125;)&#125;)// 执行 reject() 后，状态变成 rejectedconst p3 = new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;        reject()    &#125;)&#125;)\n\n2.2 状态的表现\npending 状态，不会触发 then 和 catch\nresolved 状态，会触发后续的 then 回调函数\nrejected 状态，会触发后续的 catch 回调函数\n\n// 直接返回一个 resolved 状态Promise.resolve(100)// 直接返回一个 rejected 状态Promise.reject(&#x27;some error&#x27;)\n\n2.3 then 和 catch 对状态的影响\nthen 正常返回 resolved，里面有报错则返回 rejected\ncatch 正常返回 resolved，里面有报错则返回 rejected\n\n// then() 一般正常返回 resolved 状态的 promisePromise.resolve().then(() =&gt; &#123;    return 100&#125;)// then() 里抛出错误，会返回 rejected 状态的 promisePromise.resolve().then(() =&gt; &#123;    throw new Error(&#x27;err&#x27;)&#125;)// catch() 不抛出错误，会返回 resolved 状态的 promisePromise.reject().catch(() =&gt; &#123;    console.error(&#x27;catch some error&#x27;)&#125;)// catch() 抛出错误，会返回 rejected 状态的 promisePromise.reject().catch(() =&gt; &#123;    console.error(&#x27;catch some error&#x27;)    throw new Error(&#x27;err&#x27;)&#125;)\n\n3. Promise 相关的面试题// 第一题Promise.resolve().then(() =&gt; &#123;    console.log(1)&#125;).catch(() =&gt; &#123;    console.log(2)&#125;).then(() =&gt; &#123;    console.log(3)&#125;)// 答案：1, 3\n\n// 第二题Promise.resolve().then(() =&gt; &#123;    console.log(1)    throw new Error(&#x27;erro1&#x27;)&#125;).catch(() =&gt; &#123;    console.log(2)&#125;).then(() =&gt; &#123;    console.log(3)&#125;)// 答案：1, 2, 3\n\n// 第三题Promise.resolve().then(() =&gt; &#123;    console.log(1)    throw new Error(&#x27;erro1&#x27;)&#125;).catch(() =&gt; &#123;    console.log(2)&#125;).catch(() =&gt; &#123; // 注意这里是 catch    console.log(3)&#125;)// 答案：1, 2\n\n4. async/await\n异步回调 callback hell\nPromise then catch 链式调用，但也是基于回调函数\nasync/await 是同步语法，彻底消灭了回调函数\n\n4. async/await 和 Promise 的关系\nasync/await 是消灭异步回调的终极武器\n但和 Promise 并不互斥\n反而，两者相辅相成\n\n\n\n执行 async 函数，返回的是 Promise 对象\nawait 相当于 Promise 的 then\ntry…catch 可捕获异常，代替了 Promise 的 catch\n\n5. 异步的本质\nJS 还是单线程，还得是有异步，还得是基于event loop\nasync/await 只是一个语法糖\n\n什么是语法糖？就相当于汉语里的成语。即，用更简练的言语表达较复杂的含义。在得到广泛接受的情况之下，可以提升交流的效率。\n\n\n\n\n\n\n\n\n\n\n\n\n\n6. 微任务/宏任务","tags":["面试题"]},{"title":"Hello World","url":"/2021/12/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"makedown笔记语法","url":"/2021/04/20/makedown%E7%AC%94%E8%AE%B0%E8%AF%AD%E6%B3%95/","content":"按 Ctrl+/  可以查看文档源码\n1、如何生成代码框// ```生成代码框\n\n\n\n2、如何快速生成标题//# 标题\t\t一级标题//## 标题\t\t二级标题//### 标题\t\t三级标题//#### 标题\t\t四级标题//###### 标题\t\t五级标题//####### 标题\t\t六级标题\n\n\n\n3、字体// 加粗**这是要加粗的文字**    左右两边各两个星号// 代码高亮==我是高亮的代码==      左右两边各两个等号// 删除线~~被删除的文字~~        左右两边各两个波浪线// 斜体*斜体的文字 *          左右两边各一个星号\n\n// 加粗这是要加粗的文字   左右两边各两个星号// 代码高亮==我是高亮的代码==    左右两边各两个等号// 删除线被删除的文字        左右两边各两个波浪线// 斜体*斜体的文字 *        左右两边各一个星号\n4、引用//引用语法&gt;作者：A&gt;&gt;作者：AA&gt;&gt;&gt;作者：AAA\n\n//引用语法\n\n作者：A\n\n作者：AA\n\n\n\n作者：AAA \n\n\n\n5、分割线//分割线---\t\t\t三个短横线//分割线2***\t\t\t三个星号\n\n三个短横线\n\n6、图片插入//在线图片/本地图片![我的图片](/images/me.png(在线图片/本地图片))  --图片路径\n\n\n7、超链接//超链接语法[我的GitHub](https://github.com/xiaaut)\n\n//超链接语法我的GitHub\n8、列表//无序列表- 目录1\t\t短横线，和文字之间有空格- 目录2- 目录3//有序列表//1. +名称\t\t中间有一个空格\n\n\n目录1\n\n目录2\n\n目录3\n\n\n\n有序列表\n有序列表\n\n9、表格\n\n\n成绩\n语文\n数学\n\n\n\n\n10\n10\n\n\n"},{"title":"一些字符串和数组的API用法","url":"/2021/11/21/%E4%B8%80%E4%BA%9B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84API%E7%94%A8%E6%B3%95/","content":"字符串的APIcharAt 方法和 slice 方法// 字符串有 charAt 方法，这个方法接收索引值，表示从字符串中把索引对应的字符，获取出来// val.charAt(0)const first = val.charAt(0).toUpperCase()// 字符串的 slice 方法，可以截取字符串，从指定索引往后截取const other = val.slice(1)// 强调：过滤器中，一定要有一个返回值return first + other\n\naxios 用法调用 axios 方法得到的返回值是 Promise 对象\ndocument.querySelector(&#x27;#btnGet&#x27;).addEventListener(&#x27;click&#x27;, async function () &#123;// 解构赋值的时候，使用 : 进行重命名// 1. 调用 axios 之后，使用 async/await 进行简化// 2. 使用解构赋值，从 axios 封装的大对象中，把 data 属性解构出来// 3. 把解构出来的 data 属性，使用 冒号 进行重命名，一般都重命名为 &#123; data: res &#125;const &#123; data: res &#125; = await axios(&#123;\tmethod: &#x27;GET&#x27;,\turl:&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;\t&#125;)\tconsole.log(res.data)&#125;)\n\n","categories":["API用法"],"tags":["JS"]},{"title":"一些面试真题","url":"/2021/04/29/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/","content":"1. var 和 let const 的区别\nvar 是 ES5 语法，let const 是 ES6 语法；var 有变量提升\nvar 和 let 是变量，可修改；const 是常量，不可修改\nlet const 有块级作用域，var 没有\n\n\n\n// 变量提升 ES5console.log(a) // undefinedvar a = 200// 上面的代码实际运行时如下var aconsole.log(a) // undefineda = 200// 块级作用域for (let i = 0; i &lt; 10; i++) &#123;    let j = i + 1&#125;console.log(i,j)\t// i 是 not defined\n\n2. typeof 返回哪些类型\nundefined string number boolean symbol（值类型）\nobject（注意：typeof null == ‘object’）（引用类型）\nfunction\n\n3. 列举强制类型转换和隐式类型转换\n强制：parseInt、parseFloat、toString 等\n隐式：if、逻辑运算、==、+ 拼接字符串\n\n4. 手写深度比较，模拟 lodash isEqual// 判断是否是对象或数组function isObject(obj) &#123;    return typeof obj === &#x27;object&#x27; &amp;&amp; obj !== null&#125;// 全相等（深度）function isEqual(obj1, obj2) &#123;    if (!isObject(obj1) || !isObject(obj2)) &#123;        // 值类型（注意，参与 equal 的一般不会是函数）        return obj1 === obj2    &#125;    if (obj1 === obj2) &#123;        return true    &#125;    // 两个都是对象或数组，而且不相等    // 1. 先取出 obj1 和 obj2 的 keys ，比较个数    const obj1Keys = Object.keys(obj1)    const obj2Keys = Object.keys(obj2)    if (obj1Keys.length !== obj2Keys.length) &#123;        return false    &#125;    // 2. 以 obj1 为基准，和 obj2 一次递归比较    for (let key in obj1) &#123;        // 比较当前 key 的 val —— 递归！！！        const res = isEqual(obj1[key], obj2[key])        if (!res) &#123;            return false        &#125;    &#125;    // 3. 全相等    return true&#125;// 测试const obj1 = &#123;    a: 100,    b: &#123;        x: 100,        y: 200    &#125;&#125;const obj2 = &#123;    a: 100,    b: &#123;        x: 100,        y: 200    &#125;&#125;// console.log( obj1 === obj2 )    falseconsole.log( isEqual(obj1, obj2) )    trueconst arr1 = [1, 2, 3]const arr2 = [1, 2, 3, 4]\n\n5. split() 和 join() 的区别// split() 方法用于把一个字符串分割成字符串数组&#x27;1-2-3&#x27;.split(&#x27;-&#x27;)    // [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]// join() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的[1,2,3].join(&#x27;-&#x27;)    // 1-2-3\n\n6. 数组的 pop、push、unshift、shift 分别做什么const arr = [10, 20, 30, 40]// popconst popRes = arr.pop()console.log(popRes, arr)    // 40 [10,20,30]// shiftconst shiftRes = arr.shift()console.log(shiftRes, arr)    // 10 [20,30,40]// pushconst pushRes = arr.push(50)    // 返回 lengthconsole.log(pushRes, arr)    // 5 [10, 20, 30, 40, 50]// unshiftconst unshiftRes = arr.unshift(5)    // 返回 lengthconsole.log(unshiftRes, arr)    // 5 [5, 10, 20, 30, 40]\n\n7.【扩展】数组的 API，有哪些是纯函数// 纯函数：1. 不改变源数组（没有副作用）；2. 返回一个数组const arr = [10, 20, 30, 40]// concatconst arr1 = arr.concat([50, 60, 70])console.log(arr)    // [10,20,30,40]console.log(arr1)    // [10,20,30,40,50,60,70]// mapconst arr2 = arr.map(num =&gt; num * 10)console.log(arr)    // [10,20,30,40]console.log(arr2)    // [100,200,300,400]// filterconst arr3 = arr.filter(num =&gt; num &gt; 25)console.log(arr)    // [10,20,30,40]console.log(arr3)    // [30,40]// slice 类似于深拷贝const arr4 = arr.slice()console.log(arr)    // [10,20,30,40]console.log(arr4)    // [10,20,30,40]// 非纯函数// push pop shift unshift// forEach// some every// reduce\n\n\n7. 数组 slice 和 splice 的区别\n功能区别（slice - 切片，splice - 剪接）\n参数和返回值\n是否纯函数\n\nconst arr = [10, 20, 30, 40]// slice 纯函数const arr1 = arr.slice()\t// [10,20,30,40]const arr2 = arr.slice(1, 4)\t// [20,30]const arr3 = arr.slice(2)\t// [20,30,40]const arr4 = arr.slice(-2)\t// [30,40]--------------------------------------------------const arr = [10, 20, 30, 40]// splice 非纯函数const spliceRes = arr.splice(1, 2, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)console.log(spliceRes, arr)\t// [20,30] [10,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,40,50]const spliceRes1 = arr.splice(1, 2)console.log(spliceRes1, arr)\t// [20,30] [10,40]const spliceRes2 = arr.splice(1, 0, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)console.log(spliceRes2, arr)\t// [] [10,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,20,30,40]\n\n8. [10, 20, 30].map(parseInt) 返回的结果是什么\nmap 的参数和返回值\nparseInt 参数和返回值\n\nconst res = [10, 20, 30].map(parseInt)console.log(res)\t// [10,NaN,NaN]// 拆解[10, 20, 30].map((num, index) =&gt; &#123;    return parseInt(num, index)&#125;)\n\n9. Ajax 请求 get 和 post 的区别\nget 一般用于查询操作，post 一般用于用户的提交操作\nget 参数拼接在 url 上，post 放在请求体内（数据体积可更大）\n安全性：post 易于防止 CSRF\n\n10. 函数 call 和 apply 的区别// call 和 apply 都是用来修改函数中this的指向问题fn.call(this, p1, p2, p3)\t// call 里面的参数是拆分后传进去fn.apply(this, arguments)\t// apply 是数组形式传进去\n\n11. 事件代理（委托）是什么\n12. 闭包是什么，有什么特性？有什么负面影响\n回顾作用域和自由变量\n回顾闭包应用场景：作为参数被传入，作为返回值被返回\n回顾：自由变量的查找，要在函数定义的地方（而非执行的地方）\n影响：变量会常驻内存，得不到释放。闭包不要乱用\n\n// 自由变量示例 —— 内存会被释放let a = 0function fn1() &#123;    let a1 = 100        function fn2() &#123;        let a2 = 200                function fn3() &#123;            let a3 = 300            return a + a1 + a2 + a3        &#125;        fn3()    &#125;    fn2()&#125;fn1()\n\n// 闭包 函数作为返回值 —— 内存不会被释放function create() &#123;    let a = 100    return function () &#123;        console.log(a)    &#125;&#125;let fn = create()let a = 200fn()\t// 100-------------------------------------     function print(fn) &#123;    let a = 200    fn()&#125;let a = 100function fn() &#123;    console.log(a)&#125;print(fn) // 100\n\n13. 如何阻止事件冒泡和默认行为\nevent.stopPropagation()\nevent.preventDefault()\n\n14. 查找、添加、删除、移动 DOM 节点的方法\n基础中的基础，可回顾之前的内容\n\n15. 如何减少 DOM 操作\n缓存 DOM 查询结果\n多次 DOM 操作，合并到一次插入\n\n\n16. 解释 jsonp 的原理，为何它不是真正的 Ajax\n浏览器的同源策略（服务端没有同源策略）和跨域\n哪些 html 标签能绕过跨域？\nimg 标签\nscript 标签\n\n\njsonp 原理\n\n\n17. document load 和 ready 的区别\n18. == 和 === 的不同\n== 会尝试类型转换\n=== 严格相等\n那些场景才用 == \n\n19. 函数声明和函数表达式的区别\n函数声明 function fn() {…}\n函数表达式 const fn = function() {…}\n函数声明会在代码执行前预加载，而函数表达式不会\n\n// 函数声明const res = sum(10, 20)console.log(res)\t// 30function sum(x, y) &#123;    return x + y&#125;// 函数表达式var res = sum(10, 20)console.log(res)\t// 报错sum = function (x, y) &#123;    return x + y&#125;\n\n20. new Object() 和 Objuect.create() 的区别\n{} 等同于 new Object()，原型都是 Object.prototype\nObject.create(null) 没有原型\nObject.create({…}) 可以指定原型\n\nconst obj1 = &#123;    a: 10,    b: 20,    sum() &#123;        return this.a + this.b    &#125;&#125;const obj2 = new Object(&#123;    a: 10,    b: 20,    sum() &#123;        return this.a + this.b    &#125;&#125;)const obj21 = new Object(obj1) // obj1 === obj2const obj3 = Object.create(null)const obj4 = new Object() // &#123;&#125;const obj5 = Object.create(&#123;    a: 10,    b: 20,    sum() &#123;        return this.a + this.b    &#125;&#125;)const obj6 = Object.create(obj1)\n\n21. 关于 this 的场景题const User = &#123;    count: 1,    getCount: function() &#123;        return this.count;    &#125;&#125;console.log(User.getCount());\t// 1const func = User.getCount;console.log(func());\t// undefined\n\n22. 关于作用域和自由变量的场景题 - 1let ifor(i =1; i&lt;=3; i++)&#123;    setTimeout(function () &#123;        console.log(i);    &#125;,0)&#125;// 4\n\n23. 判断字符串以字母开头，后面字母数字下划线，长度 6-30\nconst reg = /^[a-zA-Z]\\w{5,29}$/\n学习正则表达式的规则\n手写常见的正则表达式\n\n// 邮政编码/\\d&#123;6&#125;/// 小写英文字母/^[a-z]+$/// 英文字母/^[a-zA-Z]+$/// 日期格式 2019.12.1/^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$/// 用户名/^[a-zA-Z]\\w&#123;5, 17&#125;$/// 简单的 IP 地址匹配/\\d+\\.\\d+\\.\\d+\\.\\d+/\n\n24. 关于作用域和自由变量的场景题 - 2let a = 100function test() &#123;    alert(a)    a = 10    alert(a)&#125;test()alert(a)// 100// 10// 10\n\n25. 手写字符串 trim 方法，保证浏览器兼容性String.prototype.trim = function () &#123;    return this.replace(/^\\s+/,&#x27;&#x27;).replace(/\\s+$/,&#x27;&#x27;)&#125;// （原型、this、正则表达式）\n\n26. 如何获取多个数字中的最大值\nMath.max(10, 30, 20, 40)// 以及 Math.min\n\n27. 如何用 JS 实现继承\nclass 继承\nprototype 继承\n\n28. 如何捕获 JS 程序中的异常\nlineNom、colNom 拼写错误，实际是 lineNum、colNum\n29. 什么是 JSON\njson 是一种数据格式，本质是一段字符串\njson 格式和 JS 对象结构一致，对 JS 语言更友好\nwindow.JSON 是一个全局对象：JSON.stringify JSON.parse\n\n\n30. 获取当前页面的 url 参数\n传统方式，查找 location.search\n新 API，URLSearchParams\n\n// 传统方式function query(name) &#123;    const search = location.search.substr(1) // 类似 array.slice(1)    // search: &#x27;a=10&amp;b=20&amp;c=30&#x27;    const reg = new RegExp(`(^|&amp;)$&#123;name&#125;=([^&amp;]*)(&amp;|$)`, &#x27;i&#x27;)    const res = search.match(reg)    if (res === null) &#123;        return null    &#125;    return res[2]&#125;query(&#x27;d&#x27;)// URLSearchParamsfunction query(name) &#123;    const search = location.search    const p = new URLSearchParams(search)    return p.get(name)&#125;console.log( query(&#x27;b&#x27;) )\n\n31. 将 url 参数解析为 JS 对象// 传统方式，分析 searchfunction queryToObj() &#123;    const search = location.search.substr(1) // 去掉前面的 `?`    search.split(&#x27;&amp;&#x27;).forEach(paramStr =&gt; &#123;        const arr = paramStr.split(&#x27;=&#x27;)        const key = arr[0]        const val = arr[1]        res[key] = val    &#125;)\treturn res&#125;// 使用 URLSearchParamsfunction queryToObj() &#123;    const res = &#123;&#125;    const pList = new URLSearchParams(location.search)    pList.forEach((val, key) =&gt; &#123;        res[key] = val    &#125;)    return res&#125;\n\n32. 手写数组 flatern，考虑多层级function flat(arr) &#123;    // 验证 arr 中，还有没有深层数组 [1, 2, [3, 4]]    const isDeep = arr.some(item =&gt; item instanceof Array)    if (!isDeep) &#123;        return arr // 已经是 flatern [1, 2, 3, 4]    &#125;    const res = Array.prototype.concat.apply([], arr)    return flat(res) // 递归&#125;const res = flat( [1, 2, [3, 4, [10, 20, [100, 200]]], 5] )console.log(res)\n\n33. 数组去重\n传统方式，遍历元素挨个比较、去重\n使用 Set\n考虑计算效率\n\n// 传统方式function unique(arr) &#123;    const res = []    arr.forEach(item =&gt; &#123;        if (res.indexOf(item) &lt; 0) &#123;            res.push(item)        &#125;    &#125;)    return res&#125;// 使用 Set （无序，不能重复）function unique(arr) &#123;    const set = new Set(arr)    return [...set]&#125;const res = unique([30, 10, 20, 30, 40, 10])console.log(res)\n\n34. 手写深拷贝function deepClone(obj = &#123;&#125;) &#123;    if (typeof obj !== &#x27;object&#x27; || obj == null) &#123;        // obj 是 null ，或者不是对象和数组，直接返回        return obj    &#125;    // 初始化返回结果    let result    if (obj instanceof Array) &#123;        result = []    &#125; else &#123;        result = &#123;&#125;    &#125;    for (let key in obj) &#123;        // 保证 key 不是原型的属性        if (obj.hasOwnProperty(key)) &#123;            // 递归调用！！！            result[key] = deepClone(obj[key])        &#125;    &#125;    // 返回结果    return result&#125;\n\n注意：Object.assign 不是深拷贝！\n35. 介绍一下 RAF requestAnimationFrame\n要想动画流畅，更新频率要 60帧/s，即 16.67ms 更新一次视图\nsetTimeout 要手动控制频率，而 RAF 浏览器会自动控制\n后台标签或隐藏 iframe 中，RAF 会暂停，而 setTimeout 依然执行\n\n&lt;style&gt;    #div1 &#123;        width: 100px;        height: 50px;        background-color: red;    &#125;&lt;/style&gt;&lt;script&gt;// 3s 把宽度从 100px 变为 640px ，即增加 540px// 60帧/s ，3s 180 帧 ，每次变化 3pxconst $div1 = $(&#x27;#div1&#x27;)let curWidth = 100const maxWidth = 640// setTimeoutfunction animate() &#123;    curWidth = curWidth + 3    $div1.css(&#x27;width&#x27;, curWidth)    if (curWidth &lt; maxWidth) &#123;        setTimeout(animate, 16.7) // 自己控制时间    &#125;&#125;animate()// RAFfunction animate() &#123;    curWidth = curWidth + 3    $div1.css(&#x27;width&#x27;, curWidth)    if (curWidth &lt; maxWidth) &#123;        window.requestAnimationFrame(animate) // 时间不用自己控制    &#125;&#125;animate()&lt;/script&gt;\n\n36. 前端性能如何优化？一般从那几个方面考虑？\n原则：多使用内存、缓存，减少计算、减少网络请求\n方向：加载页面，页面渲染，页面操作流畅度\n\n","tags":["面试题"]},{"title":"一些面试编程题","url":"/2021/12/22/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E7%BC%96%E7%A8%8B%E9%A2%98/","content":"1.实现一个函数 rearange，要去对数组去重，同时进行拷贝后返回\nfunction rearange(arr) &#123;    var newArr = []    arr.forEach((item) =&gt; &#123;        if (newArr.indexOf(item) &lt; 0) &#123;            newArr.push(item)        &#125;    &#125;)    return newArr&#125;var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;]\n\n\n\n2.现有一个table，使用 CSS 将渲染为斑马条纹状（每行深浅背景交替）\n&lt;style&gt;    table &#123;        width: 300px;        border: 1px solid #ccc;        text-align: center;    &#125;    tbody tr:nth-child(even) &#123;        background-color: pink;    &#125;    tbody tr:nth-child(odd) &#123;        background-color: blue;    &#125;&lt;/style&gt;\n\n\n\n3.使用Media Query编写一个样式，实现宽度1280px以上使用蓝色背景，否则使用黄色背景\n@media screen and (max-width: 1280px) &#123;    body &#123;        background-color: yellow;    &#125;&#125;@media screen and (min-width: 1280px) &#123;    body &#123;        background-color: blue;    &#125;&#125;\n\n\n\n4.有一个理财产品列表页面，数量很多（30以上），每个产品对应一张大图片，写一个lazy-load的方法，使得图片随着用户的浏览和滚动逐步加载\n","tags":["面试题"]},{"title":"两个浏览器标签页通信交互","url":"/2022/06/15/%E4%B8%A4%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E4%BF%A1%E4%BA%A4%E4%BA%92/","content":"两个浏览器标签页通信交互vue开发中，A页面为列表页（A标签页），B页面为详情页（B标签页）\n当B页面的数据填写完成后，A页面自动刷新，获取到最新的数据并展示\n解决思路使用localStorage，相同浏览器的同源页面共享（页面属于相同域名和端口）\nA页面需要进行的操作：\n在A页面新增或编辑的跳转方法中增加以下代码：\nlocalStorage.setItem(&#x27;isSave&#x27;, false)\n\nA页面 methods 中新增加一个方法：\nmethods: &#123;    onStorageHandle(e) &#123;        if (e.key === &#x27;isSave&#x27; &amp;&amp; e.newValue === &#x27;true&#x27;) &#123;            search()  // 刷新列表页        &#125;    &#125;&#125;\n\n并在 mounted 声明周期中监听事件：\nmounted() &#123;    //监听属性值的变化    window.addEventListener(&#x27;storage&#x27;, this.onStorageHandle);&#125;,\n\n当组件关闭后需要销毁此监听事件：\ndestroyed() &#123;    // 在组件生命周期结束的时候销毁。    window.removeEventListener(&quot;storage&quot;, this.onStorageHandle);&#125;,\n\n\n\nB页面需要进行的操作：\n在B页面保存的方法中增加以下代码：\nlocalStorage.setItem(&#x27;isSave&#x27;, true)\n\n","tags":["Vue"]},{"title":"如何在PC搭建hexo博客","url":"/2021/04/21/%E5%A6%82%E4%BD%95%E5%9C%A8PC%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/","content":"1.安装 nodejsnode -v\t#查看node版本npm -v\t#查看npm版本这个是更换下载路径的代码：npm install -g cnpm --registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org\t#安装淘宝的cnpm 管理器 \n\n2.安装 hexo 框架npm install -g hexo-cli\n\n\n\n3.在 D 盘创建 blog 目录cd d:&#x2F;blog\n\n4.初始化博客hexo init\n\n5.启动本地博客服务hexo s本地浏览器访问地址：http:&#x2F;&#x2F;localhost:4000&#x2F;\n\n6.创建新的文章hexo n &quot;文章的名称&quot;\n\n7.生成文章hexo g\n\n8.如何将本地博客部署到 GitHubnpm install hexo-deployer-git --save\t#在blog目录下安装git部署插件\n\n在 GitHub 创建一个名为：你的GitHub名称.github.io 的仓库\n\n打开 blog 目录下的 _config.yml 文件# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy:  type: git  repo: git@github.com&#x2F;GitHub名称&#x2F;GitHub名称.github.io.git  branch: branch\n\nhexo d\t#部署博客文章到Github仓库\n\n9.通过此链接可以查看博客https:&#x2F;&#x2F;GitHub名称.github.io&#x2F;\n\n10.如何更换博客主题为 yiliagit clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia\t#下载yilia主题到本地\n\n#修改hexo根目录下的 _config.yml 文件\ttheme: yilia\n\n一些快捷键\nhexo c\t#清理一下hexo g\t#生成hexo d\t#部署到远程Github仓库https:&#x2F;&#x2F;YourGithubName.github.io&#x2F;  #查看博客\n\n\n\n","categories":["博客相关"],"tags":["hexo"]},{"title":"在 GitHub 新建项目并把本地项目推送到 GitHub","url":"/2022/03/10/%E5%9C%A8-GitHub-%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%8A%8A%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E5%88%B0-GitHub/","content":"\n在电脑本地打开一个 git 工具窗口：\n之后依次执行下图命令：\n\n 如何取消一个项目的版本控制，让它成为一个普通文件夹：\n1.进入项目目录\n2.输入以下代码：\nfind . -name &quot;.git&quot; | xargs rm -Rf// 清理后查看 git 状态git status\n\n\n\n\n\n"},{"title":"开发环境","url":"/2021/04/29/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","content":"1. git\n最常用的代码版本管理用具\n大型项目需要多人协作开发，必须熟用 git\nMac OS 自带 git 命令，windows 可以去官网下载安装\ngit 服务端常见的有 GitHub coding.net 等\n大公司会搭建自己的内网 git 服务\n\n\n\n1.1 常用的 git 命令\ngit add .        提交所有的文件\ngit checkout 文件名        撤销某个文件内容的修改\ngit commit -m “xxx”        添加一条提交记录\ngit push origin master        提交 master 分支代码\ngit pull origin master        拉取 master 分支代码\ngit branch        查看当前所在的分支\ngit checkout -b xxx / git checkout xxx        切换到其他分支\ngit merge xxx        把 xxx 分支的代码合并到 master 分支\ngit stash        把修改暂存起来\ngit stash pop        把暂存的修改拉回来\n\n2.调试工具2.1 Elements看 DOM 结构，调试 CSS 样式\n2.2 Console调试 JS 代码\n2.3 Application查看 Storage 里的存储信息\n2.4 Network查看网络资源的加载状态\n2.5 Sources调试源码\n3. 抓包\n移动端 h5 页面，查看网络请求，需要用工具抓包\nwindows 一般用 fiddler\nmacOS 一般用 charles\n\n\n\n手机和电脑连同一个局域网\n将手机代理到电脑上\n手机浏览网页，即可抓包\n\n\n\n查看网络请求\n网址代理\nhttps\n\n4. webpack babel\nES6 模块化，浏览器暂不支持\nES6 语法，浏览器并不完全支持\n压缩代码，整合代码，以让网页加载更快\n\n// 新建一个名为 webpack-demo 的文件夹// 鼠标右键打开命令行工具// 先查看 node 版本node -v// 初始化 npm 环境npm init -y// 安装 webpacknpm install webpack webpack-cli -D// 在文件夹根目录下创建 webpack.config.js 文件，并添加如下代码const path = require(&#x27;path&#x27;)module.exports = &#123;    mode: &#x27;development&#x27;, //production    entry: path.join(__dirname, &#x27;src&#x27;, &#x27;index.js&#x27;),    output: &#123;        filename: &#x27;bundle.js&#x27;,        path: path.join(__dirname, &#x27;dist&#x27;)    &#125;&#125;\n\n在 package.json 文件夹中新添加如下图红框中代码\n\n// 之后在命令行工具中输入代码npm run build\n\n如图，打包成功\n\n再安装如下插件\n// 解析 HTML 的插件npm install html-webpack-plugin -D// 能启动服务的插件npm install webpack-dev-server -D\n\n修改 webpack.config.js 文件\nconst path = require(&#x27;path&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123;    mode: &#x27;development&#x27;, //production    entry: path.join(__dirname, &#x27;src&#x27;, &#x27;index.js&#x27;),    output: &#123;        filename: &#x27;bundle.js&#x27;,        path: path.join(__dirname, &#x27;dist&#x27;)    &#125;,    plugins: [        new HtmlWebpackPlugin(&#123;            template: path.join(__dirname, &#x27;src&#x27;, &#x27;index.html&#x27;),            filename: &#x27;index.html&#x27;        &#125;)    ],    devServer: &#123;        port: 3000,        contentBase: path.join(__dirname, &#x27;dist&#x27;)    &#125;&#125;\n\n在 package.json 文件夹中新添加如下图红框中代码\n\n\n安装 babel\n// 命令行工具下输入npm install @babel/core @babel/preset-env\n\n新建 .babelrc 文件，并添加代码\n\nconst path = require(&#x27;path&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123;    mode: &#x27;development&#x27;, //production    entry: path.join(__dirname, &#x27;src&#x27;, &#x27;index.js&#x27;),    output: &#123;        filename: &#x27;bundle.js&#x27;,        path: path.join(__dirname, &#x27;dist&#x27;)    &#125;,    module:&#123;        rules: [            &#123;                test: /\\.js/,                loader: [&#x27;babel-loader&#x27;],                include: path.join(__dirname, &#x27;src&#x27;),                exclude: /node_modules/            &#125;        ]    &#125;,    plugins: [        new HtmlWebpackPlugin(&#123;            template: path.join(__dirname, &#x27;src&#x27;, &#x27;index.html&#x27;),            filename: &#x27;index.html&#x27;        &#125;)    ],    devServer: &#123;        port: 3000,        contentBase: path.join(__dirname, &#x27;dist&#x27;)    &#125;&#125;\n\n5. Linux 常用命令\n公司的线上机器一般都是 Linux （参考阿里云）\n测试机也需要保持一致，用 Linux\n测试机或者线上机出了问题，本地又不能复现，需要去排查\n\n\n\nls        查看文件\nls-a        查看所有文件\nll        查看文件列表\nmkdir xxx        创建文件夹\nll xxx        查看文件夹\nrm -rf xxx        删除文件夹及其所有内容\ncd xxx        切换到 xxx 目录\nmv xxx.html xxx1.html        修改文件名\nmv xxx.html ../xxx.html        移动文件到上级目录\ncp xxx.html xxx.html        拷贝文件\nrm xxx.html        删除文件\ntouch xxx.html        新建文件\nvi xxx.html        新建并打开文件\n按 i 键进入编辑\n按 ESC 键退出编辑区域\n按 shift + ：键，并输入 w，保存输入的内容\n按 shift + ：键，并输入 q，退出vim编辑\n按 shift + ：键，并输入 q!，不保存内容强制退出vim编辑\n\n\nvim xxx.html        查看文件内容\ncat xxx.html        打印出文件的所有内容，在控制台查看\nhead xxx.html        打印出前几行，在控制台查看\ntail xxx.html        打印出末尾几行，在控制台查看\ngrep “aaa” xxx.html        在 xxx 文件中查找 aaa 关键字的内容\n\n\n","tags":["面试题"]},{"title":"常用模块类名命名","url":"/2022/04/01/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E7%B1%BB%E5%90%8D%E5%91%BD%E5%90%8D/","content":"行内块元素之间有默认的缝隙，可以通过 浮动 或者 定位 解决。\n\n\n\n名称\n说明\n\n\n\n快捷导航栏\nshortcut\n\n\n头部\nheader\n\n\n标志\nlogo\n\n\n购物车\nshopcar\n\n\n搜索\nsearch\n\n\n热点词\nhotwords\n\n\n导航\nnav\n\n\n导航左侧\ndropdown 包含 .dd .dt\n\n\n导航右侧\nnavitems\n\n\n页面底部\nfooter\n\n\n页面底部服务模块\nmod_service\n\n\n页面底部帮助模块\nmod_help\n\n\n页面底部版权模块\nmod_copyright\n\n\n","tags":["CSS"]},{"title":"微信小程序获取用户登录信息","url":"/2021/04/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF/","content":"wxml代码\n&lt;button type=&quot;primary&quot; plain bindtap=&quot;getUserProfile&quot;&gt; 获取头像 &lt;/button&gt;\n\njs代码\nPage(&#123;  data: &#123;    userInfo: &#123;&#125;  &#125;,  getUserProfile(e) &#123;    wx.getUserProfile(&#123;      desc: &#x27;用于完善会员资料&#x27;, // 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写      success: (res) =&gt; &#123;        console.log(res.userInfo);        const &#123;userInfo&#125; = res;        wx.setStorageSync(&quot;userinfo&quot;, userInfo);        wx.navigateBack(&#123;          delta: 1,        &#125;)      &#125;    &#125;)  &#125;,&#125;)\n\n","tags":["微信小程序"]},{"title":"微信小程序","url":"/2021/12/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/","content":"测试\n"},{"title":"运行环境","url":"/2021/04/29/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/","content":"\n运行环境即浏览器（server 端有 node.js）\n下载网页代码，渲染出页面，期间会执行若干 JS\n要保证代码在浏览器中：稳定且高效\n\n\n\n1. 网页加载过程1.1 资源的形式\nHTML 代码\n媒体文件，如图片、视频等\nJavaScript、CSS\n\n1.2 加载过程\nDNS 解析：域名 -&gt; IP地址\n浏览器根据 IP 地址向服务器发起 http 请求\n服务器处理 http 请求，并返回给浏览器\n\n1.3 渲染过程\n根据 HTML 代码生成 DOM Tree\n根据 CSS 代码生成 CSSOM\n将 DOM Tree 和 CSSOM 整合形成 Render Tree\n根据 Render Tree 渲染页面\n遇到 &lt; script &gt; 则暂停渲染，优先加载并执行 JS 代码，完成再继续\n直至把  Render Tree 渲染完成\n\n1.4 window.onload 和 DOMContentLoadedwindow.addEventListener(&#x27;load&#x27;, function () &#123;    // 页面的全部资源加载完才会执行，包括图片、视频等&#125;)window.addEventListener(&#x27;DOMContentLoaded&#x27;, function () &#123;    // DOM 渲染完即可执行，此时图片、视频还可能没有加载完&#125;)\n\n2. 网页加载和渲染的相关面试题2.1 从输入 url 到渲染出页面的整个过程\n下载资源：各个资源类型，下载过程\n渲染页面：结合 HTML、CSS、JavaScript 图片等 \n\n2.2 window.onload 和 DOMContentLoaded 的区别\nwindow.onload 资源全部加载完才会执行，包括图片\nDOMContentLoaded DOM 渲染完成即可，图片可能尚未下载\n\nconst img1 = document.getElementById(&#x27;img1&#x27;)img1.onload = function () &#123;    console.log(&#x27;img loaded&#x27;)&#125;window.addEventListener(&#x27;load&#x27;, function () &#123;    console.log(&#x27;window loaded&#x27;)&#125;)document.addEventListener(&#x27;DOMContentLoaded&#x27;, function () &#123;    console.log(&#x27;dom content loaded&#x27;)&#125;)// 控制台打印顺序如下// dom content loaded// img loaded// window loaded\n\n3. 性能优化\n是一个综合性问题，没有标准答案，但要求尽量全面\n手写防抖、节流\n\n3.1 性能优化原则\n多使用内存、缓存或其他方法\n减少 CPU 计算量，减少网络加载耗时\n（适用于所有编程的性能优化——空间换时间）\n\n3.2 从何入手\n让加载更快\n减少代码体积：压缩代码\n减少访问次数：合并代码，SSR 服务器端渲染，缓存\n使用更快的网络：CDN\n\n\n让渲染更快\nCSS 放在 head，JS 放在 body 下面\n尽早开始执行 JS，用 DOMContentLoaded 触发\n懒加载（图片懒加载，上滑加载更多）\n对 DOM 查询进行缓存\n频繁 DOM 操作，合并到一起插入 DOM 结构\n节流 throttle，防抖 debounce\n\n\n\n3.3 资源合并\n3.4 缓存\n\n静态资源加 hash 后缀，根据文件内容计算 hash\n文件内容不变，则 hash 不变，则 url 不变\nurl 和稳健不变，则会自动触发 http 缓存机制，返回 304\n\n3.5 CDN\n3.6 SSR\n服务器端渲染：将网页和数据一起加载，一起渲染\n非 SSR （前后端分离）：先加载网页，再加载数据，再渲染数据\n早先的 JSP ASP PHP，现在的 Vue React SSR\n\n3.7 懒加载\n3.8 查询 DOM 缓存\n3.9 多个 DOM 操作插入到 DOM 结构\n3.10 尽早开始 JS 执行window.addEventListener(&#x27;load&#x27;, function () &#123;    // 页面的全部资源加载完才会执行，包括图片、视频等&#125;)window.addEventListener(&#x27;DOMContentLoaded&#x27;, function () &#123;    // DOM 渲染完即可执行，此时图片、视频还可能没有加载完&#125;)\n\n4. 防抖 debounce\n监听一个输入框，文字变化后触发 change 事件\n直接用 keyup 事件，则会频繁触发 change 事件\n防抖：用户输入结束或暂停时，才会触发 change 事件\n\n&lt;body&gt;    &lt;input type=&quot;text&quot; id=&quot;input1&quot;&gt;&lt;/body&gt;\n\nconst input1 = document.getElementById(&#x27;input1&#x27;)// let timer = null// input1.addEventListener(&#x27;keyup&#x27;, function () &#123;//     if (timer) &#123;//         clearTimeout(timer)//     &#125;//     timer = setTimeout(() =&gt; &#123;//         // 模拟触发 change 事件//         console.log(input1.value)//         // 清空定时器//         timer = null//     &#125;, 500)// &#125;)// 防抖function debounce(fn, delay = 500) &#123;    // timer 是闭包中的    let timer = null    return function () &#123;        if (timer) &#123;            clearTimeout(timer)        &#125;        timer = setTimeout(() =&gt; &#123;            fn.apply(this, arguments)            timer = null        &#125;, delay)    &#125;&#125;input1.addEventListener(&#x27;keyup&#x27;, debounce(function (e) &#123;    console.log(e.target)    console.log(input1.value)&#125;, 600))\n\n5. 节流 throttle\n拖拽一个元素时，要随时拿到该元素被拖拽的位置\n直接用 drag 事件，则会频繁触发，很容易导致卡顿\n节流：无论拖拽速度多快，都会每隔 100ms 触发一次\n\n&lt;style&gt;    #div1 &#123;        border: 1px solid #ccc;        width: 200px;        height: 100px;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div id=&quot;div1&quot; draggable=&quot;true&quot;&gt;可拖拽&lt;div&gt;    &lt;script src=&quot;./throttle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;\n\nconst div1 = document.getElementById(&#x27;div1&#x27;)// let timer = null// div1.addEventListener(&#x27;drag&#x27;, function (e) &#123;//     if (timer) &#123;//         return//     &#125;//     timer = setTimeout(() =&gt; &#123;//         console.log(e.offsetX, e.offsetY)//         timer = null//     &#125;, 100)// &#125;)// 节流function throttle(fn, delay = 100) &#123;    let timer = null    return function () &#123;        if (timer) &#123;            return        &#125;        timer = setTimeout(() =&gt; &#123;            fn.apply(this, arguments)            timer = null        &#125;, delay)    &#125;&#125;div1.addEventListener(&#x27;drag&#x27;, throttle(function (e) &#123;    console.log(e.offsetX, e.offsetY)&#125;))div1.addEventListener(&#x27;drag&#x27;, function(event) &#123;&#125;)\n\n6. 安全问题：常见的 web 前端攻击方式有哪些？\n\nXSS 跨站请求共计\nXSRF 跨站请求伪造\n\n6.1 XSS 跨站请求攻击\n一个博客网站，我发表一篇博客，其中嵌入 &lt; script &gt; 脚本\n脚本内容：获取 cookie，发送到我的服务器（服务器配合跨域）\n发布这篇博客，有人查看它，我轻松收割访问者的 cookie\n\n6.2 XSS 跨站请求预防\n替换特殊字符，如 &lt; 变为 &amp; lt; &gt; 变为 &amp; gt;\n&lt; script &gt;变为 &amp; lt;script&amp; gt;，直接显示，而不会作为脚本执行\n前端要替换，后端也要替换，都做总不会有错\n\n6.3 XSRF 跨站请求伪造攻击\n你正在购物，看中了某个商品，商品 id 是 100\n付费接口是 xxx.com/pay?id=100，但没有任何验证\n我是攻击者，我看中了一个商品，id 是 200\n我向你发送一封电子邮件，邮件标题很吸引人\n但邮件正文隐藏着 &lt; img src =xxx.com/pay?id=200 /&gt;\n你一查看邮件，就帮我购买了 id 是 200 的商品\n\n6.4 XSRF 跨站请求伪造预防\n使用 post 接口\n增加验证，例如密码、短信验证码、指纹等\n\n","tags":["面试题"]},{"title":"浏览器缩小导致页面变形的解决办法","url":"/2021/07/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%A9%E5%B0%8F%E5%AF%BC%E8%87%B4%E9%A1%B5%E9%9D%A2%E5%8F%98%E5%BD%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","content":"在给页面div外层布局的时候，样式里面有时候会使用width:100%;\ndiv&#123;\twidth：100%；&#125;\n\n\n\n当我们缩小浏览器的时候页面便会发生布局变形，这时候需要给页面设置最小宽度即可。\ndiv&#123;\twidth:100%;\tmin-width:1360px; /*给最小的固定值，*/&#125;\n\n当浏览器窗口大于1360px 的时候，便会100%的适应，如果浏览器窗口缩小于1360px，布局便会按照最小值进行固定 min-width。\n","tags":["css问题"]},{"title":"黑马vue电商项目","url":"/2021/07/01/%E9%BB%91%E9%A9%ACvue%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE/","content":"电商项目运行环境配置步骤1. 项目初始化步骤\n\n\n安装 vue 脚手架\n通过 vue 脚手架创建项目\n打开 cmd 命令行，输入 vue ui，打开 vue 可视化面板\n\n\n配置 vue 路由\n配置 element-UI 组件库\n配置 axios 库\n初始化 git 远程仓库\n将本地项目托管到 GitHub\n\n后台项目的环境安装配置\n安装 MySQL 数据库\n安装 node.js 环境\n配置项目相关的信息\n启动项目\n后台数据文件 vue_api_server，先 npm install 安装依赖项，之后输入 node .\\app.js\n如果没有报错，就证明正常\n\n\n使用 postman 测试后台项目接口是否正常\n\n","tags":["运行环境"]},{"title":"黑马前端-HTML和CSS笔记","url":"/2021/10/16/%E9%BB%91%E9%A9%AC%E5%89%8D%E7%AB%AF-HTML%E5%92%8CCSS%E7%AC%94%E8%AE%B0/","content":""},{"title":"黑马前端-vue2基础-刘龙宾","url":"/2021/11/19/%E9%BB%91%E9%A9%AC%E5%89%8D%E7%AB%AF-vue2%E5%9F%BA%E7%A1%80-%E5%88%98%E9%BE%99%E5%AE%BE/","content":"推荐大家安装的 VScode 中的 Vue 插件\nVue 3 Snippets     https://marketplace.visualstudio.com/items?itemName=hollowtree.vue-snippets\nVetur                    https://marketplace.visualstudio.com/items?itemName=octref.vetur\n\n什么是 vue\n构建用户界面\n用 vue 往 html 页面中填充数据，非常的方便\n\n\n框架\n框架是一套现成的解决方案，程序员只能遵守框架的规范，去编写自己的业务功能！\n要学习 vue，就是在学习 vue 框架中规定的用法！\nvue 的指令、组件（是对 UI 结构的复用）、路由、Vuex、vue 组件库\n只有把上面老师罗列的内容掌握以后，才有开发 vue 项目的能力！\n\n\n\nvue 的两个特性\n数据驱动视图：\n\n数据的变化会驱动视图自动更新\n好处：程序员只管把数据维护好，那么页面结构会被 vue 自动渲染出来！\n\n\n双向数据绑定：\n\n在网页中，form 表单负责采集数据，Ajax 负责提交数据。\n\n\njs 数据的变化，会被自动渲染到页面上\n页面上表单采集的数据发生变化的时候，会被 vue 自动获取到，并更新到 js 数据中\n\n\n\n\n注意：数据驱动视图和双向数据绑定的底层原理是 MVVM（Mode 数据源、View 视图、ViewModel 就是 vue 的实例）\n\nvue 指令1. 内容渲染指令\nv-text 指令的缺点：会覆盖元素内部原有的内容！\n&#123;&#123; &#125;&#125; 插值表达式：在实际开发中用的最多，只是内容的占位符，不会覆盖原有的内容！\nv-html 指令的作用：可以把带有标签的字符串，渲染成真正的 HTML 内容！\n\n2. 属性绑定指令\n 注意：插值表达式只能用在元素的内容节点中，不能用在元素的属性节点中！\n\n\n在 vue 中，可以使用 v-bind: 指令，为元素的属性动态绑定值；\n\n简写是英文的 :\n\n在使用 v-bind 属性绑定期间，如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号，例如：\n&lt;div :title=&quot;&#x27;box&#x27; + index&quot;&gt;这是一个 div&lt;/div&gt;\n\n3. 事件绑定\nv-on: 简写是 @\n\n语法格式为：\n&lt;button @click=&quot;add&quot;&gt;&lt;/button&gt;methods: &#123;   add() &#123;\t\t\t// 如果在方法中要修改 data 中的数据，可以通过 this 访问到\t\t\tthis.count += 1   &#125;&#125;\n$event 的应用场景：如果默认的事件对象 e 被覆盖了，则可以手动传递一个  $event。例如：\n&lt;button @click=&quot;add(3, $event)&quot;&gt;&lt;/button&gt;methods: &#123;   add(n, e) &#123;\t\t\t// 如果在方法中要修改 data 中的数据，可以通过 this 访问到\t\t\tthis.count += 1   &#125;&#125;\n事件修饰符：\n\n.prevent\n&lt;a @click.prevent=&quot;xxx&quot;&gt;链接&lt;/a&gt;\n.stop\n&lt;button @click.stop=&quot;xxx&quot;&gt;按钮&lt;/button&gt;\n\n\n\n4. v-model 指令\ninput 输入框\ntype=”radio”\ntype=”checkbox”\ntype=”xxxx”\n\n\ntextarea\nselect\n\n5. 条件渲染指令\nv-show 的原理是：动态为元素添加或移除 display: none 样式，来实现元素的显示和隐藏\n如果要频繁的切换元素的显示状态，用 v-show 性能会更好\n\n\nv-if 的原理是：每次动态创建或移除元素，实现元素的显示和隐藏\n如果刚进入页面的时候，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示出来，此时 v-if 性能更好\n\n\n\n\n 在实际开发中，绝大多数情况，不用考虑性能问题，直接使用 v-if 就好了！！！\n\nv-if 指令在使用的时候，有两种方式：\n\n直接给定一个布尔值 true 或 false\n&lt;p v-if=&quot;true&quot;&gt;被 v-if 控制的元素&lt;/p&gt;\n给 v-if 提供一个判断条件，根据判断的结果是 true 或 false，来控制元素的显示和隐藏\n&lt;p v-if=&quot;type === &#x27;A&#x27;&quot;&gt;良好&lt;/p&gt;\n\n过滤器过滤器的注意点\n要定义到 filters 节点下，本质是一个函数\n在过滤器函数中，一定要有 return 值\n在过滤器的形参中，可以获取到“管道符”前面待处理的那个值\n如果全局过滤器和私有过滤器名字一致，此时按照“就近原则”，调用的是”私有过滤器“\n\nwatch 侦听器侦听器的格式\n方法格式的侦听器\n缺点1：无法在刚进入页面的时候，自动触发！！！\n缺点2：如果侦听的是一个对象，如果对象中的属性发生了变化，不会触发侦听器！！！\n\n\n对象格式的侦听器\n好处1：可以通过 immediate 选项，让侦听器自动触发！！！\n好处2：可以通过 deep 选项，让侦听器深度监听对象中每个属性的变化！！！\n\n\n\n计算属性特点：\n\n定义的时候，要被定义为“方法”\n在使用计算属性的时候，当普通的属性使用即可\n\n好处：\n\n实现了代码的复用\n只要计算属性中依赖的数据源变化了，则计算属性会自动重新求值！\n\naxios\naxios 是一个专注于网络请求的库！\n\naxios 的基本使用\n发起 GET 请求：\naxios(&#123;  // 请求方式  method: &#x27;GET&#x27;,  // 请求的地址  url: &#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;,  // URL 中的查询参数  params: &#123;    id: 1  &#125;&#125;).then(function (result) &#123;  console.log(result)&#125;)\n发起 POST 请求：\ndocument.querySelector(&#x27;#btnPost&#x27;).addEventListener(&#x27;click&#x27;, async function () &#123;  // 如果调用某个方法的返回值是 Promise 实例，则前面可以添加 await！  // await 只能用在被 async “修饰”的方法中  const &#123; data: res &#125; = await axios(&#123;    method: &#x27;POST&#x27;,     url: &#x27;http://www.liulongbin.top:3006/api/post&#x27;,    data: &#123;      name: &#x27;zs&#x27;,      age: 20    &#125;  &#125;)  console.log(res)&#125;)\n\nvue-cli 的使用\n在终端下运行如下的命令，创建指定名称的项目：\nvue cerate 项目的名称\nvue 项目中 src 目录的构成：\nassets 文件夹：存放项目中用到的静态资源文件，例如：css 样式表、图片资源components 文件夹：程序员封装的、可复用的组件，都要放到 components 目录下main.js 是项目的入口文件。整个项目的运行，要先执行 main.jsApp.vue 是项目的根组件。\n\n","categories":["黑马前端"],"tags":["VUE"]},{"title":"CSS布局相关","url":"/2021/12/22/CSS%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3/","content":"长度绝对长度单位px 像素\n相对长度单位相对长度单位相对于其他一些东西，比如父元素的字体大小，或者视图端口的大小。使用相对单位的好处是，经过一些仔细的规划，您可以使文本或其他元素的大小与页面上的其他内容相对应。\n\n\n\n单位名称\n作用\n\n\n\nem\n在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小\n\n\nrem\n根元素的字体大小\n\n\nvm\n视窗宽度的 1%\n\n\nvh\n视窗高度的 1%\n\n\nCSS 盒模型的注意点\npadding 不能为负值，而 margin 可以为负值（紧挨着的下面的盒子会盖住margin为负值的盒子）\n背景色会平铺到非 margin 的区域\nmargin-top 传递的现象及解决方案\nmargin 上下叠加的现象及解决方案\n\n块级盒子和内联盒子块级盒子（block-box）：div、p、h1…\n内联盒子（inline-box）：span、a、strong…\n块级盒子的特性\n独占一行\n支持所有样式\n不写宽度的时候，跟父容器的宽度相同\n所占区域是一个矩形\n\n内联盒子的特性\n盒子不会产生换行\n有些样式不支持，例如：width、height等\n不写宽度的时候，宽度由内容决定\n所占的区域不一定是矩形\n内联标签之间会有空隙\n\n自适应盒模型的特性自适应盒模型指的是，当盒子不设置宽度时，盒模型相关组成部分的处理方式是如何的。\n如果父盒子嵌套子盒子，父盒子设置宽度，子盒子不设置宽度（让其继承父盒子的宽度），则给子盒子设置padding、border、margin，则不会溢出父盒子。\n标准盒模型与怪异盒模型\n在标准模型中，如果给盒子设置 width 和 height，实际设置的是 content box。padding 和 border 再加上设置的宽高一起决定整个盒子的大小\n\n\n\n在怪异模型中，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分\n\n\nbox-sizing 属性\ncontent-box：width、height → content\nborder-box：width、height → content + padding + border\n应用1：量取尺寸时不用再去计算一些值\n应用2：解决一些需要设置百分比的盒模型值\n\n浮动样式详解\n当元素被浮动时，会脱离文档流，根据 float 的值向左或向右移动，直到它的外边界碰到父元素的内边界或另一个浮动元素的外边界为止，是 CSS 布局中实现左右布局的一种方式\n文档流：文档流是元素在 Web 页面上的一种呈现方式，按照出现的先后顺序进行排列\n\n清除浮动的方案\nclear 属性：给浮动的盒子相邻的盒子添加 clear:both 属性\nBFC\n空标签\n.clearfix::after{}\n\n&lt;style&gt;    .box1 &#123;        width: 200px;        border: 1px black solid;    &#125;    .box2 &#123;        width: 100px;        height: 100px;        background: pink;        float: left;    &#125;    .clearfix::after &#123;        content: &#x27;&#x27;;        display: block;        clear: both;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;box1 clearfix&quot;&gt;        &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\n浮动特性注意点\n只会影响后面的元素\n文本不会被浮动元素覆盖\n具备内联盒子特性：宽度由内容决定\n具备块级盒子特性：支持所有样式\n浮动放不下，会自动换行\n\n定位样式详解\nCSS position 属性用于指定一个元素在文档中的定位方式，其中 top，right，bottom 和 left 属性则决定了该元素的最终位置\nposition\nstatic 默认值\nrelative 相对定位\nabsolute 绝对定位\nsticky 粘性定位\nfixed 固定定位\n\n\n\n相对定位及特性\n相对定位的元素是在文档中的正常位置偏移给定的值\n不影响其他元素布局\n相对于自身进行偏移\n\n绝对定位及特性\n绝对定位的元素脱离了文档流，绝对定位的元素不占据空间\n具备内联盒子特性：宽度由内容决定（如果不设置宽度）\n具备块级盒子特性：支持所有样式\n绝对定位元素相对于最近的非 static 祖先元素定位。当这样的祖先元素不存在时，则相对于可视区域定位\n\n固定定位及特性\n固定定位与绝对定位相似，但是会固定在可视区域中\n具备内联盒子特性：宽度由内容决定（如果不设置宽度）\n具备块级盒子特性：支持所有样式\n固定定位元素不受祖先元素影响\n\n黏性定位及特性\n黏性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位\n\nflex 弹性布局flex弹性概念\n弹性盒子是一种用于按行或按列布局元素的一维布局方法。元素可以膨胀以填充额外的空间，收缩以适应更小的空间\n\n主轴与交叉轴\nflex 容器与 flex 子项\n改变轴方向flex-direction：\n\nrow（默认）：主轴方向从左到右\nrow-reverse：主轴方向从右到左\ncolumn：主轴方向从上到下\ncolumn-reverse：主轴方向从下到上\n\n换行与缩写flex-wrap：\n\nnowrap（默认）：一行排列\nwrap：换行排列 \nwrap-reverse：从盒子底部开始排列\n\n缩写：\nflex-flow：flex-direction  flex-wrap\n如：flex-flow：column wrap\n主轴对齐详解justify-content：\n\nflex-start（默认）：靠左\nflex-end：靠右\ncenter：居中\nspace-around：平分左右空间\nspace-between：两端不留空隙，中间平分\nspace-evenly：子项左右的空间都是相等的\n\n交叉轴对齐详解align-content：\n当不使用换行（flex-wrap: wrap）的时候，以下的属性都是不生效的\n\nstretch（默认）\nflex-start\nflex-end\ncenter\nspace-around\nspace-between\nspace-evenly\n\nalign-item：\n\nstretch（默认）\nflex-start：顶对齐\nflex-end：底对齐\ncenter：居中\nbaseline：基线对齐\n\n内联与块的上下左右居中布局\n&lt;style&gt;    .box &#123;        width: 300px;        height: 200px;        background-color: skyblue;        display: flex;        justify-content: center;        align-items: center;    &#125;    .box div &#123;        width: 100px;        height: 100px;        background-color: pink;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;        &lt;div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\n不定项居中布局\n&lt;style&gt;    .box &#123;        width: 300px;        height: 150px;        background-color: skyblue;        display: flex;        justify-content: center;        align-items: flex-end;    &#125;    .box div &#123;        width: 30px;        height: 30px;        background-color: pink;        border-radius: 50%;        margin: 5px;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;        &lt;div&gt;&lt;/div&gt;        &lt;div&gt;&lt;/div&gt;        &lt;div&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\n均匀分列布局\n&lt;style&gt;    .main &#123;        height: 200px;        background-color: skyblue;        display: flex;        justify-content: space-between;        align-items: flex-end;        padding: 0 20px;    &#125;    .main div &#123;        width: 30px;        height: 30px;        background-color: pink;        border-radius: 50%;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;main&quot;&gt;        &lt;div&gt;&lt;/div&gt;      \t&lt;div&gt;&lt;/div&gt;      \t&lt;div&gt;&lt;/div&gt;      \t&lt;div&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\n子项分组布局\n&lt;style&gt;    .main &#123;        height: 200px;        background-color: skyblue;        display: flex;        align-items: center;    &#125;    .main div &#123;        width: 50px;        height: 100px;        background-color: pink;        margin-right: 10px;    &#125;    /* 下面两行代码是同样的效果 */    /* .main div:nth-of-type(1) &#123;    \t\tmargin-right: auto;    &#125; */    .main div:nth-child(1) &#123;        margin-right: auto;    &#125;    .main div:nth-child(4) &#123;        margin-right: auto;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;main&quot;&gt;        &lt;div&gt;1&lt;/div&gt;        &lt;div&gt;2&lt;/div&gt;      \t&lt;div&gt;3&lt;/div&gt;      \t&lt;div&gt;3&lt;/div&gt;      \t&lt;div&gt;3&lt;/div&gt;      \t&lt;div&gt;3&lt;/div&gt;      \t&lt;div&gt;3&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\nflex 子项flex-grow 扩展比例默认值是 0，表示不占用剩余的空白间隙扩展自己的宽度\n如果所有的兄弟项都有相同的 flex-grow 系数，那么所有的项目将剩余空间按相同比例分配，否则将根据不同的 flex-grow 定义的比例进行分配\n如果两个兄弟项分别占 0.3 和 0.4，剩余空间有1000px，那么就会把剩余的总长度分为 10 份，第一项增加的长度为 3 份，第二项增加的长度为 4 份\n如果两个兄弟项分别占 2 和 1，剩余空间有1000px，那么就会把剩余的总长度分为 3 份，然后第一项增加的长度为 3分之2 和 第二项增加的长度为 3分之1\n&lt;style&gt;    .main &#123;        width: 500px;        height: 300px;        background-color: skyblue;        display: flex;    &#125;    .main div &#123;        width: 100px;        height: 100px;        background-color: pink;        /* flex-grow: 0; 默认值 */        /* 如果比例值为1，就占满剩余的所有空间 */        /* 400 * 0.5 -&gt; 200 + 100 -&gt; 300 */        /* flex-grow: 0.5; */        /* 当比例值大于等于1的时候，都会占满剩余的所有空间 */        flex-grow: 2;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;main&quot;&gt;        &lt;div&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\nflex-shrink 收缩比例默认值是1，表示 flex 容器空间不足时，元素的收缩比例\n&lt;style&gt;    .main &#123;        width: 500px;        height: 200px;        background-color: skyblue;        display: flex;    &#125;    .main div &#123;        width: 600px;        height: 100px;        background-color: pink;        /* flex-shrink: 1; 该属性为默认值，使用flex布局时默认生效。自动收缩，跟容器大小相同 */        /* flex-shrink: 0;  不进行自动收缩，超出的部分会显示 */        /* flex-shrink: 0.5; 进行收缩，展示出的长度为超出部分的二分之一 */      &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;main&quot;&gt;        &lt;div&gt;1&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\n\nflex-basis默认值是 auto，指定了 flex元素在主轴方向上的初始大小\n&lt;style&gt;    .main &#123;        width: 500px;        height: 500px;        background-color: skyblue;        display: flex;        align-items: flex-start;    &#125;    .main div &#123;        background-color: pink;        flex-basis: 100%; /* 可选值类型：0、auto、200px、100% */    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;main&quot;&gt;        &lt;div&gt;测试文字&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\nflex 缩写flex 属性是 flex-grow、flex-shrink 和 flex-basis 的属性\nflex：1 0 50%表示的就是\n​    flex-grow：1;\n​    flex-shrink: 0;\n​    flex-basis: 50%\norder默认值是 0，改变某一个 flex 子项的排序位置\nalign-self默认值是 auto，控制单独某一个 flex 子项的垂直对齐方式\n等高布局\n&lt;style&gt;    .main &#123;        width: 500px;        background-color: skyblue;        display: flex;        justify-content: space-between;    &#125;    .main div &#123;        width: 100px;        background-color: pink;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;main&quot;&gt;        &lt;div&gt;            &lt;p&gt;测试内容&lt;/p&gt;        \t&lt;p&gt;测试内容&lt;/p&gt;        &lt;/div&gt;        &lt;div&gt;            &lt;p&gt;测试内容&lt;/p&gt;        \t&lt;p&gt;测试内容&lt;/p&gt;        \t&lt;p&gt;测试内容&lt;/p&gt;        \t&lt;p&gt;测试内容&lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\n两列与三列布局\n两列布局代码：\n&lt;style&gt;    body &#123;        margin: 0;    &#125;    .main &#123;        height: 100vh;        background-color: skyblue;        display: flex;    &#125;    .coll1 &#123;        width: 200px;        background-color: pink;    &#125;    .coll2 &#123;        flex-grow: 1;        background-color: red;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;main&quot;&gt;        &lt;div class=&quot;coll1&quot;&gt;&lt;/div&gt;      \t&lt;div class=&quot;coll2&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\n三列布局代码：\n&lt;style&gt;    body &#123;        margin: 0;    &#125;    .main &#123;        height: 100vh;        background-color: skyblue;        display: flex;    &#125;    .coll1 &#123;        width: 200px;        background-color: pink;    &#125;    .coll2 &#123;        flex-grow: 1;        background-color: red;    &#125;    .coll3 &#123;        width: 400px;        background-color: yellow;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;main&quot;&gt;        &lt;div class=&quot;coll1&quot;&gt;&lt;/div&gt;      \t&lt;div class=&quot;coll2&quot;&gt;&lt;/div&gt;      \t&lt;div class=&quot;coll3&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\nSticky Footer 布局\n&lt;style&gt;    body &#123;        margin: 0;    &#125;    .main &#123;        min-height: 100vh;        display: flex;        flex-direction: column;    &#125;    .herder &#123;        height: 100px;        background-color: pink;    &#125;    .content &#123;        flex-grow: 1;    &#125;    .footer &#123;        height: 100px;        background-color: skyblue;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;main&quot;&gt;        &lt;div class=&quot;herder&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;content&quot;&gt;            &lt;p&gt;测试内容&lt;/p&gt;        \t&lt;p&gt;测试内容&lt;/p&gt;        \t&lt;p&gt;测试内容&lt;/p&gt;        \t&lt;p&gt;测试内容&lt;/p&gt;        \t&lt;p&gt;测试内容&lt;/p&gt;        &lt;/div&gt;        &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\n溢出项布局\n&lt;style&gt;    .main &#123;        height: 100px;        background-color: skyblue;        display: flex;        align-items: center;    &#125;    .main div &#123;        width: 100px;        height: 80px;        background-color: pink;        margin-right: 10px;        flex-shrink: 0;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;main&quot;&gt;        &lt;div&gt;1&lt;/div&gt;      \t&lt;div&gt;2&lt;/div&gt;      \t&lt;div&gt;3&lt;/div&gt;      \t&lt;div&gt;4&lt;/div&gt;      \t&lt;div&gt;5&lt;/div&gt;      \t&lt;div&gt;6&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\nSwiper 轮播图案例\n&lt;link rel=&quot;stylesheet&quot; href=&quot;iconfont.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;reset.css&quot; /&gt;&lt;style&gt;    .swiper-container &#123;        position: relative;    &#125;    .swiper-wrapper &#123;        display: flex;    &#125;    .swiper-slide &#123;        width: 100%;        flex-shrink: 0;    &#125;    .swiper-slide img &#123;        width: 100%;    &#125;    .swiper-pagination &#123;        position: absolute;        height: 28px;        width: 100%;        bottom: 0;        display: flex;        justify-content: center;        align-items: center;    &#125;    .swiper-pagination-bullet &#123;        width: 8px;        height: 8px;        margin: 0 4px;        border-radius: 50%;        background-color: #c6bcaf;    &#125;    .swiper-pagination-bullet-active &#123;        background-color: #fff;    &#125;    .swiper-button-prev &#123;        position: absolute;        top: 0;        left: 0;        height: 100%;        display: flex;        align-items: center;    &#125;    /* 下面一项为错误演示，请按照上面一项代码使用 */    .swiper-button-next &#123;        position: absolute;        right: 0;        top: 50%;    &#125;    .swiper-button-prev i,    .swiper-button-next i &#123;        font-size: 40px;        color: #fff;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;swiper-container&quot;&gt;        &lt;div class=&quot;swiper-wrapper&quot;&gt;            &lt;div class=&quot;swiper-slide&quot;&gt;                &lt;img src=&quot;https://m.360buyimg.com/mobilecms/s700x280_jfs/t1/219977/3/8702/95963/61c30c97E311f9a17/770a6c819bb120fa.jpg!cr_1053x420_4_0!q70.jpg.dpg&quot; alt=&quot;&quot; /&gt;            &lt;/div&gt;            &lt;div class=&quot;swiper-slide&quot;&gt;                &lt;img src=&quot;//m.360buyimg.com/mobilecms/s700x280_jfs/t1/221030/17/4257/106025/61a44d81E4b7fe423/488b8e53f1a098ac.jpg!cr_1053x420_4_0!q70.jpg.dpg&quot; alt=&quot;&quot; /&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;!-- 如果需要分页器 --&gt;        &lt;div class=&quot;swiper-pagination&quot;&gt;            &lt;span class=&quot;swiper-pagination-bullet swiper-pagination-bullet-active&quot;&gt;&lt;/span&gt;            &lt;span class=&quot;swiper-pagination-bullet&quot;&gt;&lt;/span&gt;            &lt;span class=&quot;swiper-pagination-bullet&quot;&gt;&lt;/span&gt;        &lt;/div&gt;                &lt;!-- 如果需要导航按钮 --&gt;        &lt;div class=&quot;swiper-button-prev&quot;&gt;            &lt;i class=&quot;iconfont icon-swiperhoutui&quot;&gt;&lt;/i&gt;        &lt;/div&gt;        &lt;div class=&quot;swiper-button-next&quot;&gt;            &lt;i class=&quot;iconfont icon-swiperqianjin&quot;&gt;&lt;/i&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\n知乎导航\n&lt;link rel=&quot;stylesheet&quot; href=&quot;reset.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;iconfont.css&quot; /&gt;&lt;style&gt;    body &#123;        background-color: #f6f6f6;    &#125;    .header-container &#123;        background-color: #fff;    &#125;    .header-wrapper &#123;        margin: 0 auto;        height: 52px;        min-width: 1000px;        max-width: 1156px;        display: flex;        align-items: center;    &#125;    .header-logo &#123;        margin-right: 40px;    &#125;    .header-nav &#123;        display: flex;    &#125;    .header-nav li &#123;        margin-right: 30px;    &#125;    .header-search &#123;        flex-grow: 1;        display: flex;        justify-content: center;    &#125;    .header-search-wrapper &#123;        max-width: 482px;        height: 34px;        flex-grow: 1;        display: flex;        align-items: center;        justify-content: space-between;        background-color: #f6f6f6;        border-radius: 100px;    &#125;    .header-search-input &#123;        border: none;        background: none;        margin: 0 20px;    &#125;    .header-search-wrapper i &#123;        margin: 0 20px;    &#125;    .header-btn &#123;        display: flex;    &#125;    .header-btn-login &#123;        width: 60px;        height: 32px;        border: 1px #0066ff solid;        border-radius: 3px;        color: #0066ff;        background: none;        cursor: pointer;        display: block;        margin-left: 20px;    &#125;    .header-btn-join &#123;        width: 90px;        height: 32px;        background-color: #0066ff;        color: white;        border: none;        border-radius: 3px;        display: block;        margin-left: 20px;        cursor: pointer;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;header-container&quot;&gt;        &lt;div class=&quot;header-wrapper&quot;&gt;            &lt;div class=&quot;header-logo&quot;&gt;                &lt;a href=&quot;#&quot;&gt;                    &lt;img src=&quot;logo.png&quot; alt=&quot;&quot; /&gt;                &lt;/a&gt;            &lt;/div&gt;            &lt;ul class=&quot;header-nav&quot;&gt;                &lt;li&gt;首页&lt;/li&gt;          \t\t&lt;li&gt;会员&lt;/li&gt;          \t\t&lt;li&gt;发现&lt;/li&gt;          \t\t&lt;li&gt;等你来答&lt;/li&gt;        \t&lt;/ul&gt;            &lt;div class=&quot;header-search&quot;&gt;                &lt;div class=&quot;header-search-wrapper&quot;&gt;                    &lt;input class=&quot;header-search-input&quot; type=&quot;text&quot; placeholder=&quot;520文案&quot; /&gt;                    &lt;i class=&quot;iconfont icon-fangdajing&quot;&gt;&lt;/i&gt;                &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;header-btn&quot;&gt;                &lt;button class=&quot;header-btn-login&quot;&gt;登录&lt;/button&gt;                &lt;button class=&quot;header-btn-join&quot;&gt;加入知乎&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\ngrid 网格布局CSS 网格是一个用于 web 的二维布局系统。利用网格，可以把内容按照行与列的格式进行排版。另外，网格还能非常轻松地实现一些复杂的布局。\ngrid 容器\ngrid 子项\n","categories":["静态页面布局"],"tags":["CSS"]},{"title":"黑马前端-JS基础笔记","url":"/2021/10/16/%E9%BB%91%E9%A9%AC%E5%89%8D%E7%AB%AF-JS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/","content":"JS 的组成\n\nDOM —— 文档对象模型文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。 通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。\nBOM —— 浏览器对象模型BOM (Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行 互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。 \nJS 书写位置行内式&lt;input type=&quot;button&quot; value=&quot;点我试试&quot; onclick=&quot;alert(&#x27;Hello World&#x27;)&quot; /&gt;\n\n\n可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），如：onclick \n注意单双引号的使用：在HTML中我们推荐使用双引号, JS 中我们推荐使用单引号\n可读性差， 在html中编写JS大量代码时，不方便阅读；\n引号易错，引号多层嵌套匹配时，非常容易弄混；\n特殊情况下使用\n\n内嵌式&lt;script&gt;     alert(&#x27;Hello  World~!&#x27;); &lt;/script&gt; \n\n\n可以将多行JS代码写到 &lt; script &gt;标签中\n内嵌 JS 是学习时常用的方式 \n\n外部文件&lt;script src=&quot;my.js&quot;&gt;&lt;/script&gt; \n\n\n利于HTML页面代码结构化，把大段 JS代码独立到 HTML 页面之外，既美观，也方便文件级别的复用\n引用外部 JS文件的 script 标签中间不可以写代码\n适合于JS 代码量比较大的情况\n\nJS 注释单行注释为了提高代码的可读性，JS与CSS一样，也提供了注释功能。JS中的注释主要有两种，分别是单行注释和多行注释。\n// 我是一行文字，不想被JS引擎执行，所以注释起来 \n\n//  用来注释单行文字（  快捷键   ctrl  +  /   ）\n多行注释/* 获取用户年龄和姓名   并通过提示框显示出来 */ \n\n/* */  用来注释多行文字（ 默认快捷键  alt +  shift  + a ）\n快捷键修改为：   ctrl + shift  +  /  \nvscode → 首选项按钮  →  键盘快捷方式 →  查找原来的快捷键  → 修改为新的快捷键 → 回车确认 \nJS 输入输出语句\n\n\n方法\n说明\n归属\n\n\n\nalert(msg)\n浏览器弹出警示框\n浏览器\n\n\nconsole.log(msg)\n浏览器控制台打印输出信息\n浏览器\n\n\nprompt(info)\n浏览器弹出输入框，用户可以输入\n浏览器\n\n\n注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息\n变量什么是变量白话：变量就是一个装东西的盒子。 \n通俗：变量是用于存放数据的容器。 我们通过 变量名 获取数据，甚至数据可以修改。\n本质：变量是程序在内存中申请的一块用来存放数据的空间。 \n类似我们酒店的房间，一个房间就可以看做是一个变量。\n\n变量的使用变量在使用时分为两步： 1. 声明变量   2. 赋值 \n声明变量//  声明变量   var age; //  声明一个 名称为age 的变量  \n\n\nvar 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配 内存空间，不需要程序员管\nage 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间 \n\n赋值age = 10; // 给 age  这个变量赋值为 10 \n\n\n= 用来把右边的值赋给左边的变量空间中   此处代表赋值的意思\n变量值是程序员保存到变量空间里的值 \n\n变量的初始化var age  = 18;  // 声明变量同时赋值为 18\n\n声明一个变量并赋值， 我们称之为变量的初始化。\n变量语法扩展更新变量一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。\nvar age = 18; age = 81;   // 最后的结果就是81因为18 被覆盖掉了   \n\n同时声明多个变量同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。\nvar age = 10,  name = &#x27;zs&#x27;, sex = 2;\n\n声明变量特殊情况\n\n\n情况\n说明\n结果\n\n\n\nvar  age ; console.log (age);\n只声明 不赋值\nundefined\n\n\nconsole.log(age)\n不声明 不赋值  直接使用\n报错\n\n\nage   = 10; console.log (age);\n不声明 只赋值\n10\n\n\n变量命名规范\n由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name\n严格区分大小写。var app; 和 var App; 是两个变量\n不能 以数字开头。  18age   是错误的 \n不能 是关键字、保留字。例如：var、for、while \n变量名必须有意义。 MMD   BBD        nl   →     age   \n遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。 myFirstName \n推荐翻译网站： 有道    爱词霸 \n\n数据类型变量的数据类型变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的 内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会 被自动确定。 \nvar age = 10;        // 这是一个数字型 var areYouOk = &#x27;是的&#x27;;   // 这是一个字符\n\n在代码运行时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运\n行完毕之后， 变量就确定 了数据类型。 \nJavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型： \nvar x = 6;           // x 为数字 var x = &quot;Bill&quot;;      // x 为字符串 \n\n数据类型分类JS 把数据类型分为两类：\n\n简单数据类型 （Number,String,Boolean,Undefined,Null） \n复杂数据类型 （object)\n\n简单数据类型（基本数据类型）\n\n\n简单数据类型\n说明\n默认值\n\n\n\nNumber\n数字型，包含 整型值 和 浮点型值，如 21、0.21\n0\n\n\nBoolean\n布尔值类型，如 true、false，等价于 1 和 0\nfalse\n\n\nString\n字符串类型，如”张三“。注意：JS里面，字符串都带引号\n” “\n\n\nUndefined\nvar a; 声明了变量 a 但是没有给值，此时 a = undefined\nundefined\n\n\nNull\nvar a = null; 声明了变量 a 为空值\nnull\n\n\n数字型 NumberJavaScript 数字类型既可以用来保存整数值，也可以保存小数(浮点数）。 \nvar age = 21;       // 整数 var Age = 21.3747;  // 小数\n\n数字型进制最常见的进制有二进制、八进制、十进制、十六进制。\n// 1.八进制数字序列范围：0~7  var num1 = 07;   // 对应十进制的7  var num2 = 019;  // 对应十进制的19  var num3 = 08;   // 对应十进制的8// 2.十六进制数字序列范围：0~9以及A~F  var num = 0xA; \n\n现阶段我们只需要记住，在JS中八进制前面加0，十六进制前面加 0x\n数字型范围JavaScript中数值的最大和最小值\nalert(Number.MAX_VALUE); // 1.7976931348623157e+308 alert(Number.MIN_VALUE); // 5e-324 \n\n\n最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308 \n最小值：Number.MIN_VALUE，这个值为：5e-32 \n\n数字型三个特殊值alert(Infinity);  // Infinity alert(-Infinity); // -Infinity alert(NaN);       // NaN\n\n\nInfinity ，代表无穷大，大于任何数值 \n-Infinity ，代表无穷小，小于任何数值 \nNaN ，Not a number，代表一个非数值\n\nisNaN()用来判断一个变量是否为非数字的类型，返回 true 或者 false\n\nvar usrAge = 21; var isOk = isNaN(userAge); console.log(isNum);            // false ，21 不是一个非数字 var usrName = &quot;andy&quot;; console.log(isNaN(userName));  // true ，&quot;andy&quot;是一个非数字\n\n字符串型 String字符串型可以是引号中的任意文本，其语法为 双引号 “” 和 单引号’’ \nvar strMsg = &quot;我爱北京天安门~&quot;;  // 使用双引号表示字符串 var strMsg2 = &#x27;我爱吃猪蹄~&#x27;;    // 使用单引号表示字符串// 常见错误 var strMsg3 = 我爱大肘子;       // 报错，没使用引号，会被认为是js代码，但js没有这些语法 \n\n因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用单引号。\n字符串引号嵌套JS 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (外双内单，外单内双)\nvar strMsg = &#x27;我是&quot;高帅富&quot;程序猿&#x27;;   // 可以用&#x27;&#x27;包含&quot;&quot; var strMsg2 = &quot;我是&#x27;高帅富&#x27;程序猿&quot;;  // 也可以用&quot;&quot; 包含&#x27;&#x27; //  常见错误 var badQuotes = &#x27;What on earth?&quot;; // 报错，不能 单双引号搭配\n\n字符串转义符类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。 \n转义符都是 \\ 开头的，常用的转义符及其说明如下： \n\n\n\n转义符\n解释说明\n\n\n\n\\n\n换行符，n 是 newline 的意思\n\n\n\\ \\\n斜杠 \\\n\n\n\\ ‘\n‘  单引号\n\n\n\\ “\n”  双引号\n\n\n\\t\ntab  缩进\n\n\n\\b\n空格 ，b 是 blank  的意思\n\n\n字符串长度字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度。\nar strMsg = &quot;我是帅气多金的程序猿！&quot;; alert(strMsg.length); // 显示 11\n\n字符串拼接\n多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串\n拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串 \n\n//1.1 字符串 &quot;相加&quot; alert(&#x27;hello&#x27; + &#x27; &#x27; + &#x27;world&#x27;); // hello world //1.2 数值字符串 &quot;相加&quot; alert(&#x27;100&#x27; + &#x27;100&#x27;); \t// 100100 //1.3 数值字符串 + 数值 alert(&#x27;11&#x27; + 12);     \t// 1112\n\n+号总结口诀：数值相加 ，字符相连\n字符串拼接加强console.log(&#x27;pink老师&#x27; + 18);           // 只要有字符就会相连  var age = 18; // console.log(&#x27;pink老师age岁啦&#x27;);       // 这样不行哦 console.log(&#x27;pink老师&#x27; + age);          // pink老师18 console.log(&#x27;pink老师&#x27; + age + &#x27;岁啦&#x27;);  // pink老师18岁啦\n\n\n我们经常会将字符串和变量来拼接，因为变量可以很方便地修改里面的值\n变量是不能添加引号的，因为加引号的变量会变成字符串\n如果变量两侧都有字符串拼接，口诀“引引加加 ”，删掉数字，变量写在加号中间 \n\n布尔值 Boolean布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。\n布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。\nconsole.log(true + 1);  // 2 console.log(false + 1); // 1\n\nUndefined 和 Null一个声明后没有被赋值的变量会有一个默认值 undefined ( 如果进行相连或者相加时，注意结果）\nundefined 和数字相加，最后的结果是 NaN\nvar variable; console.log(variable);           // undefined console.log(&#x27;你好&#x27; + variable);  // 你好undefined console.log(11 + variable);     // NaN console.log(true + variable);   //  NaN\n\n一个声明变量给 null 值，里面存的值为空（学习对象时，我们继续研究null) \nvar vari = null; console.log(&#x27;你好&#x27; + vari);  // 你好null console.log(11 + vari);     // 11 console.log(true + vari);   //  1\n\n获取变量数据类型检测变量的数据类型typeof 可用来获取检测变量的数据类型\nvar num = 18; console.log(typeof num) // 结果 number\n\n不同类型的返回值\n\n\n\n类型\n例\n结果\n\n\n\nString\ntypeof ”小白“\n”string“\n\n\nNumber\ntypeof 18\n”number“\n\n\nBoolean\ntypeof true\n”boolean“\n\n\nUndefined\ntypeof undefined\n“undefined”\n\n\nNull\ntypeof null\n”object“\n\n\n字面量字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。\n\n字面量：8, 9, 10\n字符串字面量：’黑马程序员’, “大前端”\n布尔字面量：true，false\n\n数据类型转换使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加\n法运算，而需要转换变 量的数据类型。通俗来说，就是把一种数据类型的变量转换成另\n外一种数据类型。 \n我们通常会实现3种方式的转换： \n\n转换为字符串类型\n转换为数字型\n转换为布尔型\n\n转换为字符串\n\n\n方式\n说明\n案例\n\n\n\ntoString()\n转成字符串\nvar num = 1;alert(num.toString());\n\n\nString() 强制转换\n转成字符串\nvar num = 1; alert(String(num));\n\n\n加号拼接字符串\n和字符串拼接的结果都是字符串\nvar num = 1; alert(num + “我是字符串”);\n\n\n\ntoString() 和 String()  使用方式不一样。\n三种转换方式，我们更喜欢用第三种加号拼接字符串（可以是空字符串）转换方式， 这一种方式也称之为隐式转换。\n\n转换为数字型（重点）\n\n\n方式\n说明\n案例\n\n\n\nparseInt(string) 函数\n将 string 类型转换成整数数值型\nparseInt(‘78’);\n\n\nparseFloat(string) 函数\n将 string 类型转换成浮点数数值型\nparseFloat(‘78.21’);\n\n\nNumber() 强制转换函数\n将 string 类型转换成数值型\nNumber(‘12’);\n\n\njs 隐式转换（ -  *  / ）\n利用算术运算隐式转换为数值型\n‘12’-0;\n\n\n\n注意 parseInt 和 parseFloat 单词的大小写，这2个是重点\n隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型\n\n转换为布尔型\n\n\n方式\n说明\n案例\n\n\n\nBoolean() 函数\n其他类型转成布尔型\nBoolean(‘true’);\n\n\n\n代表空、否定的值会被转换为 false  ，如 ‘’、0、NaN、null、undefined\n其余值都会被转换为 true\n\nconsole.log(Boolean(&#x27;&#x27;)); // false console.log(Boolean(0)); // false console.log(Boolean(NaN)); // false console.log(Boolean(null)); // false console.log(Boolean(undefined)); // false console.log(Boolean(&#x27;小白&#x27;)); // true console.log(Boolean(12)); // true\n\n扩展解释型语言和编译型语言概述计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言\n翻译成机器语言才能执行 程序。程序语言翻译成机器语言的工具，被称为翻译器。\n\n\n翻译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同\n编译器是在代码执行之前进行编译，生成中间代码文件\n解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候，也称之为解释器)\n\n执行过程\n类似于请客吃饭： \n\n编译语言：首先把所有菜做好，才能上 桌吃饭\n解释语言：好比吃火锅，边吃边涮，同时进行\n\n标识符、关键字、保留字标识符标识(zhi)符：就是指开发人员为变量、属性、函数、参数取的名字。 \n标识符不能是关键字或保留字。\n关键字关键字：是指 JS本身已经使用了的字，不能再用它们充当变量名、方法名。 \n包括：break、case、catch、continue、default、delete、do、else、finally、for、\nfunction、if、in、 instanceof、new、return、switch、this、throw、try、typeof、\nvar、void、while、with 等。 \n保留字保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成\n为关键字，同样不 能使用它们当变量名或方法名。 \n包括：boolean、byte、char、class、const、debugger、double、enum、export、\nextends、 fimal、float、goto、implements、import、int、interface、long、\nmative、package、 private、protected、public、short、static、super、\nsynchronized、throws、transient、 volatile 等。 \n注意：如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错 误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。\nJavaScript 运算符运算符（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的\n符号。 \nJavaScript中常用的运算符有： \n\n算数运算符\n递增和递减运算符\n比较运算符\n逻辑运算符\n赋值运算符\n\n算术运算符概念：算术运算使用的符号，用于执行两个变量或值的算术运算。\n\n\n\n运算符\n描述\n实例\n\n\n\n+\n加\n10  + 20 = 30\n\n\n-\n减\n10  - 20 = -10\n\n\n*\n乘\n10  * 20 = 200\n\n\n/\n除\n10  / 20 = 0.5\n\n\n%\n取余数（取模）\n返回除法的余数 9 % 2 = 1\n\n\n浮点数的精度问题浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。\nvar result = 0.1 + 0.2;    // 结果不是 0.3，而是：0.30000000000000004 console.log(0.07 * 100);   // 结果不是 7，  而是：7.000000000000001\n\n所以：不要直接判断两个浮点数是否相等 ! \n1.怎么判断 一个数能够被整除呢？\n它的余数是0 就说明这个数能被整除， 这就是 %  取余运算符的主要用途\n2.请问 1 + 2  *  3 结果是?\n结果是7 ，注意算术运算符优先级的，先乘除，后加减，有小括号先算小括号里面的 \n表达式和返回值表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合\n简单理解：是由数字、运算符、变量等组成的式子 \n表达式最终都会有一个结果，返回给我们，我们成为返回值\n递增和递减运算符如果需要反复给数字变量添加或减去1，可以使用递增（+ +）和递减（ - - ）运算符来完\n成。 \n在 JavaScript 中，递增（+ +）和递减（ - - ）既可以放在变量前面，也可以放在变量后\n面。放在变量前面时， 我们可以称为前置递增（递减）运算符，放在变量后面时，我们\n可以称为后置递增（递减）运算符。 \n注意：递增和递减运算符必须和变量配合使用\n递增运算符前置递增运算符++num 前置递增，就是自加1，类似于 num =  num + 1，但是 ++num 写起来更简单。\n使用口诀：先自加，后返回值\nvar  num = 10; alert(++num + 10);   // 21\n\n后置递增运算符num+ + 后置递增，就是自加1，类似于 num =  num + 1 ，但是 num+ + 写起来更简单。\n使用口诀：先返回原值，后自加\nvar  num = 10; alert(10 + num++);  // 20 \n\n小结 前置递增和后置递增运算符可以简化代码的编写，让变量的值 + 1  比以前写法更简\n\n单独使用时，运行结果相同\n与其他代码联用时，执行结果会不同\n后置：先原值运算，后自加（先人后己）\n前置：先自加，后运算（先已后人）\n开发时，大多使用后置递增/减，并且代码独占一行，例如：num+ +; 或者 num- -; \n\n比较运算符概念：比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算\n后，会返回一个布尔值 （true / false）作为比较运算的结果。\n\n\n\n运算符名称\n说明\n案例\n结果\n\n\n\n&lt;\n小于号\n1 &lt; 2\ntrue\n\n\n&gt;\n大于号\n1 &gt; 2\nfalse\n\n\n&gt;=\n大于等于号（大于或者等于）\n2 &gt;= 2\ntrue\n\n\n&lt;=\n小于等于号（小于或者等于）\n3 &lt;= 2\nfalse\n\n\n==\n判等号（会转型）\n37 == 37\ntrue\n\n\n!=\n不等号\n37 != 37\nfalse\n\n\n===     !==\n全等 要求值和数据类型都一致\n37 === ‘37’\nfalse\n\n\n== 会把字符串型的数据转换为数字型\n= 符号\n\n\n符号\n作用\n用法\n\n\n\n=\n赋值\n把右边给左边\n\n\n==\n判断\n判断两边值是否相等（注意此时有隐式转换）\n\n\n===\n全等\n判断两边的值和数据类型是否完全相同\n\n\n逻辑运算符概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断。\n\n\n\n逻辑运算符\n说明\n案例\n\n\n\n&amp;&amp;\n“逻辑与”，简称“与”    and\ntrue &amp;&amp; false\n\n\n||\n“逻辑或”，简称“或”    or\ntrue || false\n\n\n！\n“逻辑非”，简称“非”    not\n！true\n\n\n逻辑与 &amp;&amp;两边都是 true才返回 true，否则返回 false\n\n逻辑或 ||两边都为 false 才返回 false，否则都为true \n\n逻辑非 ！逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false \nvar isOk = !true; console.log(isOk);  // false\n\n短路运算（逻辑中断）短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续\n运算右边的表达式的值; \n1.逻辑与\n语法： 表达式1 &amp;&amp; 表达式2\n如果第一个表达式的值为真，则返回表达式2\n如果第一个表达式的值为假，则返回表达式1 \n\nconsole.log( 123 &amp;&amp; 456 );        // 456 console.log( 0 &amp;&amp; 456 );          // 0 console.log( 123 &amp;&amp; 456&amp;&amp; 789 );  // 789 \n\n2.逻辑或\n语法： 表达式1 || 表达式2\n如果第一个表达式的值为真，则返回表达式1\n如果第一个表达式的值为假，则返回表达式2 \n\nconsole.log( 123 || 456 );         //  123 console.log( 0 ||  456 );          //  456 console.log( 123 || 456 || 789 );  //  123\n\n练习题\nvar num = 0; console.log(123 || num++); console.log(num);      \t\t\t\t// 0\n\n赋值运算符概念：用来把数据赋值给变量的运算符。\n\n\n\n赋值运算符\n说明\n案例\n\n\n\n=\n直接赋值\nvar usrName = “我是值”;\n\n\n+=、-=\n加、减一个数后再赋值\nvar age = 10;  age += 5;  //15\n\n\n*=、/=、%=\n乘、除、取模后再赋值\nvar age = 2;  age *= 5;  //10\n\n\nvar age = 10; age += 5;  // 相当于 age = age + 5; age -= 5;  // 相当于 age = age - 5; age *= 10; // 相当于 age = age * 10; \n\n运算符优先级\n\n\n优先级\n运算符\n顺序\n\n\n\n1\n小括号\n()\n\n\n2\n一元运算符\n++  –  !\n\n\n3\n算数运算符\n先 * / % 后 + -\n\n\n4\n关系运算符\n&gt;  &gt;=  &lt;  &lt;=\n\n\n5\n相等运算符\n==  !=  ===  !==\n\n\n6\n逻辑运算符\n先 &amp;&amp;  后 ||\n\n\n7\n赋值运算符\n=\n\n\n8\n逗号运算符\n,\n\n\n\n一元运算符里面的逻辑非优先级很高\n逻辑与比逻辑或优先级高\n\n练习题\nconsole.log( 4 &gt;= 6 || &#x27;人&#x27; != &#x27;阿凡达&#x27; &amp;&amp; !(12 * 2 == 144) &amp;&amp; true)\t// truevar num = 10; console.log( 5 == num / 2 &amp;&amp; (2 + 2 * num).toString() === ‘22’)； \t// true\n\nvar a = 3 &gt; 5 &amp;&amp; 2 &lt; 7 &amp;&amp; 3 == 4;  console.log(a);   \t// false var b = 3 &lt;= 4 || 3 &gt; 1 || 3 != 2;  console.log(b);  \t// true var c = 2 === &quot;2&quot;;  console.log(c);   \t// false var d = !c || b &amp;&amp; a ; console.log(d);\t\t// true\n\nJavaScript 流程控制-分支流程控制简单理解： 流程控制就是来控制我们的代码按照什么结构顺序来执行\n流程控制主要有三种结构，分别是顺序结构、分支结构和循环结构，这三种结构代表三\n种代码执行的顺序。 \n\n顺序流程控制顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行， 程序中大多数的代码都是这样执行的。\n\n分支流程控制 if 语句分支结构由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码（执行代码多选一\n的过程），从而得到不同的结果\n\nJS 语言提供了两种分支结构语句\n\nif 语句\nswitch 语句\n\nif 语句// 条件成立执行代码，否则什么也不做 if (条件表达式) &#123;     \t// 条件成立执行的代码语句 &#125;\n\n语句可以理解为一个行为，循环语句和分支语句就是典型的语句。一个程序由很多个语\n句组成，一般情况下，会分 割成一个一个的语句。 \n\nif else 语句（双分支语句）// 条件成立  执行 if 里面代码，否则执行else 里面的代码 if (条件表达式) &#123;     \t// [如果] 条件成立执行的代码 &#125; else &#123;     \t// [否则] 执行的代码 &#125; \n\n\nif else if 语句（多分支语句）// 适合于检查多重条件。 if (条件表达式1) &#123;     \t语句1； &#125; else if (条件表达式2)  &#123;\t语句2； &#125; else if (条件表达式3)  &#123;    \t语句3；  .... &#125; else &#123;     \t// 上述条件都不成立执行此处代码 &#125; \n\n\n三元表达式三元表达式也能做一些简单的条件选择。 有三元运算符组成的式子称为三元表达式 \n表达式1 ? 表达式2 : 表达式3; \n\n\n如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值\n简单理解： 就类似于  if  else （双分支） 的简写\n\n分支流程控制 switch 语句switch 语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量\n设置一系列的特定值 的选项时，就可以使用 switch。\nswitch( 表达式 )&#123;      \tcase value1:         \t\t// 表达式 等于 value1 时要执行的代码         \t\tbreak;     case value2:         \t\t// 表达式 等于 value2 时要执行的代码         \t\tbreak;     default:         \t\t// 表达式 不等于任何一个 value 时要执行的代码 &#125;\n\n\nswitch ：开关 转换  ， case ：小例子   选项\n关键字 switch 后面括号内可以是表达式或值， 通常是一个变量\n关键字 case , 后跟一个选项的表达式或值，后面跟一个冒号\nswitch 表达式的值会与结构中的 case 的值做比较\n如果存在匹配全等(===) ，则与该 case 关联的代码块会被执行，并在遇到 break 时停止，整个 switch 语句代码 执行结束\n如果所有的 case 的值都和表达式的值不匹配，则执行 default 里的代码 \n\n注意： 执行case 里面的语句时，如果没有break，则继续执行下一个case里面的语句。\nswitch 语句和 if else if 语句的区别\n一般情况下，它们两个语句可以相互替换\nswitch…case 语句通常处理 case为比较确定值的情况， 而 if…else…语句更加灵活，常用于范围判断(大于、 等于某个范围) \nswitch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而if…else 语句有几种条件，就得判断多 少次\n当分支比较少时，if… else语句的执行效率比 switch语句高\n当分支比较多时，switch语句的执行效率比较高，而且结构更清晰\n\nJavaScript 流程控制-循环for 循环语法结构在程序中，一组被重复执行的语句被称之为循环体，能否继续重复执行，取决于循环的\n终止条件。由循环体及循环的终止条件组成的语句，被称之为循环语句\nfor 循环主要用于把某些代码循环若干次，通常跟计数有关系。其语法结构如下：\nfor(初始化变量; 条件表达式; 操作表达式 )&#123;    //循环体&#125;\n\n\n初始化变量：通常被用于初始化一个计数器，该表达式可以使用 var 关键字声明新的变量，这个变量帮我们来记录次数\n条件表达式：用于确定每一次循环是否能被执行。如果结果是 true 就继续循环，否则退出循环\n操作表达式：每次循环的最后都要执行的表达式。通常被用于更新或者递增计数器变量。当然，递减变量也是可以的\n\n执行过程：\n\n初始化变量，初始化操作在整个 for 循环只会执行一次。\n执行条件表达式，如果为true，则执行循环体语句，否则退出循环，循环结束。\n执行操作表达式，此时第一轮结束。\n第二轮开始，直接去执行条件表达式（不再初始化变量），如果为 true ，则去执行循环体语句，否则退出循环。\n继续执行操作表达式，第二轮结束。\n后续跟第二轮一致，直至条件表达式为假，结束整个 for 循环。\n\n断点调试：\n断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。\n断点调试可以帮我们观察程序的运行过程\n浏览器中按 F12–&gt; sources –&gt;找到需要调试的文件–&gt;在程序的某一行设置断点\nWatch: 监视，通过watch可以监视变量的值的变化，非常的常用。\nF11: 程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。\n代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决bug的能力。初学者\n不要觉得调试代码麻烦就不去调试，知识点花点功夫肯定学的会，但是代码调试这个东\n西，自己不去练，永远都学不会。\n今天学的代码调试非常的简单，只要求同学们记住代码调试的这几个按钮的作用即可\n，后面还会学到很多的代码调试技巧。\nfor 循环重复相同的代码for循环可以重复相同的代码 ，比如我们要输出10句“媳妇我错了”\n//  基本写法for(var i = 1; i &lt;= 10; i++)&#123;    console.log(&#x27;媳妇我错了~&#x27;);&#125;// 用户输入次数var num = prompt(&#x27;请输入次数:&#x27;)；for ( var i = 1 ; i &lt;= num; i++) &#123;    console.log(&#x27;媳妇我错了~&#x27;);&#125; \n\nfor 循环重复不相同的代码for 循环还可以重复不同的代码，这主要是因为使用了计数器 ，计数器在每次循环过程\n中都会有变化。\n例如，求输出一个人1到100岁：\n//  基本写法for (var i = 1; i &lt;= 100; i++) &#123;      console.log(&#x27;这个人今年&#x27; + i + &#x27;岁了&#x27;);&#125;\n\nfor 循环还可以重复不同的代码，这主要是因为使用了计数器 ，计数器在每次循环过程\n中都会有变化。\n例如，求输出一个人1到100岁：\n// for 里面是可以添加其他语句的 for (var i = 1; i &lt;= 100; i++) &#123; if (i == 1) &#123;    console.log(&#x27;这个人今年1岁了， 它出生了&#x27;); &#125; else if (i == 100) &#123;    console.log(&#x27;这个人今年100岁了，它死了&#x27;);  &#125; else &#123;       console.log(&#x27;这个人今年&#x27; + i + &#x27;岁了&#x27;);  &#125;&#125;\n\nfor 循环因为有了计数器的存在，我们还可以重复的执行某些操作，比如做一些算术运\n算。 \n双重 for 循环概述很多情况下，单层 for 循环并不能满足我们的需求，比如我们要打印一个 5 行 5 列的图\n形、打印一个倒直角三角形等，此时就可以通过循环嵌套来实现。\n\n循环嵌套是指在一个循环语句中再定义一个循环语句的语法结构，例如在for循环语\n句中，可以再嵌套一个for 循环，这样的 for 循环语句我们称之为双重for循环。\n语法for (外循环的初始; 外循环的条件; 外循环的操作表达式) &#123;    for (内循环的初始; 内循环的条件; 内循环的操作表达式) &#123;         需执行的代码;   &#125;&#125;\n\n\n内层循环可以看做外层循环的语句\n内层循环执行的顺序也要遵循 for 循环的执行顺序\n外层循环执行一次，内层循环要执行全部次数\n\nfor 循环小结\nfor 循环可以重复执行某些相同代码\nfor 循环可以重复执行些许不同的代码，因为我们有计数器\nfor 循环可以重复执行某些操作，比如算术运算符加法操作\n随着需求增加，双重for循环可以做更多、更好看的效果\n双重 for 循环，外层循环一次，内层 for 循环全部执行\nfor 循环是循环条件和数字直接相关的循环\n\nwhile 循环while 语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为\n真时结束循环。\nwhile语句的语法结构如下：\nwhile (条件表达式) &#123;    // 循环体代码 &#125;\n\n执行思路：\n\n先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循\n环，执行后面代码\n\n执行循环体代码\n\n循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继\n续执行循环体，直到循环条件为 false 时，整个循环过程才会结束\n\n\n注意：\n\n使用 while 循环时一定要注意，它必须要有退出条件，否则会成为死循环\n\nwhile 循环和 for 循环的不同之处在于 while 循环可以做较为复杂的条件判断，比如\n判断用户名和密码\n\n\ndo while 循环do… while 语句其实是 while 语句的一个变体。该循环会先执行一次代码块，然后对条\n件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环。\ndo… while 语句的语法结构如下：\ndo &#123;    // 循环体代码 - 条件表达式为 true 时重复执行循环体代码&#125; while(条件表达式);\n\n执行思路：\n\n先执行一次循环体代码\n\n再执行条件表达式，如果结果为 true，则继续执行循环体代码，如果为 false，则退\n出循环，继续执行后面代码\n\n\n注意：先再执行循环体，再判断，我们会发现 do…while 循环语句至少会执行一次循环体代码\n循环小结\nJS 中循环有 for 、while 、 do while\n\n三个循环很多情况下都可以相互替代使用\n\n如果是用来计次数，跟数字相关的，三者使用基本相同，但是我们更喜欢用 for\n\nwhile 和 do…while 可以做更复杂的判断条件，比 for 循环灵活一些 \n\nwhile 和 do…while 执行顺序不一样，while 先判断后执行，do…while 先执行一\n次，再判断执行\n\nwhile 和 do…while 执行次数不一样，do…while 至少会执行一次循环体， 而 while\n可能一次也不执行\n\n实际工作中，我们更常用for 循环语句，它写法更简洁直观， 所以这个要重点学习\n\n\ncontinue breakcontinue 关键字continue 关键字用于立即跳出本次循环，继续下一次循环（本次循环体中 continue 之\n后的代码就会少执行一次）。\n例如，吃5个包子，第3个有虫子，就扔掉第3个，继续吃第4个第5个包子，其代码实现\n如下：\nfor (var i = 1; i &lt;= 5; i++) &#123;     if (i == 3) &#123;         console.log(&#x27;这个包子有虫子，扔掉&#x27;);         continue; // 跳出本次循环，跳出的是第3次循环       &#125;      console.log(&#x27;我正在吃第&#x27; + i + &#x27;个包子呢&#x27;);&#125;\n\nbreak 关键字break 关键字用于立即跳出整个循环（循环结束）。\n例如，吃5个包子，吃到第3个发现里面有半个虫子，其余的不吃了，其代码实现如下：\nfor (var i = 1; i &lt;= 5; i++) &#123;   if (i == 3) &#123;       break; // 直接退出整个for 循环，跳到整个for下面的语句   &#125;   console.log(&#x27;我正在吃第&#x27; + i + &#x27;个包子呢&#x27;); &#125;\n\nJavaScript 命名规范以及语法格式标识符命名规范\n变量、函数的命名必须要有意义\n变量的名称一般用名词 \n函数的名称一般用动词 \n\n操作符规范// 操作符的左右两侧各保留一个空格for (var i = 1; i &lt;= 5; i++) &#123;   if (i == 3) &#123;       break; // 直接退出整个 for 循环，跳到整个for循环下面的语句   &#125;   console.log(&#x27;我正在吃第&#x27; + i + &#x27;个包子呢&#x27;);&#125;\n\n单行注释规范for (var i = 1; i &lt;= 5; i++) &#123;   if (i == 3) &#123;       break; // 单行注释前面注意有个空格   &#125;   console.log(&#x27;我正在吃第&#x27; + i + &#x27;个包子呢&#x27;);&#125;\n\nJavaScript 数组数组的概念问：之前学习的数据类型，只能存储一个值。如果我们想存储班级中所有学生的姓名，\n那么该如何存储呢？ \n答：可以使用数组(Array)。数组可以把一组相关的数据一起存放，并提供方便的访问(获\n取）方式。 \n问：什么是数组呢？ \n答：数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类\n型的元素。数组是一 种将一组数据存储在单个变量名下的优雅方式。\n// 普通变量一次只能存储一个值 var  num = 10;  // 数组一次可以存储多个值 var arr = [1,2,3,4,5]; \n\n创建数组数组的创建方式JS 中创建数组有两种方式：\n\n利用  new 创建数组\n利用数组字面量创建数组\n\n利用 new 创建数组var 数组名 = new Array() ； var arr = new Array();   // 创建一个新的空数组\n\n\n这种方式暂且了解，等学完对象再看\n注意 Array () ，A 要大写\n\n利用数组字面量创建数组//1. 使用数组字面量方式创建空的数组 var  数组名 = []； //2. 使用数组字面量方式创建带初始值的数组 var  数组名 = [&#x27;小白&#x27;,&#x27;小黑&#x27;,&#x27;大黄&#x27;,&#x27;瑞奇&#x27;];\n\n\n数组的字面量是方括号 [ ] \n声明数组并赋值称为数组的初始化\n这种字面量方式也是我们以后最多使用的方式 \n\n数组元素的类型数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。\nvar arrStus = [&#x27;小白&#x27;,12,true,28.9];\n\n获取数组中的元素数组的索引索引 (下标) ：用来访问数组元素的序号（数组下标从 0 开始）。\n​    var  arr = [‘小白’,’小黑’,’大黄’,’瑞奇’]; \n​    索引号：       0         1        2         3 \n数组可以通过索引来访问、设置、修改对应的数组元素，我们可以通过“数组名[索引]”的\n形式来获取数组中的 元素。 \n这里的访问就是获取得到的意思\n// 定义数组 var arrStus = [1,2,3]; // 获取数组中的第2个元素 alert(arrStus[1]);    \n\n遍历数组问：数组中的每一项我们怎么取出来？\n答：可以通过“数组名[索引号]”的方式一项项的取出来。\nvar arr = [&#x27;red&#x27;,&#x27;green&#x27;, &#x27;blue&#x27;]; console.log(arr[0]) // red console.log(arr[1]) // green console.log(arr[2]) // blue\n\n问：怎么把数组里面的元素全部取出来？ \n规律：\n从代码中我们可以发现，从数组中取出每一个元素时，代码是重复的，有所不一样的是\n索引值在递增 \n答案就是：循环\n遍历: 就是把数组中的每个元素从头到尾都访问一次（类似我们每天早上学生的点名）。 \n我们可以通过 for 循环索引遍历数组中的每一项 \nvar arr = [&#x27;red&#x27;,&#x27;green&#x27;, &#x27;blue&#x27;]; for(var i = 0; i &lt; arr.length; i++)&#123;     console.log(arrStus[i]); &#125;\n\n数组的长度使用“数组名.length”可以访问数组元素的数量（数组长度）。 \nvar arrStus = [1,2,3]; alert(arrStus.length);  // 3 \n\n注意：\n\n此处数组的长度是数组元素的个数 ，不要和数组的索引号混淆\n当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化\n\n数组中新增元素通过修改 length 长度新增数组元素\n可以通过修改 length 长度来实现数组扩容的目的 \nlength 属性是可读写的\n\nvar arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;]; arr.length = 7; console.log(arr); console.log(arr[4]); console.log(arr[5]); console.log(arr[6]);\n\n其中索引号是 4，5，6 的空间没有给值，就是声明变量未给值，默认值就是 \nundefined。\n\n通过修改数组索引新增数组元素\n可以通过修改数组索引的方式追加数组元素\n不能直接给数组名赋值，否则会覆盖掉以前的数据\n\nvar arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;]; arr[4] = &#x27;hotpink&#x27;; console.log(arr);\n\n这种方式也是我们最常用的一种方式。\n不要直接给数组名赋值，否则里面的数组元素就会都没有。\n案例1.数组新增元素 新建一个数组，里面存放10个整数（ 1~10）， 要求使用循环追加的方式输出：\n [1,2,3,4,5,6,7,8,9,10] \n案例分析：\n\n使用循环来追加数组。\n\n声明一个空数组 arr。\n\n循环中的计数器 i  可以作为数组元素存入。\n\n由于数组的索引号是从0开始的， 因此计数器从 0 开始更合适，存入的数组元素要\n+1。\n\n\nvar arr = []; for (var i = 0; i &lt; 10; i++) &#123;     arr[i] = i + 1; &#125; console.log(arr)；\n\n2.筛选数组要求：将数组 [2, 0, 6, 1, 77, 0, 52, 0, 25, 7] 中大于等于 10 的元素选出来，放入新数\n组。\n案例分析：\n\n声明一个新的数组用于存放新数据。\n遍历原来的数组，找出大于等于 10 的元素。\n依次追加给新数组 newArr。\n\nvar arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7]; var newArr = []; // 定义一个变量 用来计算 新数组的索引号 var j = 0; for (var i = 0; i &lt; arr.length; i++) &#123;     if (arr[i] &gt;= 10) &#123;             \t// 给新数组            \t\tnewArr[j] = arr[i];             \t// 索引号 不断自加             \tj++;     &#125; &#125; console.log(newArr);\n\nvar arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7]; var newArr = []; for (var i = 0; i &lt; arr.length; i++) &#123;     if (arr[i] &gt;= 10) &#123;             \t// 给新数组             \tnewArr[newArr.length] = arr[i];     &#125; &#125; console.log(newArr);\n\n数组案例1.删除指定数组元素要求：将数组[2, 0, 6, 1, 77, 0, 52, 0, 25, 7]中的 0 去掉后，形成一个不包含 0 的新数\n组。 \n案例分析：\n\n需要一个新数组用于存放筛选之后的数据。\n\n遍历原来的数组，把不是 0 的数据添加到新数组里面( 此时要注意采用数组名+索引\n的格式接收数据)。\n\n新数组里面的个数，用 length 不断累加。 \n\n\nvar arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7]; var newArr = [];   // 空数组的默认的长度为 0  // 定义一个变量 i 用来计算新数组的索引号 for (var i = 0; i &lt; arr.length; i++) &#123;          // 找出大于 10 的数          if (arr[i] != 0) &#123;                   // 给新数组                   // 每次存入一个值，newArr长度都会 +1           \t\t \t\t           newArr[newArr.length] = arr[i];     &#125; &#125; console.log(newArr);\n\n2.翻转数组要求: 将数组 [‘red’, ‘green’, ‘blue’, ‘pink’, ‘purple’] 的内容反过来存放。 输出： \n[‘purple’, ‘pink’, ‘blue’, ‘green’, ‘red’] \n案例分析：\n\nvar arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;, &#x27;purple&#x27;]; var newArr = []; for (var i = 0; i &lt; arr.length; i++) &#123;          // newArr 是接收方，arr 是输送方          newArr[i] = arr[arr.length - i - 1]; &#125; console.log(newArr);\n\n3.数组排序（冒泡排序）冒泡排序：是一种算法，把一系列的数据按照一定的顺序进行排列显示(从小到大或从大\n到小）。 例如，我们可以将数组 [5, 4, 3, 2, 1]中的元素按照从小到大的顺序排序，输\n出： 1，2，3，4，5\n案例分析：\n\nvar arr = [5, 4, 3, 2, 1];      for (var i = 0; i &lt; arr.length - 1; i++) &#123;          for (var j = 0; j &lt; arr.length - i - 1; j++) &#123;             if (arr[j] &gt; arr[j + 1]) &#123;                  var temp = arr[j];                  arr[j] = arr[j + 1];                  arr[j + 1] = temp;               &#125;           &#125;       &#125; console.log(arr); \n\nJavaScript 函数函数的概念在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量\n重复使用。 \n虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以\n使用 JS 中的函数。 \n函数：就是封装了一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的\n重复使用。\n函数的使用函数在使用时分为两步：声明函数和调用函数。\n声明函数// 声明函数 function 函数名() &#123;     \t//函数体代码 &#125; \n\n\nfunction 是声明函数的关键字,必须小写\n由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum\n\n调用函数// 调用函数 函数名();  // 通过调用函数名来执行函数体代码\n\n\n调用的时候千万不要忘记添加小括号\n口诀：函数不调用，自己不执行\n\n注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。 \n函数的封装\n函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单\n的函数接口\n\n简单理解：封装类似于将电脑配件整合组装到机箱中 ( 类似快递打包）\n\n\n\n案例：利用函数计算 1-100 之间的累加和\n/*     计算1-100之间值的函数 */ // 声明函数 function getSum()&#123;\tvar sumNum = 0;// 准备一个变量，保存数字和\tfor (var i = 1; i &lt;= 100; i++) &#123;        sumNum += i;// 把每个数值 都累加 到变量中  &#125;   alert(sumNum);&#125; // 调用函数 getSum();\n\n函数的参数形参和实参在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，\n而在调用该函数时， 同样也需要传递相应的参数，这些参数被称为实参。\n\n\n\n参数\n说明\n\n\n\n形参\n形式上的参数。函数定义的时候传递的参数，当前并不知道是什么\n\n\n实参\n实际上的参数。函数调用的时候传递的参数，实参是传递给形参的\n\n\n参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值\n进去。\n// 带参数的函数声明 function 函数名(形参1, 形参2 , 形参3...) &#123; // 可以定义任意多的参数，用逗号分隔   // 函数体 &#125; // 带参数的函数调用 函数名(实参1, 实参2, 实参3...); \n\n函数参数的传递过程// 声明函数 function getSum(num1, num2) &#123;     console.log(num1 + num2); &#125; // 调用函数 getSum(1, 3); // 4 getSum(6, 5); // 11\n\n\n调用的时候实参值是传递给形参的 \n形参简单理解为：不用声明的变量 \n实参和形参的多个参数之间用逗号（,）分隔 \n\n函数形参和实参个数不匹配问题\n\n\n参数个数\n说明\n\n\n\n实参个数等于形参个数\n输出正确结果\n\n\n实参个数多于形参个数\n只取到形参的个数\n\n\n实参个数小于形参个数\n多的形参定义为 undefined，结果为NaN\n\n\nfunction sum(num1, num2) &#123;     console.log(num1 + num2); &#125; sum(100, 200);    \t\t\t// 形参和实参个数相等，输出正确结果 sum(100, 400, 500, 700);   \t// 实参个数多于形参，只取到形参的个数 sum(200);         // 实参个数少于形参，多的形参定义为undefined，结果为NaN\n\n注意：在JavaScript中，形参的默认值是undefined。\n小结\n函数可以带参数也可以不带参数\n声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined \n调用函数的时候，函数名括号里面的是实参 \n多个参数中间用逗号分隔\n形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配\n\n函数的返回值return 语句有的时候，我们会希望函数将值返回给调用者，此时通过使用 return 语句就可以实现。\nreturn 语句的语法格式如下： \n// 声明函数 function 函数名（）&#123;     \t...     \treturn  需要返回的值； &#125; // 调用函数 函数名();    // 此时调用函数就可以得到函数体内 return 后面的值\n\n\n在使用 return 语句时，函数会停止执行，并返回指定的值\n如果函数没有 return ，返回的值是 undefined \n\n// 声明函数 function sum（）&#123;\t...     \treturn  666； &#125; // 调用函数 sum();  \t// sum() = 666   此时 sum 的值就等于666，因为 return 语句会把自身后面的值返回给调用者// console.log(sum());\n\n案例1.利用函数求任意两个数的最大值function getMax(num1, num2) &#123;     return num1 &gt; num2 ? num1 : num2; &#125; console.log(getMax(1, 2)); console.log(getMax(11, 2)); \n\n2.利用函数求任意一个数组中的最大值//定义一个获取数组中最大数的函数 function getMaxFromArr(numArray)&#123;     var maxNum = 0;     for(var i =0;i &lt; numArray.length;i++)&#123;         if(numArray[i] &gt; maxNum)&#123;             maxNum = numArray[i];         &#125;     &#125;     return maxNum; &#125; var arrNum = [5,2,99,101,67,77]; var maxN = getMaxFromArr(arrNum); // 这个实参是个数组 alert(&#x27;最大值为：&#x27;+ maxN); \n\nreturn 终止函数return 语句之后的代码不被执行。\nfunction add(num1，num2)&#123;     \t//函数体     \treturn num1 + num2; // 注意：return 后的代码不执行     \talert(&#x27;我不会被执行，因为前面有 return&#x27;); &#125; var resNum = add(21,6); // 调用函数，传入两个实参，并通过 resNum 接收函数返回值 alert(resNum);          // 27\n\nreturn 的返回值return 只能返回一个值。如果用逗号隔开多个值，以最后一个为准。 \nfunction add(num1，num2)&#123;     \t//函数体     \treturn num1，num2; &#125; var resNum = add(21,6); // 调用函数，传入两个实参，并通过 resNum 接收函数返回值 alert(resNum);          // 6 \n\n案例创建一个函数，实现两个数自检的加减乘除运算，并将结果返回\nvar a = parseFloat(prompt(&#x27;请输入第一个数&#x27;)); var b = parseFloat(prompt(&#x27;请输入第二个数&#x27;)); function count(a, b) &#123;     var arr = [a + b, a - b, a * b, a / b];     return arr; &#125; var result = count(a, b); console.log(result); \n\n函数没有 return 返回 undefined函数都是有返回值的\n\n如果有return 则返回 return 后面的值 \n如果没有return 则返回 undefined\n\nbreak，continue，return 的区别\nbreak ：结束当前的循环体（如 for、while）\ncontinue ：跳出本次循环，继续执行下次循环（如 for、while）\nreturn ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码\n\n通过榨汁机看透函数\narguments 的使用当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，\narguments 实际上 它是当前函数的一个内置对象。所有函数都内置了一个 arguments \n对象，arguments 对象中存储了传递的 所有实参。\narguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：\n\n具有 length 属性\n按索引方式储存数据\n不具有数组的 push , pop 等方法\n\n案例利用函数求任意个数的最大值\nfunction maxValue() &#123;       var max = arguments[0];       for (var i = 0; i &lt; arguments.length; i++) &#123;          if (max &lt; arguments[i]) &#123;                     max = arguments[i];          &#125;       &#125;       return max; &#125;  console.log(maxValue(2, 4, 5, 9));  console.log(maxValue(12, 4, 9)); \n\n函数案例案例1：利用函数封装方式，翻转任意一个数组function reverse(arr) &#123; var newArr = []; for (var i = arr.length - 1; i &gt;= 0; i--) &#123; newArr[newArr.length] = arr[i]; &#125; return newArr; &#125; var arr1 = reverse([1, 3, 4, 6, 9]); console.log(arr1); \n\n案例2：利用函数封装方式，对数组排序 – 冒泡排序function sort(arr) &#123; for (var i = 0; i &lt; arr.length - 1; i++) &#123; for (var j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; return arr; &#125; \n\n案例3：判断闰年要求：输入一个年份，判断是否是闰年（闰年：能被4整除并且不能被100整数，或者能\n被400整除） \nfunction isRun(year) &#123;      var flag = false;      if (year % 4 === 0 &amp;&amp; year % 100 !== 0 || year % 400 === 0) &#123;         flag = true;      &#125;     return flag; &#125; console.log(isRun(2010)); console.log(isRun(2012)); \n\n函数可以调用另外一个函数因为每个函数都是独立的代码块，用于完成特殊任务，因此经常会用到函数相互调用的\n情况。\nfunction fn1() &#123;   console.log(111);   fn2();   console.log(&#x27;fn1&#x27;); &#125; function fn2() &#123;   console.log(222);   console.log(&#x27;fn2&#x27;); &#125; fn1();\n\n案例4：用户输入年份，输出当前年份 2 月份的天数\n函数的两种声明方式自定义函数方式（命名函数）利用函数关键字 function 自定义函数方式。 \n// 声明定义方式 function fn() &#123;...&#125; // 调用   fn(); \n\n\n因为有名字，所以也被称为命名函数\n调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面 \n\n函数表达式方式（匿名函数）用函数表达式方式的写法如下：\n// 这是函数表达式写法，匿名函数后面跟分号结束 var fn = function()&#123;...&#125;； // 调用的方式，函数调用必须写到函数体下面 fn();\n\n\n因为函数没有名字，所以也被称为匿名函数\n这个fn 里面存储的是一个函数\n函数表达式方式原理跟声明变量方式是一致的\n函数调用的代码必须写到函数体后面\n\nJavaScript 作用域作用域作用域概述通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可\n用性的代码范围就是这 个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强\n了程序的可靠性，减少了名字冲突。\nJavaScript（es6前）中的作用域有两种：\n\n全局作用域\n局部作用域（函数作用域）\n\n全局作用域作用于所有代码执行的环境(整个script 标签内部)或者一个独立的js 文件。\n局部作用域（函数作用域）作用于函数内的代码环境，就是局部作用域。因为跟函数有关系，所以也称为函数作用\n域。\nJS 没有块级作用域\n块作用域由 { } 包括。\n\n在其他编程语言中（如java、c#等），在if 语句、循环语句中创建的变量，仅仅只能\n在本if 语句、本循 环语句中使用，如下面的Java代码：\n\n\nif(true)&#123;\tint num = 123;\tsystem.out.print(num);  // 123&#125;system.out.print(num); // 报错\n\nJs中没有块级作用域（在ES6之前）。\nif(true)&#123;\tvar num = 123;\tconsole.log(123); //123&#125;console.log(123);  //123\n\n变量的作用域变量作用域的分类在JavaScript中，根据作用域的不同，变量可以分为两种：\n\n全局变量\n局部变量\n\n全局变量在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。\n\n全局变量在代码的任何位置都可以使用\n在全局作用域下 var 声明的变量是全局变量\n特殊情况下，在函数内不使用var 声明的变量也是全局变量（不建议使用）\n\n局部变量在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量）\n\n局部变量只能在该函数内部使用\n在函数内部 var 声明的变量是局部变量\n函数的形参实际上就是局部变量\n\n全局变量和局部变量的区别\n全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比\n较占内存\n\n局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码\n块运行结束后，就会被 销毁，因此更节省内存空间\n\n\n作用域链\n只要是代码，就至少有一个作用域\n\n写在函数内部的局部作用域\n\n如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域\n\n根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被\n内部函数访问，就称 作作用域链\n\n\nfunction f1() &#123;\tvar num = 123;\tfunction f2() &#123;\t\tconsole.log( num );\t\t\t// 123\t&#125;\tf2();&#125;var num = 456;f1();\t\t\t\t\t\n\n\n作用域链：采取就近原则的方式来查找变量最终的值。\nvar a = 1;function fn1() &#123;\tvar a = 2;\tvar b = &#x27;22&#x27;;\tfn2();\tfunction fn2() &#123;\t\tvar a = 3;\t\tfn3();\t\tfunction fn3() &#123;\t\t\tvar a = 4; \t\t\tconsole.log(a); //a的值 ? \t\t4\t\t\tconsole.log(b); //b的值 ?\t\t\t22\t\t&#125;\t&#125;&#125;fn1();\n\nJavaScript 预解析预解析console.log(num);  // 结果是多少？\t报错\n\nconsole.log(num);  // 结果是多少？ \tundefinedvar num = 10;   ？-----------相当于：var num;console.log(num);num = 10;\n\nfn();function fn() &#123;\tconsole.log(&#x27;打印&#x27;);\t\t\t打印&#125;\n\nfn();var  fn = function() &#123;\tconsole.log(&#x27;想不到吧&#x27;);\t\t报错&#125;-----------相当于：var fn;fn();fn = function()&#123;\tconsole.log(&#x27;想不到吧&#x27;);&#125; \n\nJavaScript 代码是由浏览器中的JavaScript 解析器来执行的。JavaScript解析器在运行\nJavaScript代码的 时候分为两步：预解析和代码执行。\n\n预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function \n声明的变量在内存中 进行提前声明或者定义\n\n代码执行： 从上到下执行JS语句。\n\n\n预解析只会发生在通过 var 定义的变量和 function 上。学习预解析能够让我们知道为什\n么在变量声明之前 访问变量的值是 undefined，为什么在函数声明之前就可以调用函\n数。\n变量预解析和函数预解析变量预解析（变量提升）预解析也叫做变量、函数提升。\n量提升： 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。\nconsole.log(num);  // 结果是多少？ var num = 10;   // ？\n\n函数预解析（函数提升）函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。\nfn();function fn() &#123;\tconsole.log(&#x27;打印&#x27;);&#125;\n\n解决函数表达式声明调用问题函数表达式，调用必须写在函数表达式的下面。\nfn();var  fn = function() &#123;\tconsole.log(&#x27;想不到吧&#x27;);&#125;------先声明，后调用\n\n预解析案例// 案例1 var num = 10;fun();function fun() &#123;\tconsole.log(num);\t\t// undefined\tvar num = 20;&#125;-----------var num;function fun() &#123;\tvar num;\t\tconsole.log(num);\t\t\tnum= 20;&#125;num = 10;fun();\n\n// 案例2 var num = 10;function fn()&#123;\tconsole.log(num);\t// undefined\tvar num = 20;\tconsole.log(num);\t// 20&#125; fn();---------var num;function fn()&#123;\tvar num;\tconsole.log(num);\tnum = 20;\tconsole.log(num);&#125; num = 10;fn();\n\n// 案例3 var a = 18;f1();function f1() &#123;\tvar b = 9;\tconsole.log(a);\tconsole.log(b);\tvar a = &#x27;123&#x27;;&#125;---------var a;function f1() &#123;\tvar b;\tvar a; \tb = 9;\tconsole.log(a);\t\t// undefined\tconsole.log(b);\t\t// 9\ta = &#x27;123&#x27;;&#125;a = 18;f1();\n\n// 案例4 f1();console.log(c);console.log(b);console.log(a);function f1() &#123;\tvar a = b = c = 9;\t// 相当于 var a = 9; b = 9; c = 9; b 和 c 直接赋值，没有var声明，相当于全局变量\t// 集体声明 var a = 9, b = 9, c = 9;\tconsole.log(a);\tconsole.log(b);\tconsole.log(c);&#125;-----------b = 9;c = 9;function f1() &#123;\tvar a = 9;\tconsole.log(a);\t\t// 9\tconsole.log(b);\t\t// 9\tconsole.log(c);\t\t// 9&#125;f1();console.log(c);\t\t\t// 9console.log(b);\t\t\t// 9console.log(a);\t\t\t// 报错\n\nJavaScript 对象对象什么是对象现实生活中：万物皆对象，对象是一个具体的事物，看得见摸得着的实物。例如，一本\n书、一辆汽车、一个人 可以是“对象”，一个数据库、一张网页、一个与远程服务器的连\n接也可以是“对象”。\n在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例\n如字符串、数值、数组、 函数等。\n\n属性：事物的特征，在对象中用属性来表示（常用名词）\n方法：事物的行为，在对象中用方法来表示（常用动词）\n\n为什么需要对象保存一个值时，可以使用变量，保存多个值（一组值）时，可以使用数组。如果要保存\n一个人的完整信息呢？\n例如，将“张三疯”的个人的信息保存在数组中的方式为：\nvar arr = [‘张三疯’, ‘男&#x27;, 128,154];\n\nJS 中的对象表达结构更清晰，更强大。张三疯的个人信息在对象中的表达结构如下：\n\n创建对象的三种方式在 JavaScript中，现阶段我们可以采用三种方式创建对象（object）：\n\n利用字面量创建对象\n利用 new Object 创建对象\n利用构造函数创建对象\n\n利用字面量创建对象对象字面量：就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法。\n{ } 里面采取键值对的形式表示\n\n键：相当于属性名\n\n值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函\n数类型等）\n\n\nvar star = &#123;\tname : &#x27;pink&#x27;,\tage : 18, \tsex : &#x27;男&#x27;, \tsayHi : function()&#123; \t\talert(&#x27;大家好啊~&#x27;); \t&#125;&#125;;\n\n对象的调用\n对象里面的属性调用 : 对象.属性名 ，这个小点 . 就理解为“ 的 ”\n\n对象里面属性的另一种调用方式: 对象[‘属性名’]，注意方括号里面的属性必须加引\n号，我们后面会用\n\n对象里面的方法调用：对象.方法名() ，注意这个方法名字后面一定加括号\n\n\nconsole.log(star.name)  // 调用名字属性 console.log(star[&#x27;name&#x27;])  // 调用名字属性 star.sayHi();  // 调用 sayHi 方法,注意，一定不要忘记带后面的括号\n\n变量、属性、函数、方法总结\n变量：单独声明赋值，单独存在\n\n属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征\n\n函数：单独存在的，通过“函数名()”的方式就可以调用\n\n方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可\n以调用，方法用来描述该对象 的行为和功能。\n\n\n利用 new Object 创建对象跟我们前面学的 new Array()  原理一致\nvar andy = new Obect();andy.name = &#x27;pink&#x27;;andy.age = 18;andy.sex = &#x27;男&#x27;;andy.sayHi = function()&#123; \talert(&#x27;大家好啊~&#x27;); &#125;\n\n\nObject() ：第一个字母大写\nnew Object() ：需要 new 关键字\n使用的格式：对象.属性 =  值;\n\n利用构造函数创建对象构造函数 ：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它\n总与new 运算符一起 使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封\n装到这个函数里面。\n在 js 中，使用构造函数要时要注意以下两点：\n\n构造函数用于创建某一类对象，其首字母要大写\n构造函数要和new 一起使用才有意义\n\n构造函数语法格式：\nfunction 构造函数名() &#123;\tthis.属性 = 值;\tthis.方法 = function() &#123;&#125;&#125;new 构造函数名();\n\nfunction Person(name, age, sex) &#123;\tthis.name = name;\tthis.age = age;\tthis.sex = sex;\tthis.sayHi = function() &#123; \talert(&#x27;我的名字叫：&#x27; + this.name + &#x27;，年龄：&#x27; + this.age + &#x27;，性别：&#x27; + this.sex); \t&#125;&#125; var bigbai = new Person(&#x27;大白&#x27;, 100, &#x27;男&#x27;); var smallbai = new Person(&#x27;小白&#x27;, 21, &#x27;男&#x27;); console.log(bigbai.name);console.log(smallbai.name);\n\n注意：\n\n构造函数约定首字母大写。\n函数内的属性和方法前面需要添加this ，表示当前对象的属性和方法。\n构造函数中不需要return 返回结果。\n当我们创建对象的时候，必须用new 来调用构造函数。\n\n构造函数和对象\n构造函数，如Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类\n（class）\n\n创建对象，如new Stars()，特指某一个，通过new 关键字创建对象的过程我们也称\n为对象实例化\n\n\n\nnew 关键字\n遍历对象属性for…in 语句用于对数组或者对象的属性进行循环操作。\n其语法如下：\nfor (变量 in 对象名字) &#123; \t// 在此执行代码 &#125;\n\n语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为k 或者 \nkey。\nfor (var k in obj) &#123; \tconsole.log(k); \t\t// 这里的 k 是属性名 \tconsole.log(obj[k]); \t// 这里的 obj[k] 是属性值 &#125;\n\n小结\n对象可以让代码结构更清晰\n\n对象复杂数据类型object。\n\n本质：对象就是一组无序的相关属性和方法的集合。\n\n构造函数泛指某一大类，比如苹果，不管是红色苹果还是绿色苹果，都统称为苹\n果。\n\n对象实例特指一个事物，比如这个苹果、正在给你们讲课的pink老师等。\n\nfor…in 语句用于对对象的属性进行循环操作。\n\n\nJavaScript 内置对象内置对象\nJavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象\n\n前面两种对象是JS 基础 内容，属于 ECMAScript；  第三个浏览器对象属于我们JS 独\n有的， 我们JS API 讲解\n\n内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常\n用的或是最基本而必要的功能（属性和方法）\n\n内置对象最大的优点就是帮助我们快速开发\n\nJavaScript 提供了多个内置对象：Math、 Date 、Array、String等\n\n\n查文档MDN学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学\n习，可以通过MDN/W3C 来查询。 \nMozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 \nHTML、CSS 和万维网及 HTML5 应用的 API。\nMDN:   https://developer.mozilla.org/zh-CN/ \n如何学习对象中的方法\n查阅该方法的功能 \n查看里面参数的意义和类型 \n查看返回值的意义和类型 \n通过 demo 进行测试 \n\nMath 对象Math 概述Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求\n绝对值，取整、最大值 等）可以使用 Math 中的成员。\nMath.PI   // 圆周率 Math.floor()   // 向下取整 Math.ceil()            // 向上取整 Math.round()           // 四舍五入版 就近取整   注意 -3.5   结果是  -3  Math.abs()   // 绝对值 Math.max()/Math.min()  // 求最大和最小值\n\n注意：上面的方法必须带括号\n案例：封装自己的数学对象\n利用对象封装自己的数学对象 里面有 PI 最大值和最小值 \nvar myMath = &#123;\tPI: 3.1415926,    max: function () &#123;    \tvar max = arguments[0];    \tfor (var i = 1; i &lt;= arguments.length; i++) &#123;\t\t\tif (arguments[i] &gt; max) &#123;              max = arguments[i];            &#125;          &#125;          return max;        &#125;,     min: function () &#123;          var min = arguments[0];          for (var i = 1; i &lt;= arguments.length; i++) &#123;            if (arguments[i] &lt; min) &#123;              min = arguments[i];            &#125;          &#125;          return min;        &#125;,      &#125;;console.log(myMath.PI);console.log(myMath.max(1, 222, 3232));console.log(myMath.min(-10, 3, 34, -222));\n\n随机数方法 random()random() 方法可以随机返回一个小数，其取值范围是 [0，1)，左闭右开 0 &lt;= x &lt; 1\n得到一个两数之间的随机整数，包括两个数在内\nfunction getRandom(min, max) &#123;   return Math.floor(Math.random() * (max - min + 1)) + min;  &#125;\n\n日期对象Date 概述\nDate 对象和 Math 对象不一样，他是一个构造函数，所以我们需要实例化后才能使\n用\n\nDate 实例用来处理日期和时间\n\n\nDate() 方法的使用1.获取当前时间必须实例化\nvar now = new Date(); console.log(now); \n\n2.Date() 构造函数的参数\n如果括号里面有时间，就返回参数里面的时间。例如日期格式字符串为‘2019-5-1’，可以\n写成new Date(‘2019-5-1’)  或者 new Date(‘2019/5/1’) \n\n如果Date()不写参数，就返回当前时间\n如果Date()里面写参数，就返回括号里面输入的时间 \n\n日期格式化我们想要 2019-8-8  8:8:8 格式的日期，要怎么办？\n需要获取日期指定的部分，所以我们要手动的得到这种格式。 \n\n\n\n方法名\n说明\n代码\n\n\n\ngetFullYear()\n获取当年\ndObj.getFullYear()\n\n\ngetMonth()\n获取当月（0-11）\ndObj.getMonth()\n\n\ngetDate()\n获取当天日期\ndObj.getDate()\n\n\ngetDay()\n获取星期几（周日0到周六6）\ndObj.getDay()\n\n\ngetHours()\n获取当前小时\ndObj.getHours()\n\n\ngetMinutes()\n获取当前分钟\ndObj.getMinutes()\n\n\ngetSeconds()\n获取当前秒钟\ndObj.getSeconds()\n\n\n案例：输出当前日期请写出这个格式的日期：2019年8月8日 星期四 \nvar date = new Date();var year = date.getFullYear();var month = date.getMonth() + 1;var dates = date.getDate();var arr = [&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,];var day = date.getDay();console.log(&quot;今天是：&quot; + year + &quot;年&quot; + month + &quot;月&quot; + dates + &quot;日 &quot; + arr[day]);\n\n案例：输出当前时间写一个函数，格式化日期对象，成为 HH:mm:ss 的形式   比如  00:10:45\nfunction getTimer() &#123;    var date = new Date();    var h = date.getHours();    h = h &lt; 10 ? &quot;0&quot; + h : h;    var m = date.getMinutes();    m = m &lt; 10 ? &quot;0&quot; + m : m;    var s = date.getSeconds();    s = s &lt; 10 ? &quot;0&quot; + s : s;    return h + &quot;:&quot; + m + &quot;:&quot; + s;   &#125;console.log(getTimer());\n\n获取日期的总的毫秒形式Date 对象是基于1970年1月1日（世界标准时间）起的毫秒数（时间戳）\n我们经常利用总的毫秒数来计算时间，因为它更精确 \n// 实例化Date对象 var now = new Date(); // 1. 用于获取对象的原始值 console.log(date.valueOf())  // 得到的就是现在的时间距离1970.1.1 总的毫秒数console.log(date.getTime())  // 2. 简单写可以这么做 var now = + new Date();    \t // 返回的就是总的毫秒数// 3. HTML5中提供的方法，有兼容性问题 var now = Date.now(); \n\n案例：倒计时效果核心算法：输入的时间减去现在的时间就是剩余的时间，即倒计时 ，但是不能拿着时分\n秒相减，比如 05 分减去25分，结果会是负数的。\n用时间戳来做。用户输入时间总的毫秒数减去现在时间的总的毫秒数，得到的就是剩余\n时间的毫秒数。 \n把剩余时间总的毫秒数转换为天、时、分、秒（时间戳转换为时分秒）转换公式如下：\n\nd = parseInt(总秒数/ 60/60 /24);    //  计算天数\nh = parseInt(总秒数/ 60/60 %24)   //   计算小时\nm = parseInt(总秒数 /60 %60 );     //   计算分数\ns = parseInt(总秒数%60);               //   计算当前秒数\n\nfunction countDown(time) &#123;  var nowTime = +new Date(); // 当前时间总的毫秒数  var inputTime = +new Date(time); // 用户输入时间总的毫秒数  var times = (inputTime - nowTime) / 1000; // 剩余时间总的秒数  var d = parseInt(times / 60 / 60 / 24); //天  d = d &lt; 10 ? &quot;0&quot; + d : d;  var h = parseInt((times / 60 / 60) % 24); //时  h = h &lt; 10 ? &quot;0&quot; + h : h;  var m = parseInt((times / 60) % 60); //分  m = m &lt; 10 ? &quot;0&quot; + m : m;  var s = parseInt(times % 60); //秒  s = s &lt; 10 ? &quot;0&quot; + s : s;  return d + &quot;天&quot; + h + &quot;时&quot; + m + &quot;分&quot; + s + &quot;秒&quot;;&#125;console.log(countDown(&quot;2020-9-10 15:00:00&quot;));\n\n数组对象数组对象的创建创建数组对象的两种方式\n\n字面量方式\nnew Array()\n\n\n检测是否为数组\ninstanceof 运算符，可以判断一个对象是否属于某种类型  \nArray.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法\n\nvar arr = [1, 23]; var obj = &#123;&#125;; console.log(arr instanceof Array); // true console.log(obj instanceof Array); // false console.log(Array.isArray(arr));   // true console.log(Array.isArray(obj));   // false \n\n添加删除数组元素的方法\n\n\n方法名\n说明\n返回值\n\n\n\npush(参数1，参数2…)\n末尾添加一个或多个元素，注意修改原数组\n并返回新的长度\n\n\npop()\n删除数组最后一个元素，把数组长度减 1 无参数、修改原数组\n返回它删除的元素的值\n\n\nunshift(参数1，参数2…)\n向数组的开头添加一个或更多元素，注意修改原数组\n并返回新的长度\n\n\nshift()\n删除数组的第一个元素，数组长度减 1 无参数、修改原数组\n并返回第一个元素的值\n\n\n案例：筛选数组有一个包含工资的数组[1500, 1200, 2000, 2100, 1800]，要求把数组中工资超过2000的\n删除，剩余的放到新数组里面 \nvar arr = [1500, 1200, 2000, 2100, 1800]; var newArr = []; for (var i = 0; i &lt; arr.length; i++) &#123;     if (arr[i] &lt; 2000) &#123;         newArr.push(arr[i]);     &#125; &#125; console.log(newArr); \n\n数组排序\n\n\n方法名\n说明\n是否修改原数组\n\n\n\nreverse()\n颠倒数组中元素的顺序，无参数\n该方法会改变原来的数组，返回新数组\n\n\nsort()\n对数组的元素进行排序\n该方法会改变原来的数组，返回新数组\n\n\nvar arr = [1, 64, 9, 6]; arr.sort(function(a, b) &#123;     return b - a;      // 降序的顺序排列    // return a - b;   // 升序的顺序排列&#125;); console.log(arr); \n\n数组索引方法\n\n\n方法名\n说明\n返回值\n\n\n\nindexOf()\n数组中查找指定元素的第一个索引号，从前面查找\n如果存在返回索引号，如果不存在，返回 -1\n\n\nlastIndexOf()\n数组中查找指定元素的第一个索引号，从后面查找\n如果存在返回索引号，如果不存在，返回 -1\n\n\n数组去重（重点案例）有一个数组[‘c’, ‘a’, ‘z’, ‘a’, ‘x’, ‘a’, ‘x’, ‘c’, ‘b’]，要求去除数组中重复的元素。 \n案例分析：\n目标：把旧数组里面不重复的元素选取出来放到新数组中，重复的元素只保留一个，放\n到新数组中去重。 \n核心算法：我们遍历旧数组，然后拿着旧数组元素去查询新数组，如果该元素在新数组\n里面没有出现过，我们就添加， 否则不添加。\n我们怎么知道该元素没有存在？  利用 新数组.indexOf(数组元素)  如果返回时 -1 就说明 \n新数组里面没有改元素\n​    旧数组  [‘c’, ‘a’, ‘z’, ‘a’, ‘x’, ‘a’, ‘x’, ‘c’, ‘b’]​    新数组  [ ]\nfunction unique(arr) &#123;      var newArr = [];      for (var i = 0; i &lt; arr.length; i++) &#123;        if (newArr.indexOf(arr[i]) === -1) &#123;          newArr.push(arr[i]);        &#125;      &#125;      return newArr;    &#125;    var demo = unique([&quot;green&quot;, &quot;blue&quot;, &quot;green&quot;]);    console.log(demo);\n\n数组转换为字符串\n\n\n方法名\n说明\n返回值\n\n\n\ntoString()\n把数组转换成字符串，逗号分隔每一项\n返回一个字符串\n\n\njoin(‘分隔符’)\n方法用于把数组中的所有元素转换为一个字符串\n返回一个字符串\n\n\n其他方法\n\n\n方法名\n说明\n返回值\n\n\n\nconcat()\n连接两个或多个数组，不影响原数组\n返回一个新的数组\n\n\nslice()\n数组截取 slice(begin,end)\n返回被截取项目的新数组\n\n\nsplice()\n数组删除 splice(第几个开始，要删除的个数)\n返回被删除项目的新数组。注意，这个会影响原数组\n\n\n字符串对象基本包装类型为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、\nNumber和 Boolean。 \n基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属\n性和方法。 \n// 下面代码有什么问题？ var str = &#x27;andy&#x27;; console.log(str.length);\n\n按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以\n执行，这是因为 js 会把 基本数据类型包装为复杂数据类型，其执行过程如下 ： \n// 1. 生成临时变量，把简单类型包装为复杂数据类型 var temp = new String(&#x27;andy&#x27;); // 2. 赋值给我们声明的字符变量 str = temp; // 3. 销毁临时变量 temp = null;\n\n字符串的不可变指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟\n了一个内存空间。 \nvar str = &#x27;abc&#x27;; str = &#x27;hello&#x27;; // 当重新给 str 赋值的时候，常量&#x27;abc&#x27;不会被修改，依然在内存中 // 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变 // 由于字符串的不可变，在大量拼接字符串的时候会有效率问题 var str = &#x27;&#x27;; for (var i = 0; i &lt; 100000; i++) &#123;     str += i; &#125; console.log(str); // 这个结果需要花费大量时间来显示，因为需要不断的开辟新的空间 \n\n根据字符返回位置字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新\n的字符串。 \n\n\n\n方法名\n说明\n\n\n\nindexOf(‘要查找的字符’，开始的位置)\n返回指定内容在原字符串中的位置，如果找不到就返回 -1，开始的位置是 index 索引号\n\n\nlastIndexOf()\n从后往前找，只找第一个匹配的\n\n\n案例：返回字符位置查找字符串”abcoefoxyozzopp”中所有o出现的位置以及次数 \n思路：\n\n核心算法：先查找第一个o出现的位置 \n\n然后 只要indexOf 返回的结果不是 -1 就继续往后查找\n\n因为indexOf 只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加\n1，从而继续查找\n\n\nvar str = &quot;ooabcoefoxyozzopp&quot;; var index = str.indexOf(&quot;o&quot;); var num = 0; while (index !== -1) &#123;   console.log(index);   num++;   index = str.indexOf(&quot;o&quot;, index + 1); &#125;console.log(&quot;0出现的次数：&quot; + num);\n\n根据位置返回字符（重点）\n\n\n方法名\n说明\n使用\n\n\n\ncharAt(index)\n返回指定位置的字符（index 字符串的索引号）\nstr.charAt(0)\n\n\ncharCodeAt(index)\n获取指定位置处字符的ASCII码（index 索引号）\nstr.charCodeAt(0)\n\n\nstr[index]\n获取指定位置处字符\nHTML5，IE8+支持，和charAt()等效\n\n\n\n案例：返回字符位置\n判断一个字符串 ‘abcoefoxyozzopp’ 中出现次数最多的字符，并统计其次数。 \n核心算法：\n\n核心算法：利用 charAt(） 遍历这个字符串\n把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1\n遍历对象，得到最大值和该字符\n\nvar str = &quot;abcoefoxyozzopp&quot;;var o = &#123;&#125;;for (var i = 0; i &lt; str.length; i++) &#123;  var chars = str.charAt(i); // chars 是字符串的每一个字符  if (o[chars]) &#123;\t\t\t// o[chars] 得到的是属性值    o[chars]++;  &#125; else &#123;    o[chars] = 1;  &#125;&#125;console.log(o);//遍历对象var max = 0;var ch = &quot;&quot;;for (var k in o) &#123;  // k 得到的是 属性名  // o[k] 得到的是 属性值  if (o[k] &gt; max) &#123;    max = o[k];    ch = k;  &#125;&#125;console.log(max);console.log(&quot;出现最多的是：&quot; + ch);\n\n字符串操作方法（重点）\n\n\n方法名\n说明\n\n\n\nconcat(str1,str2,str3…)\nconcat()  方法用于连接两个或多个字符串。拼接字符串，等效于 +，+ 更常用\n\n\nsubstr(start,length)\n从 start 位置开始（索引号），length 取的个数   重点记住这个\n\n\nslice(start,end)\n从start 位置开始，截取到 end 位置，end 取不到（他们俩都是索引号）\n\n\nsubstring(start,end)\n从start 位置开始，截取到 end 位置，end 取不到。基本和 slice 相同，但是不接受负值\n\n\nreplace() 方法replace() 方法用于在字符串中用一些字符替换另一些字符。 只会替换第一个字符\nreplace(被替换的字符串， 要替换为的字符串)； \n\nsplit() 方法split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一\n个新数组。 \nvar str = &#x27;a,b,c,d&#x27;; console.log(str.split(&#x27;,&#x27;));   // 返回的是一个数组 [a, b, c, d] \n\nJavaScript 简单类型和复杂类型简单类型与复杂类型简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。\n\n值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做\n值类型\n\n\nstring ，number，boolean，undefined，null\n\n引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做\n引用数据类型\n\n\n通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等\n堆和栈堆栈空间分配区别： \n1.栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。\n其操作方式类似于数据结构中的栈；\n简单数据类型存放到栈里面\n2.堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由\n垃圾回收机制回收。 \n复杂数据类型存放到堆里面 \n\n注意：JavaScript中没有堆栈的概念，通过堆栈的方式，可以让大家更容易理解代码的一\n些执行方式，便于将来学习其他语言。 \n\n简单类型的内存分配\n值类型（简单数据类型）： string ，number，boolean，undefined，null\n值类型变量的数据直接存放在变量（栈空间）中\n\n\n复杂类型的内存分配\n引用类型（复杂数据类型）：通过 new 关键字创建的对象（系统对象、自定义对\n象），如 Object、Array、Date等\n\n引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中\n\n\n\n简单类型传参函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参\n时，其实是把变量在栈 空间里的值复制了一份给形参，那么在方法内部对形参做任何修\n改，都不会影响到的外部变量。\n\nfunction fn(a) &#123;     a++;     console.log(a);  // 11&#125; var x = 10; fn(x); console.log(x)； \t// 10\n\n复杂类型传参函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量\n在栈空间里保存的堆地 址复制给了形参，形参和实参其实保存的是同一个堆地址，所以\n操作的是同一个对象。 \n\nfunction Person(name) &#123;     this.name = name; &#125; function f1(x) &#123; // x = p     console.log(x.name); // 2. 这个输出什么 ?     刘德华    x.name = &quot;张学友&quot;;     console.log(x.name); // 3. 这个输出什么 ?     张学友&#125; var p = new Person(&quot;刘德华&quot;); console.log(p.name);    // 1. 这个输出什么 ?      刘德华f1(p); console.log(p.name);    // 4. 这个输出什么 ? \t\t张学友\n\n\n\n","categories":["黑马前端"],"tags":["JS"]},{"title":"黑马前端-JS高级笔记","url":"/2021/10/16/%E9%BB%91%E9%A9%AC%E5%89%8D%E7%AB%AF-JS%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/","content":"JavaScript 面向对象面向对象编程介绍两大编程思想\n面向过程\n面向对象 \n\n面向过程编程 POP(Process-oriented programming)面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依 次调用就可以了。\n举个栗子：将大象装进冰箱，面向过程做法。\n\n面向过程，就是按照我们分析好了的步骤，按照步骤解决问题。\n面向对象编程 OOP (Object Oriented Programming)面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。 \n举个栗子：将大象装进冰箱，面向对象做法。 \n先找出对象，并写出这些对象的功能： \n\n大象对象\n\n\n进去 \n\n\n冰箱对象 \n\n\n打开\n关闭 \n\n\n使用大象和冰箱的功能  \n\n面向对象是以对象功能来划分问题，而不是步骤。 \n在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。 \n面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。 \n面向对象的特性： \n\n封装性\n继承性\n多态性\n\n\n面向过程和面向对象的对比面向过程\n\n优点：性能比面向对象高，适合跟硬件联系很紧密 的东西，例如单片机就采用的面向过程编程\n缺点：没有面向对象易维护、易复用、易扩展\n\n面向对象 \n\n优点：易维护、易复用、易扩展，由于面向对象有 封装、继承、多态性的特性，可以设计出低耦合的 系统，使系统 更加灵活、更加易于维护\n缺点：性能比面向过程低\n\n用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭。\nES6 中的类和对象面向对象面向对象更贴近我们的实际生活, 可以使用面向对象描述现实世界事物.  但是事物分为具体的事物和抽象的事物。\n\n面向对象的思维特点:  \n\n抽取（抽象）对象共用的属性和行为组织(封装)成一个类(模板) \n对类进行实例化, 获取类的对象\n\n面向对象编程我们考虑的是有哪些对象，按照面向对象的思维特点,不断的创建对象,使用对象,指挥对象做事情。\n对象现实生活中：万物皆对象，对象是一个具体的事物，看得见摸得着的实物。例如，一本书、一辆汽车、一个人 可以是“对象”，一个数据库、一张网页、一个与远程服务器的连接也可以是“对象”。 \n在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、 函数等。\n对象是由属性和方法组成的：\n\n属性：事物的特征，在对象中用属性来表示（常用名词） \n方法：事物的行为，在对象中用方法来表示（常用动词） \n\n类 class在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。 \n类抽象了对象的公共部分，它泛指某一大类（class） \n对象特指某一个，通过类实例化一个具体的对象\n\n面向对象的思维特点:  \n\n抽取（抽象）对象共用的属性和行为组织(封装)成一个类(模板) \n对类进行实例化, 获取类的对象 \n\n创建类语法：\nclass name &#123;   // class body &#125;  \n\n创建实例： \nvar xx = new name();\n\n注意： 类必须使用 new 实例化对象\n类 constructor 构造函数constructor() 方法是类的构造函数(默认方法)，用于传递参数,返回实例对象，通过 new 命令生成对象实例时 ，自动调用该方法。如果没有显示定义, 类内部会自动给我们创建一个constructor()  \n语法：\nclass Person &#123;   \tconstructor(name,age) &#123;   // constructor 构造方法或者构造函数       \t\t  this.name = name;       \t\tthis.age = age;     \t&#125; &#125;\n\n创建实例：\nvar ldh = new Person(&#x27;刘德华&#x27;, 18);  console.log(ldh.name) \n\n// 1. 创建类 class  创建一个 明星类class Star &#123;    constructor(uname, age) &#123;        this.uname = uname;        this.age = age;    &#125;&#125;// 2. 利用类创建对象 newvar ldh = new Star(&#x27;刘德华&#x27;, 18);var zxy = new Star(&#x27;张学友&#x27;, 20);console.log(ldh);console.log(zxy);//(1) 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写//(2) 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象//(3) constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数//(4) 生成实例 new 不能省略//(5) 最后注意语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function\n\n类添加方法语法：\nclass Person &#123;   \tconstructor(name,age) &#123;   // constructor 构造器或者构造函数       \t\tthis.name = name;       \t   this.age = age;     &#125;    say() &#123;       \tconsole.log(this.name + &#x27;你好&#x27;);    \t&#125; &#125; \n\n创建实例： \nvar ldh = new Person(&#x27;刘德华&#x27;, 18);  ldh.say()\n\n注意： 方法之间不能加逗号分隔，同时方法不需要添加 function 关键字。 \n// 1. 创建类 class  创建一个 明星类class Star &#123;    // 类的共有属性放到 constructor 里面    constructor(uname, age) &#123;        this.uname = uname;        this.age = age;    &#125;    sing(song) &#123;        // console.log(&#x27;我唱歌&#x27;);        console.log(this.uname + song);    &#125;&#125;// 2. 利用类创建对象 newvar ldh = new Star(&#x27;刘德华&#x27;, 18);var zxy = new Star(&#x27;张学友&#x27;, 20);console.log(ldh);console.log(zxy);// (1) 我们类里面所有的函数不需要写function //(2) 多个函数方法之间不需要添加逗号分隔ldh.sing(&#x27;冰雨&#x27;);zxy.sing(&#x27;李香兰&#x27;);\n\n类的继承继承现实中的继承：子承父业，比如我们都继承了父亲的姓。\n程序中的继承：子类可以继承父类的一些属性和方法。\n语法：\nclass Father&#123;   // 父类 &#125;  class  Son extends Father &#123;  // 子类继承父类 &#125; \n\n实例：\nclass Father &#123;       \tconstructor(surname) &#123;         \tthis.surname= surname;       \t&#125;       \t\tsay() &#123;         \t\t\tconsole.log(&#x27;你的姓是&#x27; + this.surname);        &#125; &#125; class Son extends Father&#123;  // 这样子类就继承了父类的属性和方法 &#125; var damao= new Son(&#x27;刘&#x27;); damao.say(); \n\n// 1. 类的继承// class Father &#123;//     constructor() &#123;//     &#125;//     money() &#123;//         console.log(100);//     &#125;// &#125;// class Son extends Father &#123;// &#125;// var son = new Son();// son.money();class Father &#123;    constructor(x, y) &#123;        this.x = x;        this.y = y;    &#125;    sum() &#123;        console.log(this.x + this.y);    &#125;&#125;class Son extends Father &#123;    constructor(x, y) &#123;        super(x, y); //调用了父类中的构造函数    &#125;&#125;var son = new Son(1, 2);var son1 = new Son(11, 22);son.sum();son1.sum();\n\nsuper 关键字super 关键字用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数\n语法：\nclass Person &#123;   // 父类       \tconstructor(surname)&#123;          \tthis.surname = surname;      \t&#125; &#125;  class  Student extends Person &#123;       // 子类继承父类   \t\t\t\t\tconstructor(surname,firstname)&#123;           \t\tsuper(surname);             // 调用父类的constructor(surname)  \t\t  this.firstname = firstname; // 定义子类独有的属性      \t&#125; &#125;\n\n注意: 子类在构造函数中使用super, 必须放到 this 前面  (必须先调用父类的构造方法,在使用子类构造方法) \n案例：\nclass Father &#123;     \tconstructor(surname) &#123;         \t\tthis.surname = surname;      \t&#125;     \tsaySurname() &#123;       \t\tconsole.log(&#x27;我的姓是&#x27; + this.surname);     \t&#125; &#125; class Son extends Father &#123; // 这样子类就继承了父类的属性和方法     \t\t\tconstructor(surname, fristname) &#123;          \t\tsuper(surname);   // 调用父类的constructor(surname)          \t\tthis.fristname = fristname;      &#125;     \tsayFristname() &#123;          \t\tconsole.log(&quot;我的名字是：&quot; + this.fristname); \t    &#125; &#125; var damao = new Son(&#x27;刘&#x27;, &quot;德华&quot;); damao.saySurname(); damao.sayFristname(); \n\nsuper关键字 用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数。 \n语法：\nclass Father &#123;      \tsay() &#123;          \t\treturn &#x27;我是爸爸&#x27;;      &#125; &#125; class Son extends Father &#123; // 这样子类就继承了父类的属性和方法      \tsay() &#123;           \t\t// super.say()  super 调用父类的方法           \t\treturn super.say() + &#x27;的儿子&#x27;;      \t&#125; &#125; var damao = new Son(); console.log(damao.say()); \n\n// super 关键字调用父类普通函数class Father &#123;    say() &#123;        return &#x27;我是爸爸&#x27;;    &#125;&#125;class Son extends Father &#123;    say() &#123;        // console.log(&#x27;我是儿子&#x27;);        console.log(super.say() + &#x27;的儿子&#x27;);        // super.say() 就是调用父类中的普通函数 say()    &#125;&#125;var son = new Son();son.say();// 继承中的属性或者方法查找原则: 就近原则// 1. 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的// 2. 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则)\n\n// 父类有加法方法class Father &#123;    constructor(x, y) &#123;        this.x = x;        this.y = y;    &#125;    sum() &#123;        console.log(this.x + this.y);    &#125;&#125;// 子类继承父类加法方法 同时 扩展减法方法class Son extends Father &#123;    constructor(x, y) &#123;        // 利用super 调用父类的构造函数        // super 必须在子类this之前调用        super(x, y);        this.x = x;        this.y = y;    &#125;    subtract() &#123;        console.log(this.x - this.y);    &#125;&#125;var son = new Son(5, 3);son.subtract();son.sum();\n\n三个注意点\n在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象. \n类里面的共有属性和方法一定要加this使用. \n类里面的this指向问题.  \nconstructor 里面的this指向实例对象, 方法里面的this 指向这个方法的调用者 \n\n&lt;button&gt;点击&lt;/button&gt;&lt;script&gt;    var that;    var _that;    class Star &#123;        constructor(uname, age) &#123;            // constructor 里面的this 指向的是 创建的实例对象            that = this;            console.log(this);            this.uname = uname;            this.age = age;            // this.sing();            this.btn = document.querySelector(&#x27;button&#x27;);            this.btn.onclick = this.sing;        &#125;        sing() &#123;            // 这个sing方法里面的this 指向的是 btn 这个按钮,因为这个按钮调用了这个函数            console.log(this);            console.log(that.uname); // that里面存储的是constructor里面的this        &#125;        dance() &#123;            // 这个dance里面的this 指向的是实例对象 ldh 因为ldh 调用了这个函数            _that = this;            console.log(this);        &#125;    &#125;    var ldh = new Star(&#x27;刘德华&#x27;);    console.log(that === ldh);    ldh.dance();    console.log(_that === ldh);    // 1. 在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象    // 2. 类里面的共有的属性和方法一定要加this使用.\n\n面向对象案例案例：面向对象版 tab 栏切换 \n构造函数和原型构造函数和原型概述在典型的 OOP 的语言中（如 Java），都存在类的概念，类就是对象的模板，对象就是类的实例，但在 ES6之前， JS 中并没用引入类的概念。 \nES6， 全称 ECMAScript 6.0 ，2015.06 发版。但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏 览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。\n在 ES6之前 ，对象不是基于类创建的，而是用一种称为构建函数的特殊函数来定义对象和它们的特征。 \n创建对象可以通过以下三种方式：\n\n对象字面量 \nnew Object() \n自定义构造函数\n\n// 1. 利用 new Object() 创建对象var obj1 = new Object();// 2. 利用 对象字面量创建对象var obj2 = &#123;&#125;;// 3. 利用构造函数创建对象function Star(uname, age) &#123;    this.uname = uname;    this.age = age;    this.sing = function() &#123;        console.log(&#x27;我会唱歌&#x27;);    &#125;&#125;var ldh = new Star(&#x27;刘德华&#x27;, 18);var zxy = new Star(&#x27;张学友&#x27;, 19);console.log(ldh);ldh.sing();zxy.sing();\n\n构造函数构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 一起使用。我 们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。 \n在 JS 中，使用构造函数时要注意以下两点： \n\n构造函数用于创建某一类对象，其首字母要大写 \n构造函数要和 new 一起使用才有意义 \n\nnew 在执行时会做四件事情：\n\n在内存中创建一个新的空对象\n让 this 指向这个新的对象\n执行构造函数里面的代码，给这个新对象添加属性和方法\n返回这个新对象（所以构造函数里面不需要 return ）\n\nJavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添 加。通过这两种方式添加的成员，就分别称为静态成员和实例成员。 \n\n静态成员：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问\n实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问\n\n// 构造函数中的属性和方法我们称为成员, 成员可以添加function Star(uname, age) &#123;    this.uname = uname;    this.age = age;    this.sing = function() &#123;        console.log(&#x27;我会唱歌&#x27;);    &#125;&#125;var ldh = new Star(&#x27;刘德华&#x27;, 18);// 1.实例成员就是构造函数内部通过this添加的成员 uname age sing 就是实例成员// 实例成员只能通过实例化的对象来访问console.log(ldh.uname);ldh.sing();// console.log(Star.uname); // 不可以通过构造函数来访问实例成员// 2. 静态成员 在构造函数本身上添加的成员  sex 就是静态成员Star.sex = &#x27;男&#x27;;// 静态成员只能通过构造函数来访问console.log(Star.sex);console.log(ldh.sex); // 不能通过对象来访问\n\n构造函数的问题构造函数方法很好用，但是存在浪费内存的问题。 \n\n我们希望所有的对象使用同一个函数，这样就比较节省内存，那么我们要怎样做呢？ \n构造函数原型 prototype构造函数通过原型分配的函数是所有对象所共享的。 \nJavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。注意这个 prototype 就是一 个对象，这个对象的所有属性和方法，都会被构造函数所拥有。\n我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。 \n问答？ \n\n原型是什么 ？一个对象，我们也称为 prototype 为原型对象。 \n原型的作用是什么 ？共享方法。 \n\n// 1. 构造函数的问题. function Star(uname, age) &#123;    this.uname = uname;    this.age = age;    // this.sing = function() &#123;    //     console.log(&#x27;我会唱歌&#x27;);    // &#125;&#125;Star.prototype.sing = function() &#123;    console.log(&#x27;我会唱歌&#x27;);&#125;var ldh = new Star(&#x27;刘德华&#x27;, 18);var zxy = new Star(&#x27;张学友&#x27;, 19);console.log(ldh.sing === zxy.sing);// console.dir(Star);ldh.sing();zxy.sing();// 2. 一般情况下,我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上\n\n对象原型 _ proto _对象都会有一个属性 __ proto __ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __ proto __ 原型的存在。 \n\n __ proto __ 对象原型和原型对象 prototype 是等价的\n __ proto __对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性， 因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype\n\n \nfunction Star(uname, age) &#123;    this.uname = uname;    this.age = age;&#125;Star.prototype.sing = function() &#123;    console.log(&#x27;我会唱歌&#x27;);&#125;var ldh = new Star(&#x27;刘德华&#x27;, 18);var zxy = new Star(&#x27;张学友&#x27;, 19);ldh.sing();console.log(ldh); // 对象身上系统自己添加一个 __proto__ 指向我们构造函数的原型对象 prototypeconsole.log(ldh.__proto__ === Star.prototype);// 方法的查找规则: 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing// 如果么有sing 这个方法,因为有__proto__ 的存在,就去构造函数原型对象prototype身上去查找sing这个方法\n\nconstructor  构造函数对象原型（ __ proto __）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称 为构造函数，因为它指回构造函数本身。\nconstructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。 \n一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋 值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor  就不再指向当前构造函数了。 此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。 \nfunction Star(uname, age) &#123;    this.uname = uname;    this.age = age;&#125;// 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数// Star.prototype.sing = function() &#123;//     console.log(&#x27;我会唱歌&#x27;);// &#125;;// Star.prototype.movie = function() &#123;//     console.log(&#x27;我会演电影&#x27;);// &#125;Star.prototype = &#123;    // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数    constructor: Star,    sing: function() &#123;        console.log(&#x27;我会唱歌&#x27;);    &#125;,    movie: function() &#123;        console.log(&#x27;我会演电影&#x27;);    &#125;&#125;var ldh = new Star(&#x27;刘德华&#x27;, 18);var zxy = new Star(&#x27;张学友&#x27;, 19);console.log(Star.prototype);console.log(ldh.__proto__);console.log(Star.prototype.constructor);console.log(ldh.__proto__.constructor);\n\n构造函数、实例、原型对象三者之间的关系\n原型链\nfunction Star(uname, age) &#123;    this.uname = uname;    this.age = age;&#125;Star.prototype.sing = function() &#123;    console.log(&#x27;我会唱歌&#x27;);&#125;var ldh = new Star(&#x27;刘德华&#x27;, 18);// 1. 只要是对象就有__proto__ 原型, 指向原型对象console.log(Star.prototype);console.log(Star.prototype.__proto__ === Object.prototype);// 2.我们Star原型对象里面的__proto__原型指向的是 Object.prototypeconsole.log(Object.prototype.__proto__);// 3. 我们Object.prototype原型对象里面的__proto__原型  指向为 null\n\nJavaScript 的成员查找机制(规则)\n当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性\n如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）\n如果还没有就查找原型对象的原型（Object的原型对象）\n依此类推一直找到 Object 为止（null）\n__ proto __对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线\n\nfunction Star(uname, age) &#123;    this.uname = uname;    this.age = age;&#125;Star.prototype.sing = function() &#123;    console.log(&#x27;我会唱歌&#x27;);&#125;Star.prototype.sex = &#x27;女&#x27;;// Object.prototype.sex = &#x27;男&#x27;;var ldh = new Star(&#x27;刘德华&#x27;, 18);ldh.sex = &#x27;男&#x27;;console.log(ldh.sex);console.log(Object.prototype);console.log(ldh);console.log(Star.prototype);console.log(ldh.toString());\n\n原型对象this指向构造函数中的this 指向我们实例对象。\n原型对象里面放的是方法,  这个方法里面的this 指向的是 这个方法的调用者, 也就是这个实例对象。\nfunction Star(uname, age) &#123;    this.uname = uname;    this.age = age;&#125;var that;Star.prototype.sing = function() &#123;    console.log(&#x27;我会唱歌&#x27;);    that = this;&#125;var ldh = new Star(&#x27;刘德华&#x27;, 18);// 1. 在构造函数中,里面this指向的是对象实例 ldhldh.sing();console.log(that === ldh);// 2.原型对象函数里面的this 指向的是 实例对象 ldh\n\n扩展内置对象可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。 \n注意：数组和字符串内置对象不能给原型对象覆盖操作 Array.prototype = {} ，只能是 Array.prototype.xxx = function(){} 的方式。\n// 原型对象的应用 扩展内置对象方法Array.prototype.sum = function() &#123;    var sum = 0;    for (var i = 0; i &lt; this.length; i++) &#123;        sum += this[i];    &#125;    return sum;&#125;;// Array.prototype = &#123;//     sum: function() &#123;//         var sum = 0;//         for (var i = 0; i &lt; this.length; i++) &#123;//             sum += this[i];//         &#125;//         return sum;//     &#125;// &#125;var arr = [1, 2, 3];console.log(arr.sum());console.log(Array.prototype);var arr1 = new Array(11, 22, 33);console.log(arr1.sum());\n\n继承ES6之前并没有给我们提供 extends 继承。我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承。 \ncall()调用这个函数, 并且修改函数运行时的 this 指向\nfun.call(thisArg, arg1, arg2, ...) \n\n\nthisArg ：当前调用函数 this 的指向对象\narg1，arg2：传递的其他参数\n\n// call 方法function fn(x, y) &#123;    console.log(&#x27;我想喝手磨咖啡&#x27;);    console.log(this);    console.log(x + y);&#125;var o = &#123;    name: &#x27;andy&#x27;&#125;;// fn();// 1. call() 可以调用函数// fn.call();// 2. call() 可以改变这个函数的this指向 此时这个函数的this 就指向了o这个对象fn.call(o, 1, 2);\n\n借用构造函数继承父类型属性核心原理： 通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。\n    // 父类     function Person(name, age, sex) &#123;       this.name = name;       this.age = age;       this.sex = sex;     &#125;     // 子类     function Student(name, age, sex, score) &#123;       \tPerson.call(this, name, age, sex);  // 此时父类的 this 指向子类的 this，同时调用这个函数       \tthis.score = score;     &#125;     var s1 = new Student(&#x27;zs&#x27;, 18, &#x27;男&#x27;, 100);     console.dir(s1); \n\n// 借用父构造函数继承属性// 1. 父构造函数function Father(uname, age) &#123;    // this 指向父构造函数的对象实例    this.uname = uname;    this.age = age;&#125;// 2 .子构造函数 function Son(uname, age, score) &#123;    // this 指向子构造函数的对象实例    Father.call(this, uname, age);    this.score = score;&#125;var son = new Son(&#x27;刘德华&#x27;, 18, 100);console.log(son);\n\n借用原型对象继承父类型方法一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。\n核心原理：\n\n将子类所共享的方法提取出来，让子类的 prototype 原型对象 = new 父类() \n本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象\n将子类的 constructor 从新指向子类的构造函数\n\n// 借用父构造函数继承属性// 1. 父构造函数function Father(uname, age) &#123;    // this 指向父构造函数的对象实例    this.uname = uname;    this.age = age;&#125;Father.prototype.money = function() &#123;    console.log(100000);&#125;;// 2 .子构造函数 function Son(uname, age, score) &#123;    // this 指向子构造函数的对象实例    Father.call(this, uname, age);    this.score = score;&#125;// Son.prototype = Father.prototype;  这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化Son.prototype = new Father();// 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数Son.prototype.constructor = Son;// 这个是子构造函数专门的方法Son.prototype.exam = function() &#123;    console.log(&#x27;孩子要考试&#x27;);&#125;var son = new Son(&#x27;刘德华&#x27;, 18, 100);console.log(son);console.log(Father.prototype);console.log(Son.prototype.constructor);\n\nES5 中的新增方法ES5 中给我们新增了一些方法，可以很方便的操作数组或者字符串，这些方法主要包括： \n\n数组方法\n字符串方法\n对象方法\n\n数组方法 forEach()迭代(遍历)方法：forEach()、map()、filter()、some()、every()； \narray.forEach(function(currentValue, index, arr)) \n\n\ncurrentValue：数组当前项的值\nindex：数组当前项的索引\narr：数组对象本身\n\n// forEach 迭代(遍历) 数组var arr = [1, 2, 3];var sum = 0;arr.forEach(function(value, index, array) &#123;    console.log(&#x27;每个数组元素&#x27; + value);    console.log(&#x27;每个数组元素的索引号&#x27; + index);    console.log(&#x27;数组本身&#x27; + array);    sum += value;&#125;)console.log(sum);\n\n数组方法 filter()array.filter(function(currentValue, index, arr)) \n\n\nfilter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素,主要用于筛选数组\n注意它直接返回一个新数组\ncurrentValue: 数组当前项的值\nindex：数组当前项的索引\narr：数组对象本身\n\n// filter 筛选数组var arr = [12, 66, 4, 88, 3, 7];var newArr = arr.filter(function(value, index) &#123;    // return value &gt;= 20;    return value % 2 === 0;&#125;);console.log(newArr);\n\n数组方法 some()array.some(function(currentValue, index, arr)) \n\n\nsome() 方法用于检测数组中的元素是否满足指定条件.   通俗点 查找数组中是否有满足条件的元素\n注意它返回值是布尔值, 如果查找到这个元素, 就返回true ,  如果查找不到就返回false\n如果找到第一个满足条件的元素,则终止循环. 不在继续查找\ncurrentValue: 数组当前项的值\nindex：数组当前项的索引\narr：数组对象本身\n\n// some 查找数组中是否有满足条件的元素 // var arr = [10, 30, 4];// var flag = arr.some(function(value) &#123;//     // return value &gt;= 20;//     return value &lt; 3;// &#125;);// console.log(flag);var arr1 = [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;];var flag1 = arr1.some(function(value) &#123;    return value == &#x27;pink&#x27;;&#125;);console.log(flag1);// 1. filter 也是查找满足条件的元素 返回的是一个数组 而且是把所有满足条件的元素返回回来// 2. some 也是查找满足条件的元素是否存在  返回的是一个布尔值 如果查找到第一个满足条件的元素就终止循环\n\n案例：查询商品\n把数据渲染到页面中 (forEach) \n根据价格显示数据  \n根据商品名称显示数据 \n\n&lt;div class=&quot;search&quot;&gt;    按照价格查询: &lt;input type=&quot;text&quot; class=&quot;start&quot;&gt; - &lt;input type=&quot;text&quot; class=&quot;end&quot;&gt; &lt;button class=&quot;search-price&quot;&gt;搜索&lt;/button&gt; 按照商品名称查询: &lt;input type=&quot;text&quot; class=&quot;product&quot;&gt; &lt;button class=&quot;search-pro&quot;&gt;查询&lt;/button&gt;&lt;/div&gt;&lt;table&gt;    &lt;thead&gt;        &lt;tr&gt;            &lt;th&gt;id&lt;/th&gt;            &lt;th&gt;产品名称&lt;/th&gt;            &lt;th&gt;价格&lt;/th&gt;        &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;    &lt;/tbody&gt;&lt;/table&gt;&lt;script&gt;    // 利用新增数组方法操作数据    var data = [&#123;        id: 1,        pname: &#x27;小米&#x27;,        price: 3999    &#125;, &#123;        id: 2,        pname: &#x27;oppo&#x27;,        price: 999    &#125;, &#123;        id: 3,        pname: &#x27;荣耀&#x27;,        price: 1299    &#125;, &#123;        id: 4,        pname: &#x27;华为&#x27;,        price: 1999    &#125;, ];    // 1. 获取相应的元素    var tbody = document.querySelector(&#x27;tbody&#x27;);    var search_price = document.querySelector(&#x27;.search-price&#x27;);    var start = document.querySelector(&#x27;.start&#x27;);    var end = document.querySelector(&#x27;.end&#x27;);    var product = document.querySelector(&#x27;.product&#x27;);    var search_pro = document.querySelector(&#x27;.search-pro&#x27;);    setDate(data);    // 2. 把数据渲染到页面中    function setDate(mydata) &#123;        // 先清空原来tbody 里面的数据        tbody.innerHTML = &#x27;&#x27;;        mydata.forEach(function(value) &#123;            // console.log(value);            var tr = document.createElement(&#x27;tr&#x27;);            tr.innerHTML = &#x27;&lt;td&gt;&#x27; + value.id + &#x27;&lt;/td&gt;&lt;td&gt;&#x27; + value.pname + &#x27;&lt;/td&gt;&lt;td&gt;&#x27; + value.price + &#x27;&lt;/td&gt;&#x27;;            tbody.appendChild(tr);        &#125;);    &#125;    // 3. 根据价格查询商品    // 当我们点击了按钮,就可以根据我们的商品价格去筛选数组里面的对象    search_price.addEventListener(&#x27;click&#x27;, function() &#123;        // alert(11);        var newDate = data.filter(function(value) &#123;            return value.price &gt;= start.value &amp;&amp; value.price &lt;= end.value;        &#125;);        console.log(newDate);        // 把筛选完之后的对象渲染到页面中        setDate(newDate);    &#125;);    // 4. 根据商品名称查找商品    // 如果查询数组中唯一的元素, 用some方法更合适,因为它找到这个元素,就不在进行循环,效率更高]    search_pro.addEventListener(&#x27;click&#x27;, function() &#123;        var arr = [];        data.some(function(value) &#123;            if (value.pname === product.value) &#123;                // console.log(value);                arr.push(value);                return true; // return 后面必须写true              &#125;        &#125;);        // 把拿到的数据渲染到页面中        setDate(arr);    &#125;)&lt;/script&gt;\n\nforEach 和 some 的区别var arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;];// 1. forEach迭代 遍历// arr.forEach(function(value) &#123;//     if (value == &#x27;green&#x27;) &#123;//         console.log(&#x27;找到了该元素&#x27;);//         return true; // 在forEach 里面 return 不会终止迭代//     &#125;//     console.log(11);// &#125;)// 如果查询数组中唯一的元素, 用some方法更合适,arr.some(function(value) &#123;    if (value == &#x27;green&#x27;) &#123;        console.log(&#x27;找到了该元素&#x27;);        return true; //  在some 里面 遇到 return true 就是终止遍历 迭代效率更高    &#125;    console.log(11);&#125;);// arr.filter(function(value) &#123;//     if (value == &#x27;green&#x27;) &#123;//         console.log(&#x27;找到了该元素&#x27;);//         return true; //  // filter 里面 return 不会终止迭代//     &#125;//     console.log(11);// &#125;);\n\n字符串方法trim()  方法会从一个字符串的两端删除空白字符。 \nstr.trim() \n\ntrim() 方法并不影响原字符串本身，它返回的是一个新的字符串。 \n&lt;input type=&quot;text&quot;&gt; &lt;button&gt;点击&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt;    // trim 方法去除字符串两侧空格    var str = &#x27;   an  dy   &#x27;;    console.log(str);    var str1 = str.trim();    console.log(str1);    var input = document.querySelector(&#x27;input&#x27;);    var btn = document.querySelector(&#x27;button&#x27;);    var div = document.querySelector(&#x27;div&#x27;);    btn.onclick = function() &#123;        var str = input.value.trim();        if (str === &#x27;&#x27;) &#123;            alert(&#x27;请输入内容&#x27;);        &#125; else &#123;            console.log(str);            console.log(str.length);            div.innerHTML = str;        &#125;    &#125;&lt;/script&gt;\n\n对象方法\nObject.keys() 方法返回一个所有元素为字符串的数组。 \n\nObject.keys(obj)\n\n\n效果类似 for…in\n输出对象中值大于 2 的 key 的数组 \n\n// 用于获取对象自身所有的属性var obj = &#123;    id: 1,    pname: &#x27;小米&#x27;,    price: 1999,    num: 2000&#125;;var arr = Object.keys(obj);console.log(arr);arr.forEach(function(value) &#123;    console.log(value);&#125;)\n\n\nObject.defineProperty() 定义新属性或修改原有的属性。\n\nObject.defineProperty(obj, prop, descriptor) \n\n\nobj：必需。目标对象\nprop：必需。需定义或修改的属性的名字\ndescriptor：必需。目标属性所拥有的特性\n\n Object.defineProperty()   第三个参数 descriptor 说明：\n\nvalue: 设置属性的值\nwritable: 值是否可以重写。true | false\nenumerable: 目标属性是否可以被枚举。true | false\nconfigurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false\n\n// Object.defineProperty() 定义新属性或修改原有的属性var obj = &#123;    id: 1,    pname: &#x27;小米&#x27;,    price: 1999&#125;;// 1. 以前的对象添加和修改属性的方式// obj.num = 1000;// obj.price = 99;// console.log(obj);// 2. Object.defineProperty() 定义新属性或修改原有的属性Object.defineProperty(obj, &#x27;num&#x27;, &#123;    value: 1000,    enumerable: true&#125;);console.log(obj);Object.defineProperty(obj, &#x27;price&#x27;, &#123;    value: 9.9&#125;);console.log(obj);Object.defineProperty(obj, &#x27;id&#x27;, &#123;    // 如果值为false 不允许修改这个属性值 默认值也是false    writable: false,&#125;);obj.id = 2;console.log(obj);Object.defineProperty(obj, &#x27;address&#x27;, &#123;    value: &#x27;中国山东蓝翔技校xx单元&#x27;,    // 如果只为false 不允许修改这个属性值 默认值也是false    writable: false,    // enumerable 如果值为false 则不允许遍历, 默认的值是 false    enumerable: false,    // configurable 如果为false 则不允许删除这个属性 不允许在修改第三个参数里面的特性 默认为false    configurable: false&#125;);console.log(obj);console.log(Object.keys(obj));delete obj.address;console.log(obj);delete obj.pname;console.log(obj);Object.defineProperty(obj, &#x27;address&#x27;, &#123;    value: &#x27;中国山东蓝翔技校xx单元&#x27;,    // 如果只为false 不允许修改这个属性值 默认值也是false    writable: true,    // enumerable 如果值为false 则不允许遍历, 默认的值是 false    enumerable: true,    // configurable 如果为false 则不允许删除这个属性 默认为false    configurable: true&#125;);console.log(obj.address);\n\n函数进阶函数的定义和调用函数的定义方式\n函数声明方式 function 关键字 (命名函数) \n函数表达式 (匿名函数) \nnew Function()  \n\nvar fn = new Function(&#x27;参数1&#x27;,&#x27;参数2&#x27;..., &#x27;函数体&#x27;)\n\n\nFunction 里面参数都必须是字符串格式\n第三种方式执行效率低，也不方便书写，因此较少使用\n所有函数都是 Function 的实例(对象) \n函数也属于对象 \n\n\n//  函数的定义方式// 1. 自定义函数(命名函数) function fn() &#123;&#125;;// 2. 函数表达式 (匿名函数)var fun = function() &#123;&#125;;// 3. 利用 new Function(&#x27;参数1&#x27;,&#x27;参数2&#x27;, &#x27;函数体&#x27;);var f = new Function(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;console.log(a + b)&#x27;);f(1, 2);// 4. 所有函数都是 Function 的实例(对象)console.dir(f);// 5. 函数也属于对象console.log(f instanceof Object);\n\n函数的调用方式\n普通函数 \n对象的方法 \n构造函数 \n绑定事件函数 \n定时器函数 \n立即执行函数 \n\n// 函数的调用方式// 1. 普通函数function fn() &#123;    console.log(&#x27;人生的巅峰&#x27;);&#125;// fn();   fn.call()// 2. 对象的方法var o = &#123;    sayHi: function() &#123;        console.log(&#x27;人生的巅峰&#x27;);    &#125;&#125;o.sayHi();// 3. 构造函数function Star() &#123;&#125;;new Star();// 4. 绑定事件函数// btn.onclick = function() &#123;&#125;;   // 点击了按钮就可以调用这个函数// 5. 定时器函数// setInterval(function() &#123;&#125;, 1000);  这个函数是定时器自动1秒钟调用一次// 6. 立即执行函数(function() &#123;    console.log(&#x27;人生的巅峰&#x27;);&#125;)();// 立即执行函数是自动调用\n\nthis函数内 this 的指向这些 this 的指向，是当我们调用函数的时候确定的。 调用方式的不同决定了this 的指向不同 \n一般指向我们的调用者。\n\n\n\n调用方式\nthis指向\n\n\n\n普通函数调用\nwindow\n\n\n构造函数调用\n实例对象，原型对象里面的方法也指向实例对象\n\n\n对象方法调用\n该方法所属对象\n\n\n事件绑定方法\n绑定事件对象\n\n\n定时器函数\nwindow\n\n\n立即执行函数\nwindow\n\n\n&lt;button&gt;点击&lt;/button&gt;&lt;script&gt;    // 函数的不同调用方式决定了this 的指向不同    // 1. 普通函数 this 指向window    function fn() &#123;        console.log(&#x27;普通函数的this&#x27; + this);    &#125;    window.fn();    // 2. 对象的方法 this指向的是对象 o    var o = &#123;        sayHi: function() &#123;            console.log(&#x27;对象方法的this:&#x27; + this);        &#125;    &#125;    o.sayHi();    // 3. 构造函数 this 指向 ldh 这个实例对象 原型对象里面的this 指向的也是 ldh这个实例对象    function Star() &#123;&#125;;    Star.prototype.sing = function() &#123;    &#125;    var ldh = new Star();    // 4. 绑定事件函数 this 指向的是函数的调用者 btn这个按钮对象    var btn = document.querySelector(&#x27;button&#x27;);    btn.onclick = function() &#123;        console.log(&#x27;绑定时间函数的this:&#x27; + this);    &#125;;    // 5. 定时器函数 this 指向的也是window    window.setTimeout(function() &#123;        console.log(&#x27;定时器的this:&#x27; + this);    &#125;, 1000);    // 6. 立即执行函数 this还是指向window    (function() &#123;        console.log(&#x27;立即执行函数的this&#x27; + this);    &#125;)();&lt;/script&gt;\n\n改变函数内部 this 指向JavaScript 为我们专门提供了一些函数方法来帮我们更优雅的处理函数内部 this 的指向问题，常用的有 bind()、 call()、apply() 三种方法。 \ncall 方法call() 方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。 \nfun.call(thisArg, arg1, arg2, ...) \n\n\nthisArg：在 fun 函数运行时指定的 this 值\narg1，arg2：传递的其他参数\n返回值就是函数的返回值，因为它就是调用函数\n因此当我们想改变 this 指向，同时想调用这个函数的时候，可以使用 call，比如继承 \n\n// 改变函数内this指向  js提供了三种方法  call()  apply()  bind()// 1. call()var o = &#123;    name: &#x27;andy&#x27;&#125;function fn(a, b) &#123;    console.log(this);    console.log(a + b);&#125;;fn.call(o, 1, 2);// call 第一个可以调用函数 第二个可以改变函数内的this 指向// call 的主要作用可以实现继承function Father(uname, age, sex) &#123;    this.uname = uname;    this.age = age;    this.sex = sex;&#125;function Son(uname, age, sex) &#123;    Father.call(this, uname, age, sex);&#125;var son = new Son(&#x27;刘德华&#x27;, 18, &#x27;男&#x27;);console.log(son);\n\napply 方法apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。\nfun.apply(thisArg, [argsArray])\n\n\nthisArg：在fun函数运行时指定的 this 值\nargsArray：传递的值，必须包含在数组里面\n返回值就是函数的返回值，因为它就是调用函数\n因此 apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值 \n\n// 改变函数内this指向  js提供了三种方法  call()  apply()  bind()// 2. apply()  应用 运用的意思var o = &#123;    name: &#x27;andy&#x27;&#125;;function fn(arr) &#123;    console.log(this);    console.log(arr); // &#x27;pink&#x27;&#125;;fn.apply(o, [&#x27;pink&#x27;]);// 1. 也是调用函数 第二个可以改变函数内部的this指向// 2. 但是他的参数必须是数组(伪数组)// 3. apply 的主要应用 比如说我们可以利用 apply 借助于数学内置对象求数组最大值 // Math.max();var arr = [1, 66, 3, 99, 4];var arr1 = [&#x27;red&#x27;, &#x27;pink&#x27;];// var max = Math.max.apply(null, arr);var max = Math.max.apply(Math, arr);var min = Math.min.apply(Math, arr);console.log(max, min);\n\nbind 方法bind() 方法不会调用函数。但是能改变函数内部this 指向。\nfun.bind(thisArg, arg1, arg2, ...) \n\n\nthisArg：在 fun 函数运行时指定的 this 值\narg1，arg2：传递的其他参数\n返回由指定的 this 值和初始化参数改造的原函数拷贝\n因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind\n\n&lt;button&gt;点击&lt;/button&gt;&lt;button&gt;点击&lt;/button&gt;&lt;button&gt;点击&lt;/button&gt;&lt;script&gt;    // 改变函数内this指向  js提供了三种方法  call()  apply()  bind()    // 3. bind()  绑定 捆绑的意思    var o = &#123;        name: &#x27;andy&#x27;    &#125;;    function fn(a, b) &#123;        console.log(this);        console.log(a + b);    &#125;;    var f = fn.bind(o, 1, 2);    f();    // 1. 不会调用原来的函数   可以改变原来函数内部的this 指向    // 2. 返回的是原函数改变this之后产生的新函数    // 3. 如果有的函数我们不需要立即调用,但是又想改变这个函数内部的this指向此时用bind    // 4. 我们有一个按钮,当我们点击了之后,就禁用这个按钮,3秒钟之后开启这个按钮    // var btn1 = document.querySelector(&#x27;button&#x27;);    // btn1.onclick = function() &#123;    //     this.disabled = true; // 这个this 指向的是 btn 这个按钮    //     // var that = this;    //     setTimeout(function() &#123;    //         // that.disabled = false; // 定时器函数里面的this 指向的是window    //         this.disabled = false; // 此时定时器函数里面的this 指向的是btn    //     &#125;.bind(this), 3000); // 这个this 指向的是btn 这个对象    // &#125;    var btns = document.querySelectorAll(&#x27;button&#x27;);    for (var i = 0; i &lt; btns.length; i++) &#123;        btns[i].onclick = function() &#123;            this.disabled = true;            setTimeout(function() &#123;                this.disabled = false;            &#125;.bind(this), 2000);        &#125;    &#125;&lt;/script&gt;\n\ncall  apply  bind 总结相同点：\n都可以改变函数内部的this指向。\n区别点：\n\ncall 和 apply  会调用函数, 并且改变函数内部this指向\ncall 和 apply 传递的参数不一样, call 传递参数 aru1, aru2..形式  apply 必须数组形式[arg] \nbind  不会调用函数, 可以改变函数内部this指向\n\n主要应用场景：\n\ncall 经常做继承\napply 经常跟数组有关系.  比如借助于数学对象实现数组最大值最小值 \nbind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向\n\n严格模式什么是严格模式JavaScript 除了提供正常模式外，还提供了严格模式（strict mode）。ES5 的严格模式是采用具有限制性 JavaScript 变体的一种方式，即在严格的条件下运行 JS 代码。 \n严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。 \n严格模式对正常的 JavaScript 语义做了一些更改：  \n\n消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。 \n消除代码运行的一些不安全之处，保证代码运行的安全。 \n提高编译器效率，增加运行速度。 \n禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比 如一些保留字如：class, enum, export, extends, import, super 不能做变量名\n\n开启严格模式严格模式可以应用到整个脚本或个别函数中。因此在使用时，我们可以将严格模式分为为脚本开启严格模式和 为函数开启严格模式两种情况。\n为脚本开启严格模式为整个脚本文件开启严格模式，需要在所有语句之前放一个特定语句“use strict”;（或‘use strict’;）。\n&lt;script&gt;       &quot;use strict&quot;;       console.log(&quot;这是严格模式。&quot;); &lt;/script&gt;\n\n因为”use strict”加了引号，所以老版本的浏览器会把它当作一行普通字符串而忽略。 \n有的 script 基本是严格模式，有的 script 脚本是正常模式，这样不利于文件合并，所以可以将整个脚本文件 放在一个立即执行的匿名函数之中。这样独立创建一个作用域而不影响其他 script 脚本文件。 \n&lt;script&gt;   (function ()&#123;           &quot;use strict&quot;;              var num = 10;           function fn() &#123;&#125;      &#125;)(); &lt;/script&gt;\n\n为函数开启严格模式要给某个函数开启严格模式，需要把“use strict”;  (或 ‘use strict’; ) 声明放在函数体所有语句之前。 \nfunction fn()&#123;       &quot;use strict&quot;;       return &quot;这是严格模式。&quot;; &#125;\n\n将 “use strict” 放在函数体的第一行，则整个函数以 “严格模式” 运行。\n&lt;!-- 为整个脚本(script标签)开启严格模式 --&gt;&lt;script&gt;    &#x27;use strict&#x27;;    //   下面的js 代码就会按照严格模式执行代码&lt;/script&gt;&lt;script&gt;    (function() &#123;        &#x27;use strict&#x27;;    &#125;)();&lt;/script&gt;&lt;!-- 为某个函数开启严格模式 --&gt;&lt;script&gt;    // 此时只是给fn函数开启严格模式    function fn() &#123;        &#x27;use strict&#x27;;        // 下面的代码按照严格模式执行    &#125;    function fun() &#123;        // 里面的还是按照普通模式执行    &#125;&lt;/script&gt;\n\n严格模式中的变化严格模式对 Javascript 的语法和行为，都做了一些改变。\n变量规定\n在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，变量都必须先用 var 命令声明，然后再使用\n严禁删除已经声明变量。例如，delete x; 语法是错误的\n\n严格模式下 this 指向问题\n以前在全局作用域函数中的 this 指向 window 对象\n严格模式下全局作用域中函数中的 this 是 undefined\n以前构造函数时不加 new也可以 调用,当普通函数，this 指向全局对象\n严格模式下,如果 构造函数不加new调用, this 指向的是undefined 如果给他赋值则 会报错\nnew 实例化的构造函数指向创建的对象实例\n定时器 this 还是指向 window \n事件、对象还是指向调用者\n\n函数变化\n函数不能有重名的参数\n函数必须声明在顶层。新版本的 JavaScript 会引入“块级作用域”（ ES6 中已引入）。为了与新版本接轨， 不允许在非函数的代码块内声明函数\n\n更多严格模式要求参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode \n&#x27;use strict&#x27;;// 1. 我们的变量名必须先声明再使用// num = 10;// console.log(num);var num = 10;console.log(num);// 2.我们不能随意删除已经声明好的变量// delete num;// 3. 严格模式下全局作用域中函数中的 this 是 undefined。// function fn() &#123;//     console.log(this); // undefined。// &#125;// fn();// 4. 严格模式下,如果 构造函数不加new调用, this 指向的是undefined 如果给他赋值则 会报错.// function Star() &#123;//     this.sex = &#x27;男&#x27;;// &#125;// // Star();// var ldh = new Star();// console.log(ldh.sex);// 5. 定时器 this 还是指向 window // setTimeout(function() &#123;//     console.log(this);// &#125;, 2000);// a = 1;// a = 2;// 6. 严格模式下函数里面的参数不允许有重名// function fn(a, a) &#123;//     console.log(a + a);// &#125;;// fn(1, 2);function fn() &#123;&#125;\n\n高阶函数高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。 \n&lt;script&gt; function fn(callback)&#123;   callback&amp;&amp;callback(); &#125; fn(function()&#123;alert(&#x27;hi&#x27;)&#125; &lt;/script&gt; \n\n&lt;script&gt; function fn()&#123;     return function() &#123;&#125; &#125;  fn(); &lt;/script&gt;\n\n此时fn 就是一个高阶函数。\n函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。 最典型的就是作为回调函数。 \n同理函数也可以作为返回值传递回来。\n    &lt;style&gt;        div &#123;            position: absolute;            width: 100px;            height: 100px;            background-color: pink;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        // 高阶函数- 函数可以作为参数传递        function fn(a, b, callback) &#123;            console.log(a + b);            callback &amp;&amp; callback();        &#125;        fn(1, 2, function() &#123;            console.log(&#x27;我是最后调用的&#x27;);        &#125;);        $(&quot;div&quot;).animate(&#123;            left: 500        &#125;, function() &#123;            $(&quot;div&quot;).css(&quot;backgroundColor&quot;, &quot;purple&quot;);        &#125;)    &lt;/script&gt;&lt;/body&gt;\n\n闭包变量作用域变量根据作用域的不同分为两种：全局变量和局部变量。 \n\n函数内部可以使用全局变量。 \n函数外部不可以使用局部变量。 \n当函数执行完毕，本作用域内的局部变量会销毁。 \n\n什么是闭包闭包（closure）指有权访问另一个函数作用域中变量的函数。  —–  JavaScript 高级程序设计\n简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。\n&lt;script&gt;      function fn1()&#123;            // fn1 就是闭包函数             var num = 10;             function fn2()&#123;                   console.log(num); // 10             &#125;                fn2()      &#125;       fn1(); &lt;/script&gt; \n\n&lt;script&gt;    // 闭包（closure）指有权访问另一个函数作用域中变量的函数。    // 闭包: 我们fun 这个函数作用域 访问了另外一个函数 fn 里面的局部变量 num    function fn() &#123;        var num = 10;        function fun() &#123;            console.log(num);        &#125;        fun();    &#125;    fn();&lt;/script&gt;\n\n在 chrome 中调试闭包\n打开浏览器，按 F12 键启动 chrome 调试工具。 \n设置断点。 \n找到 Scope 选项（Scope 作用域的意思）。 \n当我们重新刷新页面，会进入断点调试，Scope 里面会有两个参数（global 全局作用域、local 局部作用域）。 \n当执行到 fn2() 时，Scope 里面会多一个 Closure 参数 ，这就表明产生了闭包。 \n\n闭包的作用提问：我们怎么能在 fn() 函数外面访问 fn() 中的局部变量 num 呢 ？ \n&lt;script&gt;      function fn() &#123;                 var num = 10;                 return function &#123;                            console.log(num); // 10                           &#125;   &#125;   var f = fn();   f() &lt;/script&gt;\n\n闭包作用：延伸变量的作用范围。 \n&lt;script&gt;    // 闭包（closure）指有权访问另一个函数作用域中变量的函数。    // 一个作用域可以访问另外一个函数的局部变量     // 我们fn 外面的作用域可以访问fn 内部的局部变量    // 闭包的主要作用: 延伸了变量的作用范围    function fn() &#123;        var num = 10;        // function fun() &#123;        //     console.log(num);        // &#125;        // return fun;        return function() &#123;            console.log(num);        &#125;    &#125;    var f = fn();    f();    // 类似于    // var f = function() &#123;    //         console.log(num);    //     &#125;    // var f =  function fun() &#123;    //         console.log(num);    //     &#125;&lt;/script&gt;\n\n闭包案例循环注册点击事件&lt;ul class=&quot;nav&quot;&gt;    &lt;li&gt;榴莲&lt;/li&gt;    &lt;li&gt;臭豆腐&lt;/li&gt;    &lt;li&gt;鲱鱼罐头&lt;/li&gt;    &lt;li&gt;大猪蹄子&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    // 闭包应用-点击li输出当前li的索引号    // 1. 我们可以利用动态添加属性的方式    var lis = document.querySelector(&#x27;.nav&#x27;).querySelectorAll(&#x27;li&#x27;);    for (var i = 0; i &lt; lis.length; i++) &#123;        lis[i].index = i;        lis[i].onclick = function() &#123;            // console.log(i);            console.log(this.index);        &#125;    &#125;    // 2. 利用闭包的方式得到当前小li 的索引号    for (var i = 0; i &lt; lis.length; i++) &#123;        // 利用for循环创建了4个立即执行函数        // 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量        (function(i) &#123;            // console.log(i);            lis[i].onclick = function() &#123;                console.log(i);            &#125;        &#125;)(i);    &#125;&lt;/script&gt;\n\n循环中的 setTimeout()&lt;ul class=&quot;nav&quot;&gt;    &lt;li&gt;榴莲&lt;/li&gt;    &lt;li&gt;臭豆腐&lt;/li&gt;    &lt;li&gt;鲱鱼罐头&lt;/li&gt;    &lt;li&gt;大猪蹄子&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    // 闭包应用-3秒钟之后,打印所有li元素的内容    var lis = document.querySelector(&#x27;.nav&#x27;).querySelectorAll(&#x27;li&#x27;);    for (var i = 0; i &lt; lis.length; i++) &#123;        (function(i) &#123;            setTimeout(function() &#123;                console.log(lis[i].innerHTML);            &#125;, 3000)        &#125;)(i);    &#125;&lt;/script&gt;\n\n计算打车价格&lt;script&gt;    // 闭包应用-计算打车价格     // 打车起步价13(3公里内),  之后每多一公里增加 5块钱.  用户输入公里数就可以计算打车价格    // 如果有拥堵情况,总价格多收取10块钱拥堵费    // function fn() &#123;&#125;;    // fn();    var car = (function() &#123;        var start = 13; // 起步价  局部变量        var total = 0; // 总价  局部变量        return &#123;            // 正常的总价            price: function(n) &#123;                if (n &lt;= 3) &#123;                    total = start;                &#125; else &#123;                    total = start + (n - 3) * 5                &#125;                return total;            &#125;,            // 拥堵之后的费用            yd: function(flag) &#123;                return flag ? total + 10 : total;            &#125;        &#125;    &#125;)();    console.log(car.price(5)); // 23    console.log(car.yd(true)); // 33    console.log(car.price(1)); // 13    console.log(car.yd(false)); // 13&lt;/script&gt;\n\n闭包总结闭包是什么？\n闭包是一个函数 （一个作用域可以访问另外一个函数的局部变量） \n闭包的作用是什么？\n延伸变量的作用范围\n思考&lt;script&gt;    // 思考题 1：    var name = &quot;The Window&quot;;    var object = &#123;        name: &quot;My Object&quot;,        getNameFunc: function() &#123;            return function() &#123;                return this.name;            &#125;;        &#125;    &#125;;    console.log(object.getNameFunc()())\t\t// The Window    var f = object.getNameFunc();    // 类似于    var f = function() &#123;        return this.name;    &#125;    f();            // 思考题 2：    // var name = &quot;The Window&quot;;　　    // var object = &#123;　　　　    //     name: &quot;My Object&quot;,    //     getNameFunc: function() &#123;    //         var that = this;    //         return function() &#123;    //             return that.name;    //         &#125;;    //     &#125;    // &#125;;    // console.log(object.getNameFunc()())\t// My Object    var f = object.getNameFunc();    var f = function()&#123;        return that.name;    &#125;;    f();&lt;/script&gt;\n\n递归什么是递归？如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。 \n简单理解:函数内部自己调用自己, 这个函数就是递归函数。\n递归函数的作用和循环效果一样。\n由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return。 \n&lt;script&gt;    // 递归函数 : 函数内部自己调用自己, 这个函数就是递归函数    var num = 1;    function fn() &#123;        console.log(&#x27;我要打印6句话&#x27;);        if (num == 6) &#123;            return; // 递归里面必须加退出条件        &#125;        num++;        fn();    &#125;    fn();&lt;/script&gt;\n\n利用递归求数学题求 1 * 2 *3 … * n   阶乘&lt;script&gt;    // 利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 * ..n    function fn(n) &#123;        if (n == 1) &#123;            return 1;        &#125;        return n * fn(n - 1);    &#125;    console.log(fn(3));    console.log(fn(4));    // 详细思路 假如用户输入的是3    //return  3 * fn(2)    //return  3 * (2 * fn(1))    //return  3 * (2 * 1)    //return  3 * (2)    //return  6&lt;/script&gt;\n\n求斐波那契数列&lt;script&gt;    // 利用递归函数求斐波那契数列(兔子序列)  1、1、2、3、5、8、13、21...    // 用户输入一个数字 n 就可以求出 这个数字对应的兔子序列值    // 我们只需要知道用户输入的n 的前面两项(n-1 n-2)就可以计算出n 对应的序列值    function fb(n) &#123;        if (n === 1 || n === 2) &#123;            return 1;        &#125;        return fb(n - 1) + fb(n - 2);    &#125;    console.log(fb(3));    console.log(fb(6));&lt;/script&gt;\n\n根据id返回对应的数据对象var data = [&#123;    id: 1,    name: &#x27;家电&#x27;,    goods: [&#123;        id: 11,        gname: &#x27;冰箱&#x27;,        goods: [&#123;            id: 111,            gname: &#x27;海尔&#x27;        &#125;, &#123;            id: 112,            gname: &#x27;美的&#x27;        &#125;, ]    &#125;, &#123;        id: 12,        gname: &#x27;洗衣机&#x27;    &#125;]&#125;, &#123;    id: 2,    name: &#x27;服饰&#x27;&#125;];// 我们想要做输入id号,就可以返回的数据对象// 1. 利用 forEach 去遍历里面的每一个对象function getID(json, id) &#123;    var o = &#123;&#125;;    json.forEach(function(item) &#123;        // console.log(item); // 2个数组元素        if (item.id == id) &#123;            // console.log(item);            o = item;            // 2. 我们想要得里层的数据 11 12 可以利用递归函数            // 里面应该有goods这个数组并且数组的长度不为 0         &#125; else if (item.goods &amp;&amp; item.goods.length &gt; 0) &#123;            o = getID(item.goods, id);        &#125;    &#125;);    return o;&#125;console.log(getID(data, 1));console.log(getID(data, 2));console.log(getID(data, 11));console.log(getID(data, 12));console.log(getID(data, 111));\n\n浅拷贝和深拷贝\n浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用\n深拷贝拷贝多层，每一级别的数据都会拷贝\nObject.assign(target, …sources); es6 新增方法可以浅拷贝\n\n\n&lt;script&gt;    // 浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用.    // 深拷贝拷贝多层, 每一级别的数据都会拷贝.    var obj = &#123;        id: 1,        name: &#x27;andy&#x27;,        msg: &#123;            age: 18        &#125;    &#125;;    var o = &#123;&#125;;    // for (var k in obj) &#123;    //     // k 是属性名   obj[k] 属性值    //     o[k] = obj[k];    // &#125;    // console.log(o);    // o.msg.age = 20;    // console.log(obj);    console.log(&#x27;--------------&#x27;);    Object.assign(o, obj);    console.log(o);    o.msg.age = 20;    console.log(obj);&lt;/script&gt;\n\n\n&lt;script&gt;    // 深拷贝拷贝多层, 每一级别的数据都会拷贝.    var obj = &#123;        id: 1,        name: &#x27;andy&#x27;,        msg: &#123;            age: 18        &#125;,        color: [&#x27;pink&#x27;, &#x27;red&#x27;]    &#125;;    var o = &#123;&#125;;    // 封装函数     function deepCopy(newobj, oldobj) &#123;        for (var k in oldobj) &#123;            // 判断我们的属性值属于那种数据类型            // 1. 获取属性值  oldobj[k]            var item = oldobj[k];            // 2. 判断这个值是否是数组            if (item instanceof Array) &#123;                newobj[k] = [];                deepCopy(newobj[k], item)            &#125; else if (item instanceof Object) &#123;                // 3. 判断这个值是否是对象                newobj[k] = &#123;&#125;;                deepCopy(newobj[k], item)            &#125; else &#123;                // 4. 属于简单数据类型                newobj[k] = item;            &#125;        &#125;    &#125;    deepCopy(o, obj);    console.log(o);        var arr = [];    console.log(arr instanceof Object);    o.msg.age = 20;    console.log(obj);&lt;/script&gt;\n\n正则表达式正则表达式概述什么是正则表达式正则表达式（ Regular Expression ）是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也 是对象。 \n正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字 母、数字或者下划线， 昵称输入框中可以输入中文(匹配)。此外，正则表达式还常用于过滤掉页面内容中的一 些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。 \n其他语言也会使用正则表达式，本阶段我们主要是利用 JavaScript 正则表达式完成表单验证。 \n正则表达式的特点\n灵活性、逻辑性和功能性非常的强。 \n可以迅速地用极简单的方式达到字符串的复杂控制。 \n对于刚接触的人来说，比较晦涩难懂。比如： ^\\w+([-+.]\\w+)*@\\w+([-.]\\w+).\\w+([-.]\\w+)$ \n实际开发,一般都是直接复制写好的正则表达式. 但是要求会使用正则表达式并且根据实际情况修改正则表达 式.   比如用户名:    /^[a-z0-9_-]{3,16}$/ \n\n正则表达式在 JavaScript 中的使用创建正则表达式在 JavaScript 中，可以通过两种方式创建一个正则表达式。\n1.通过调用 RegExp 对象的构造函数创建\nvar 变量名 = new RegExp(/表达式/); \n\n**2.通过字面量创建 **\nvar 变量名 = /表达式/; \n\n// 注释中间放表达式就是正则字面量 \n测试正则表达式 testtest() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。\nregexObj.test(str) \n\n\nregexObj 是写的正则表达式 \nstr 我们要测试的文本 \n就是检测str文本是否符合我们写的正则表达式规范\n\n&lt;script&gt;    // 正则表达式在js中的使用    // 1. 利用 RegExp对象来创建 正则表达式    var regexp = new RegExp(/123/);    console.log(regexp);    // 2. 利用字面量创建 正则表达式    var rg = /123/;    // 3.test 方法用来检测字符串是否符合正则表达式要求的规范    console.log(rg.test(123));    console.log(rg.test(&#x27;abc&#x27;));&lt;/script&gt;\n\n正则表达式中的特殊字符正则表达式的组成一个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，比如 /ab*c/ 。其中 特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+ 等。\n特殊字符非常多，可以参考： \n\nMDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\njQuery 手册：正则表达式部分\n正则测试工具: http://tool.oschina.net/regex \n\n这里我们把元字符划分几类学习 。\n边界符正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符。\n\n\n\n边界符\n说明\n\n\n\n^\n表示匹配行首的文本（以谁开始）\n\n\n$\n表示匹配行尾的文本（以谁结束）\n\n\n如果 ^ 和 $ 在一起，表示必须是精确匹配。 \n&lt;script&gt;    // 边界符 ^ $     var rg = /abc/; // 正则表达式里面不需要加引号 不管是数字型还是字符串型    // /abc/ 只要包含有abc这个字符串返回的都是true    console.log(rg.test(&#x27;abc&#x27;));    console.log(rg.test(&#x27;abcd&#x27;));    console.log(rg.test(&#x27;aabcd&#x27;));    console.log(&#x27;---------------------------&#x27;);    var reg = /^abc/;    console.log(reg.test(&#x27;abc&#x27;)); // true    console.log(reg.test(&#x27;abcd&#x27;)); // true    console.log(reg.test(&#x27;aabcd&#x27;)); // false    console.log(&#x27;---------------------------&#x27;);    var reg1 = /^abc$/; // 精确匹配 要求必须是 abc字符串才符合规范    console.log(reg1.test(&#x27;abc&#x27;)); // true    console.log(reg1.test(&#x27;abcd&#x27;)); // false    console.log(reg1.test(&#x27;aabcd&#x27;)); // false    console.log(reg1.test(&#x27;abcabc&#x27;)); // false&lt;/script&gt;\n\n字符类字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。 \n1.[]  方括号/[abc]/.test(&#x27;andy&#x27;)     // true \n\n后面的字符串只要包含 abc 中任意一个字符，都返回 true 。 \n2.[-]  方括号内部 范围符-/^[a-z]$/.test(c&#x27;)     // true\n\n方括号内部加上 - 表示范围，这里表示 a 到 z 26个英文字母都可以。 \n3.[^]  方括号内部 取反符^/[^abc]/.test(&#x27;andy&#x27;)     // false\n\n方括号内部加上 ^ 表示取反，只要包含方括号内的字符，都返回 false 。 \n注意和边界符 ^ 区别，边界符写到方括号外面。 \n4.字符组合\n/[a-z1-9]/.test(&#x27;andy&#x27;)     // true\n\n方括号内部可以使用字符组合，这里表示包含 a 到 z 的26个英文字母和 1 到 9 的数字都可以。 \n&lt;script&gt;    //var rg = /abc/;  只要包含abc就可以     // 字符类: [] 表示有一系列字符可供选择，只要匹配其中一个就可以了    var rg = /[abc]/; // 只要包含有a 或者 包含有b 或者包含有c 都返回为true    console.log(rg.test(&#x27;andy&#x27;));    console.log(rg.test(&#x27;baby&#x27;));    console.log(rg.test(&#x27;color&#x27;));    console.log(rg.test(&#x27;red&#x27;));    var rg1 = /^[abc]$/; // 三选一 只有是a 或者是 b  或者是c 这三个字母才返回 true    console.log(rg1.test(&#x27;aa&#x27;));    console.log(rg1.test(&#x27;a&#x27;));    console.log(rg1.test(&#x27;b&#x27;));    console.log(rg1.test(&#x27;c&#x27;));    console.log(rg1.test(&#x27;abc&#x27;));    console.log(&#x27;------------------&#x27;);    var reg = /^[a-z]$/; // 26个英文字母任何一个字母返回 true  - 表示的是a 到z 的范围      console.log(reg.test(&#x27;a&#x27;));    console.log(reg.test(&#x27;z&#x27;));    console.log(reg.test(1));    console.log(reg.test(&#x27;A&#x27;));    // 字符组合    var reg1 = /^[a-zA-Z0-9_-]$/; // 26个英文字母(大写和小写都可以)任何一个字母返回 true      console.log(reg1.test(&#x27;a&#x27;));    console.log(reg1.test(&#x27;B&#x27;));    console.log(reg1.test(8));    console.log(reg1.test(&#x27;-&#x27;));    console.log(reg1.test(&#x27;_&#x27;));    console.log(reg1.test(&#x27;!&#x27;));    console.log(&#x27;----------------&#x27;);    // 如果中括号里面有^ 表示取反的意思 千万和 我们边界符 ^ 别混淆    var reg2 = /^[^a-zA-Z0-9_-]$/;    console.log(reg2.test(&#x27;a&#x27;));    console.log(reg2.test(&#x27;B&#x27;));    console.log(reg2.test(8));    console.log(reg2.test(&#x27;-&#x27;));    console.log(reg2.test(&#x27;_&#x27;));    console.log(reg2.test(&#x27;!&#x27;));&lt;/script&gt;\n\n量词符量词符用来设定某个模式出现的次数。\n\n\n\n量词\n说明\n\n\n\n*\n重复零次或者更多次\n\n\n+\n重复一次或者更多次\n\n\n？\n重复零次或者一次\n\n\n{n}\n重复 n 次\n\n\n{n,}\n重复 n 次或者更多次\n\n\n{n,m}\n重复  n 到 m 次\n\n\n&lt;script&gt;    // 量词符: 用来设定某个模式出现的次数    // var reg = /^a$/;    // console.log(reg.test(&#x27;a&#x27;));    // console.log(reg.test(&#x27;aa&#x27;));    // 1. * 相当于 &gt;= 0 可以出现0次或者很多次     // var reg = /^a*$/;    // console.log(reg.test(&#x27;&#x27;));    // console.log(reg.test(&#x27;a&#x27;));    // console.log(reg.test(&#x27;aa&#x27;));    // console.log(reg.test(&#x27;aaaaaa&#x27;));    // 2. + 相当于 &gt;= 1 可以出现1次或者很多次    // var reg = /^a+$/;    // console.log(reg.test(&#x27;&#x27;));    // console.log(reg.test(&#x27;a&#x27;));    // console.log(reg.test(&#x27;aa&#x27;));    // console.log(reg.test(&#x27;aaaaaa&#x27;));    // 3. ?  相当于 1 || 0    // var reg = /^a?$/;    // console.log(reg.test(&#x27;&#x27;));    // console.log(reg.test(&#x27;a&#x27;));    // console.log(reg.test(&#x27;aa&#x27;));    // console.log(reg.test(&#x27;aaaaaa&#x27;));    // 4. &#123;3 &#125; 就是重复3次    // var reg = /^a&#123;3&#125;$/;    // console.log(reg.test(&#x27;&#x27;));    // console.log(reg.test(&#x27;a&#x27;));    // console.log(reg.test(&#x27;aa&#x27;));    // console.log(reg.test(&#x27;aaaaaa&#x27;));    // console.log(reg.test(&#x27;aaa&#x27;));    // 5. &#123;3, &#125;  大于等于3    var reg = /^a&#123;3,&#125;$/;    console.log(reg.test(&#x27;&#x27;));    console.log(reg.test(&#x27;a&#x27;));    console.log(reg.test(&#x27;aa&#x27;));    console.log(reg.test(&#x27;aaaaaa&#x27;));    console.log(reg.test(&#x27;aaa&#x27;));    // 6. &#123;3, 16&#125;  大于等于3 并且 小于等于16    var reg = /^a&#123;3,16&#125;$/;    console.log(reg.test(&#x27;&#x27;));    console.log(reg.test(&#x27;a&#x27;));    console.log(reg.test(&#x27;aa&#x27;));    console.log(reg.test(&#x27;aaaaaa&#x27;));    console.log(reg.test(&#x27;aaa&#x27;));    console.log(reg.test(&#x27;aaaaaaaaaaaaaaaaaaaaa&#x27;));&lt;/script&gt;\n\n案例：用户名验证功能需求:\n\n如果用户名输入合法, 则后面提示信息为 :  用户名合法,并且颜色为绿色 \n如果用户名输入不合法, 则后面提示信息为:  用户名不符合规范, 并且颜色为绿色\n\n分析: \n\n用户名只能为英文字母,数字,下划线或者短横线组成, 并且用户名长度为 6~16位\n首先准备好这种正则表达式模式 /$[a-zA-Z0-9-_]{6,16}^/\n当表单失去焦点就开始验证\n如果符合正则规范, 则让后面的span标签添加 right 类\n如果不符合正则规范, 则让后面的span标签添加 wrong 类\n\n    &lt;style&gt;        span &#123;            color: #aaa;            font-size: 14px;        &#125;        .right &#123;            color: green;        &#125;        .wrong &#123;            color: red;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;input type=&quot;text&quot; class=&quot;uname&quot;&gt; &lt;span&gt;请输入用户名&lt;/span&gt;    &lt;script&gt;        //  量词是设定某个模式出现的次数        var reg = /^[a-zA-Z0-9_-]&#123;6,16&#125;$/; // 这个模式用户只能输入英文字母 数字 下划线 短横线但是有边界符和[] 这就限定了只能多选1        // &#123;6,16&#125;  中间不要有空格        // console.log(reg.test(&#x27;a&#x27;));        // console.log(reg.test(&#x27;8&#x27;));        // console.log(reg.test(&#x27;18&#x27;));        // console.log(reg.test(&#x27;aa&#x27;));        // console.log(&#x27;-------------&#x27;);        // console.log(reg.test(&#x27;andy-red&#x27;));        // console.log(reg.test(&#x27;andy_red&#x27;));        // console.log(reg.test(&#x27;andy007&#x27;));        // console.log(reg.test(&#x27;andy!007&#x27;));        var uname = document.querySelector(&#x27;.uname&#x27;);        var span = document.querySelector(&#x27;span&#x27;);        uname.onblur = function() &#123;            if (reg.test(this.value)) &#123;                console.log(&#x27;正确的&#x27;);                span.className = &#x27;right&#x27;;                span.innerHTML = &#x27;用户名格式输入正确&#x27;;            &#125; else &#123;                console.log(&#x27;错误的&#x27;);                span.className = &#x27;wrong&#x27;;                span.innerHTML = &#x27;用户名格式输入不正确&#x27;;            &#125;        &#125;    &lt;/script&gt;&lt;/body&gt;\n\n括号总结\n大括号  量词符.   里面表示重复次数\n中括号 字符集合。匹配方括号中的任意字符\n小括号 表示优先级\n\n可以在线测试: https://c.runoob.com/ \n&lt;script&gt;    // 中括号 字符集合.匹配方括号中的任意字符.     // var reg = /^[abc]$/;    // a 也可以 b 也可以 c 可以  a ||b || c    // 大括号  量词符. 里面表示重复次数    // var reg = /^abc&#123;3&#125;$/; // 它只是让c重复三次   abccc    // console.log(reg.test(&#x27;abc&#x27;));    // console.log(reg.test(&#x27;abcabcabc&#x27;));    // console.log(reg.test(&#x27;abccc&#x27;));    // 小括号 表示优先级    var reg = /^(abc)&#123;3&#125;$/; // 它是让abcc重复三次    console.log(reg.test(&#x27;abc&#x27;));    console.log(reg.test(&#x27;abcabcabc&#x27;));    console.log(reg.test(&#x27;abccc&#x27;));&lt;/script&gt;\n\n预定义类预定义类指的是某些常见模式的简写方式。\n\n\n\n预定义类\n说明\n\n\n\n\\d\n匹配 0-9 之间的任一数字，相当于[0-9]\n\n\n\\D\n匹配所有 0-9 以外的字符，相当于 [ ^0-9]\n\n\n\\w\n匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]\n\n\n\\W\n除所有的字母、数字和下划线以外的字符，相当于[ ^A-Za-z0-9_]\n\n\n\\s\n匹配空格（包括换行符、制表符、空格符等），相当于[\\t\\r\\n\\v\\f]\n\n\n\\S\n匹配非空格的字符，相当于[ ^\\t\\r\\n\\v\\f]\n\n\n&lt;script&gt;    // 座机号码验证:  全国座机号码  两种格式:   010-12345678  或者  0530-1234567    // 正则里面的或者 符号  |      // var reg = /^\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;$/;    var reg = /^\\d&#123;3,4&#125;-\\d&#123;7,8&#125;$/;&lt;/script&gt;\n\n案例：表单验证分析: \n\n手机号码:     /^1[3|4|5|7|8][0-9]{9}$/ \nQQ: [1-9][0-9]{4,} (腾讯QQ号从10000开始) \n昵称是中文:     ^[\\u4e00-\\u9fa5]{2,8}$ \n\nwindow.onload = function() &#123;    var regtel = /^1[3|4|5|7|8]\\d&#123;9&#125;$/; // 手机号码的正则表达式    var regqq = /^[1-9]\\d&#123;4,&#125;$/; // 10000    var regnc = /^[\\u4e00-\\u9fa5]&#123;2,8&#125;$/;    var regmsg = /^\\d&#123;6&#125;$/;    var regpwd = /^[a-zA-Z0-9_-]&#123;6,16&#125;$/;    var tel = document.querySelector(&#x27;#tel&#x27;);    var qq = document.querySelector(&#x27;#qq&#x27;);    var nc = document.querySelector(&#x27;#nc&#x27;);    var msg = document.querySelector(&#x27;#msg&#x27;);    var pwd = document.querySelector(&#x27;#pwd&#x27;);    var surepwd = document.querySelector(&#x27;#surepwd&#x27;);    regexp(tel, regtel); // 手机号码    regexp(qq, regqq); // qq号码    regexp(nc, regnc); // 昵称    regexp(msg, regmsg); // 短信验证    regexp(pwd, regpwd); // 密码框    // 表单验证的函数    function regexp(ele, reg) &#123;        ele.onblur = function() &#123;            if (reg.test(this.value)) &#123;                // console.log(&#x27;正确的&#x27;);                this.nextElementSibling.className = &#x27;success&#x27;;                this.nextElementSibling.innerHTML = &#x27;&lt;i class=&quot;success_icon&quot;&gt;&lt;/i&gt; 恭喜您输入正确&#x27;;            &#125; else &#123;                // console.log(&#x27;不正确&#x27;);                this.nextElementSibling.className = &#x27;error&#x27;;                this.nextElementSibling.innerHTML = &#x27;&lt;i class=&quot;error_icon&quot;&gt;&lt;/i&gt; 格式不正确，请从新输入 &#x27;;            &#125;        &#125;    &#125;;    surepwd.onblur = function() &#123;        if (this.value == pwd.value) &#123;            this.nextElementSibling.className = &#x27;success&#x27;;            this.nextElementSibling.innerHTML = &#x27;&lt;i class=&quot;success_icon&quot;&gt;&lt;/i&gt; 恭喜您输入正确&#x27;;        &#125; else &#123;            this.nextElementSibling.className = &#x27;error&#x27;;            this.nextElementSibling.innerHTML = &#x27;&lt;i class=&quot;error_icon&quot;&gt;&lt;/i&gt; 两次密码输入不一致&#x27;;        &#125;    &#125;&#125;\n\n正则表达式中的替换replace 替换replace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。\nstringObject.replace(regexp/substr,replacement) \n\n\n第一个参数:   被替换的字符串 或者  正则表达式 \n第二个参数:   替换为的字符串 \n返回值是一个替换完毕的新字符串 \n\n正则表达式参数/表达式/[switch] \n\nswitch(也称为修饰符) 按照什么样的模式来匹配. 有三种值： \n\ng：全局匹配\ni：忽略大小写 \ngi：全局匹配 + 忽略大小写\n\n案例：敏感词过滤    &lt;style&gt;        textarea &#123;            width: 300px;            height: 100px;            border: 1px solid #ccc;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;textarea name=&quot;&quot; id=&quot;message&quot;&gt;&lt;/textarea&gt; &lt;button&gt;提交&lt;/button&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        // 替换 replace        // var str = &#x27;andy和red&#x27;;        // // var newStr = str.replace(&#x27;andy&#x27;, &#x27;baby&#x27;);        // var newStr = str.replace(/andy/, &#x27;baby&#x27;);        // console.log(newStr);        var text = document.querySelector(&#x27;textarea&#x27;);        var btn = document.querySelector(&#x27;button&#x27;);        var div = document.querySelector(&#x27;div&#x27;);        btn.onclick = function() &#123;            div.innerHTML = text.value.replace(/激情|gay/g, &#x27;**&#x27;);        &#125;    &lt;/script&gt;&lt;/body&gt;\n\nES6ES6 简介什么是 ES6 ?ES 的全称是 ECMAScript , 它是由 ECMA 国际标准化组织,制定的一项脚本语言的标准化规范。\n\nES6 实际上是一个泛指，泛指  ES2015 及后续的版本。 \n为什么使用 ES6 ?每一次标准的诞生都意味着语言的完善，功能的加强。JavaScript语言本身也有一些令人不满意的地方。 \n\n变量提升特性增加了程序运行时的不可预测性\n语法过于松散，实现相同的功能，不同的人可能会写出不同的代码\n\nES6 的新增语法letES6中新增的用于声明变量的关键字。\n1.let声明的变量只在所处于的块级有效。\nif (true) &#123;      let a = 10; &#125;  console.log(a) // a is not defined \n\n注意：使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。\n2.不存在变量提升\nconsole.log(a); // a is not defined   let a = 20; \n\n3.暂时性死区\nvar tmp = 123; if (true) &#123;      tmp = &#x27;abc&#x27;;     let tmp;  &#125; \n\n/*\tlet关键字就是用来声明变量的\t使用let关键字声明的变量具有块级作用域\t在一个大括号中 使用let关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的\t防止循环变量变成全局变量\t使用let关键字声明的变量没有变量提升\t使用let关键字声明的变量具有暂时性死区特性*//* --------let关键字就是用来声明变量的-------- */// let a = 10;// console.log(a);/* --------使用let关键字声明的变量具有块级作用域-------- */// if (true) &#123;// \tlet b = 20;// \tconsole.log(b)// \tif (true) &#123;// \t\tlet c = 30;// \t&#125;// \tconsole.log(c);// &#125;// console.log(b)/* -------在一个大括号中 使用let关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的--------- */// if (true) &#123;// \tlet num = 100;// \tvar abc = 200;// &#125;// console.log(abc);// console.log(num)/* -------防止循环变量变成全局变量--------- */// for (let i = 0; i &lt; 2; i++) &#123;&#125;// console.log(i);/*-----使用let关键字声明的变量没有变量提升------*/// console.log(a);// let a = 100;/* -------使用let关键字声明的变量具有暂时性死区特性------- */var num = 10if (true) &#123;\tconsole.log(num);\tlet num = 20;&#125;\n\nlet 经典面试题\n经典面试题图解：此题的关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值。 \n\n经典面试题图解：此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的， 函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值。\nlet arr = [];for (let i = 0; i &lt; 2; i++) &#123;\tarr[i] = function () &#123;\t\tconsole.log(i);\t&#125;&#125;arr[0]();arr[1]();\n\nconst作用：声明常量，常量就是值（内存地址）不能变化的量。\n1.具有块级作用域\n if (true) &#123;       const a = 10;  &#125;  console.log(a) // a is not defined \n\n2.声明常量时必须赋值 \nconst PI; // Missing initializer in const declaration \n\n3.常量赋值后，值不能修改。 \nconst PI = 3.14; PI = 100; // Assignment to constant variable. \n\nconst ary = [100, 200]; ary[0] = &#x27;a&#x27;; ary[1] = &#x27;b&#x27;; console.log(ary); // [&#x27;a&#x27;, &#x27;b&#x27;];  ary = [&#x27;a&#x27;, &#x27;b&#x27;]; // Assignment to constant variable. \n\n// 使用const关键字声明的常量具有块级作用域// if (true) &#123;// \tconst a = 10;// \tif (true) &#123;// \t\tconst a = 20;// \t\tconsole.log(a);// \t&#125;// \tconsole.log(a);// &#125;// console.log(a);// 使用const关键字声明的常量必须赋初始值// const PI = 3.14;// 常量声明后值不可更改 const PI = 3.14;// PI = 100;const ary = [100, 200];ary[0] = 123;ary = [1, 2]console.log(ary);\n\nlet、const、var 的区别\n使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象。 \n使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升。 \n使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值。 \n\n\n\n\nvar\nlet\nconst\n\n\n\n函数级作用域\n块级作用域\n块级作用域\n\n\n变量提升\n不存在变量提升\n不存在变量提升\n\n\n值可更改\n值可更改\n值不可更改\n\n\n解构赋值ES6中允许从数组中提取值，按照对应位置，对变量赋值。对象也可以实现解构。 \n数组解构let [a, b, c] = [1, 2, 3]; console.log(a) console.log(b)  console.log(c)\n\n如果解构不成功，变量的值为undefined。\nlet [foo] = [];  let [bar, foo] = [1]; \n\n// 数组解构允许我们按照一一对应的关系从数组中提取值 然后将值赋值给变量let ary = [1,2,3];let [a, b, c, d, e] = ary;console.log(a)console.log(b)console.log(c)console.log(d)console.log(e)\n\n对象解构按照一定模式，从数组中或对象中提取值，将提取出来的值赋值给另外的变量。 \nlet person = &#123; name: &#x27;zhangsan&#x27;, age: 20 &#125;;  let &#123; name, age &#125; = person; console.log(name); // &#x27;zhangsan&#x27;   console.log(age); // 20\n\nlet &#123;name: myName, age: myAge&#125; = person; // myName myAge 属于别名 console.log(myName); // &#x27;zhangsan&#x27;  console.log(myAge); // 20 \n\n// 对象解构允许我们使用变量的名字匹配对象的属性 匹配成功 将对象属性的值赋值给变量let person = &#123;name: &#x27;lisi&#x27;, age: 30, sex: &#x27;男&#x27;&#125;;// let &#123; name, age, sex &#125; = person;// console.log(name)// console.log(age)// console.log(sex)let &#123;name: myName&#125; = person;console.log(myName)\n\n箭头函数ES6中新增的定义函数的方式。\n() =&gt; &#123;&#125;  const fn = () =&gt; &#123;&#125; \n\n函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号。\nfunction sum(num1, num2) &#123;      return num1 + num2;  &#125;  const sum = (num1, num2) =&gt; num1 + num2; \n\n如果形参只有一个，可以省略小括号。\nfunction fn (v) &#123;     return v; &#125;   const fn = v =&gt; v; \n\n箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this。\nconst obj = &#123; name: &#x27;张三&#x27;&#125;  function fn () &#123;      console.log(this);     return () =&gt; &#123;          console.log(this)     &#125;  &#125;  const resFn = fn.call(obj);  resFn(); \n\n// 箭头函数是用来简化函数定义语法的// const fn = () =&gt; &#123;// \tconsole.log(123)// &#125;// fn();// 在箭头函数中 如果函数体中只有一句代码 并且代码的执行结果就是函数的返回值 函数体大括号可以省略// const sum = (n1, n2) =&gt; n1 + n2;\t // const result = sum(10, 20);// console.log(result)// 在箭头函数中 如果形参只有一个 形参外侧的小括号也是可以省略的// const fn = v =&gt; &#123;// \talert(v);// &#125;// fn(20)\t// 箭头函数不绑定this 箭头函数没有自己的this关键字 如果在箭头函数中使用this this关键字将指向箭头函数定义位置中的thisfunction fn () &#123;\tconsole.log(this);\treturn () =&gt; &#123;\t\tconsole.log(this)\t&#125;&#125;const obj = &#123;name: &#x27;zhangsan&#x27;&#125;;const resFn = fn.call(obj);resFn();\n\n面试题\nvar age = 100;var obj = &#123;\tage: 20,\tsay: () =&gt; &#123;\t\talert(this.age)\t&#125;&#125;obj.say();\t\t// 100\n\n剩余参数剩余参数语法允许我们将一个不定数量的参数表示为一个数组。 \nfunction sum (first, ...args) &#123;     console.log(first); // 10     console.log(args); // [20, 30]  &#125; sum(10, 20, 30) \n\n剩余参数和解构配合使用。\nlet students = [&#x27;wangwu&#x27;, &#x27;zhangsan&#x27;, &#x27;lisi&#x27;]; let [s1, ...s2] = students;  console.log(s1);  // &#x27;wangwu&#x27;   console.log(s2);  // [&#x27;zhangsan&#x27;, &#x27;lisi&#x27;]\n\n// const sum = (...args) =&gt; &#123;// \tlet total = 0;// \targs.forEach(item =&gt; total += item);// \treturn total;// &#125;;// console.log(sum(10, 20));// console.log(sum(10, 20, 30));let ary1 = [&#x27;张三&#x27; , &#x27;李四&#x27;, &#x27;王五&#x27;];let [s1, ...s2] = ary1;console.log(s1)console.log(s2)\n\nES6 的内置对象扩展Array 的扩展方法扩展运算符（展开语法）扩展运算符可以将数组或者对象转为用逗号分隔的参数序列。\nlet ary = [1, 2, 3]; ...ary  // 1, 2, 3 console.log(...ary);    // 1 2 3  console.log(1, 2, 3) \n\n扩展运算符可以应用于合并数组。 \n// 方法一   let ary1 = [1, 2, 3];  let ary2 = [3, 4, 5];  let ary3 = [...ary1, ...ary2];  // 方法二   ary1.push(...ary2); \n\n将类数组或可遍历对象转换为真正的数组。\nlet oDivs = document.getElementsByTagName(&#x27;div&#x27;);  oDivs = [...oDivs]; \n\n// 扩展运算符可以将数组拆分成以逗号分隔的参数序列// let ary = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];// ...ary // &quot;a&quot;, &quot;b&quot;, &quot;c&quot;// console.log(...ary)// console.log(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)// 扩展运算符应用于数组合并// let ary1 = [1, 2, 3];// let ary2 = [4, 5, 6];// // ...ary1 // 1, 2, 3// // ...ary1 // 4, 5, 6// let ary3 = [...ary1, ...ary2];// console.log(ary3)// 合并数组的第二种方法// let ary1 = [1, 2, 3];// let ary2 = [4, 5, 6];// ary1.push(...ary2);// console.log(ary1)// 利用扩展运算符将伪数组转换为真正的数组var oDivs = document.getElementsByTagName(&#x27;div&#x27;);console.log(oDivs)var ary = [...oDivs];ary.push(&#x27;a&#x27;);console.log(ary);\n\n构造函数方法：Array.from()将类数组或可遍历对象转换为真正的数组。\nlet arrayLike = &#123;     &#x27;0&#x27;: &#x27;a&#x27;,     &#x27;1&#x27;: &#x27;b&#x27;,     &#x27;2&#x27;: &#x27;c&#x27;,     length: 3 &#125;;  let arr2 = Array.from(arrayLike); // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] \n\n方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。\nlet arrayLike = &#123;      &quot;0&quot;: 1,     &quot;1&quot;: 2,     &quot;length&quot;: 2 &#125;  let newAry = Array.from(aryLike, item =&gt; item *2) \n\n&lt;script type=&quot;text/javascript&quot;&gt;\t// var arrayLike = &#123;\t// \t&quot;0&quot;: &quot;张三&quot;,\t// \t&quot;1&quot;: &quot;李四&quot;,\t// \t&quot;2&quot;: &quot;王五&quot;,\t// \t&quot;length&quot;: 3\t// &#125;\t// var ary = Array.from(arrayLike);\t// console.log(ary)\tvar arrayLike = &#123;\t\t&quot;0&quot;: &quot;1&quot;,\t\t&quot;1&quot;: &quot;2&quot;,\t\t&quot;length&quot;: 2\t&#125;\tvar ary = Array.from(arrayLike, item =&gt; item * 2)\tconsole.log(ary)&lt;/script&gt;\n\n实例方法：find()用于找出第一个符合条件的数组成员，如果没有找到返回undefined。\n let ary = [&#123;      id: 1,           name: &#x27;张三‘  &#125;, &#123;       id: 2,           name: &#x27;李四‘  &#125;];   let target = ary.find((item, index) =&gt; item.id == 2); \n\n&lt;script type=&quot;text/javascript&quot;&gt;\tvar ary = [&#123;\t\tid: 1,\t\tname: &#x27;张三&#x27;\t&#125;, &#123;\t\tid: 2,\t\tname: &#x27;李四&#x27;\t&#125;];\tlet target = ary.find(item =&gt; item.id == 3);\tconsole.log(target)&lt;/script&gt;\n\n实例方法：findIndex()用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1。\nlet ary = [1, 5, 10, 15]; let index = ary.findIndex((value, index) =&gt; value &gt; 9);  console.log(index); // 2 \n\n&lt;script type=&quot;text/javascript&quot;&gt;\tlet ary = [10, 20, 50];\tlet index = ary.findIndex(item =&gt; item &gt; 15);\tconsole.log(index)&lt;/script&gt;\n\n实例方法：includes()表示某个数组是否包含给定的值，返回布尔值。\n[1, 2, 3].includes(2) // true  [1, 2, 3].includes(4) // false \n\n&lt;script type=&quot;text/javascript&quot;&gt;\tlet ary = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\tlet result = ary.includes(&#x27;a&#x27;)\tconsole.log(result)\tresult = ary.includes(&#x27;e&#x27;)\tconsole.log(result)&lt;/script&gt;\n\nString 的扩展方法模板字符串ES6新增的创建字符串的方式，使用反引号定义。\nlet name = `zhangsan`; \n\n模板字符串中可以解析变量。 \nlet name = &#x27;张三&#x27;;   let sayHello = `hello,my name is $&#123;name&#125;`; // hello, my name is zhangsan \n\n模板字符串中可以换行。\nlet result = &#123;      name: &#x27;zhangsan&#x27;,      age: 20,       sex: &#x27;男&#x27;  &#125;  let html = ` &lt;div&gt;     &lt;span&gt;$&#123;result.name&#125;&lt;/span&gt;     &lt;span&gt;$&#123;result.age&#125;&lt;/span&gt;     &lt;span&gt;$&#123;result.sex&#125;&lt;/span&gt; &lt;/div&gt; `; \n\n在模板字符串中可以调用函数。\nconst sayHello = function () &#123;           return &#x27;哈哈哈哈 追不到我吧 我就是这么强大&#x27;;  &#125;;   let greet = `$&#123;sayHello()&#125; 哈哈哈哈`;   console.log(greet); // 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈 \n\n&lt;script type=&quot;text/javascript&quot;&gt;\t// let name = `张三`;\t// let sayHello = `Hello, 我的名字叫$&#123;name&#125;`;\t// console.log(sayHello);\t\t// let result = &#123;\t// \tname: &quot;zhangsan&quot;,\t// \tage: 20\t// &#125;;\t// let html = `\t// \t&lt;div&gt;\t// \t\t&lt;span&gt;$&#123;result.name&#125;&lt;/span&gt;\t// \t\t&lt;span&gt;$&#123;result.age&#125;&lt;/span&gt;\t// \t&lt;/div&gt;\t// `;\t// console.log(html);\tconst fn = () =&gt; &#123;\t\treturn &#x27;我是fn函数&#x27;\t&#125;\tlet html = `我是模板字符串 $&#123;fn()&#125;`;\tconsole.log(html)&lt;/script&gt;\n\n实例方法：startsWith() 和 endsWith()\nstartsWith()：表示参数字符串是否在原字符串的头部，返回布尔值\nendsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值\n\nlet str = &#x27;Hello world!&#x27;; str.startsWith(&#x27;Hello&#x27;) // true  str.endsWith(&#x27;!&#x27;)       // true \n\n&lt;script type=&quot;text/javascript&quot;&gt;\tlet str = &#x27;Hello ECMAScript 2015&#x27;;\tlet r1 = str.startsWith(&#x27;Hello&#x27;);\tconsole.log(r1);\tlet r2 = str.endsWith(&#x27;2016&#x27;);\tconsole.log(r2)&lt;/script&gt;\n\n实例方法：repeat()repeat方法表示将原字符串重复n次，返回一个新字符串。\n&#x27;x&#x27;.repeat(3)      // &quot;xxx&quot;  &#x27;hello&#x27;.repeat(2)  // &quot;hellohello&quot; \n\n&lt;script type=&quot;text/javascript&quot;&gt;\tconsole.log(&quot;y&quot;.repeat(5))&lt;/script&gt;\n\nSet 数据结构ES6 提供了新的数据结构  Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 \nSet本身是一个构造函数，用来生成  Set  数据结构。\nconst s = new Set(); \n\nSet函数可以接受一个数组作为参数，用来初始化。 \nconst set = new Set([1, 2, 3, 4, 4]); \n\n实例方法\nadd(value)：添加某个值，返回 Set 结构本身\ndelete(value)：删除某个值，返回一个布尔值，表示删除是否成功\nhas(value)：返回一个布尔值，表示该值是否为 Set 的成员\nclear()：清除所有成员，没有返回值\n\nconst s = new Set();  s.add(1).add(2).add(3); // 向 set 结构中添加值   s.delete(2)             // 删除 set 结构中的2值   s.has(1)                // 表示 set 结构中是否有1这个值 返回布尔值  s.clear()               // 清除 set 结构中的所有值 \n\n遍历Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。\ns.forEach(value =&gt; console.log(value)) \n\n&lt;script type=&quot;text/javascript&quot;&gt;\t// const s1 = new Set();\t// console.log(s1.size)\t// const s2 = new Set([&quot;a&quot;, &quot;b&quot;]);\t// console.log(s2.size)\t// const s3 = new Set([&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;]);\t// console.log(s3.size)\t// const ary = [...s3];\t// console.log(ary)\t// const s4 = new Set();\t// 向set结构中添加值 使用add方法\t// s4.add(&#x27;a&#x27;).add(&#x27;b&#x27;);\t// console.log(s4.size)\t// 从set结构中删除值 用到的方法是delete\t// const r1 = s4.delete(&#x27;c&#x27;);\t// console.log(s4.size)\t// console.log(r1);\t// 判断某一个值是否是set数据结构中的成员 使用has\t// const r2 = s4.has(&#x27;d&#x27;);\t// console.log(r2)\t// 清空set数据结构中的值 使用clear方法\t// s4.clear();\t// console.log(s4.size);\t\t// 遍历set数据结构 从中取值\tconst s5 = new Set([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);\ts5.forEach(value =&gt; &#123;\t\tconsole.log(value)\t&#125;)&lt;/script&gt;\n\n","categories":["黑马前端"],"tags":["JS"]},{"title":"黑马前端-Vue基础","url":"/2021/11/04/%E9%BB%91%E9%A9%AC%E5%89%8D%E7%AB%AF-Vue%E5%9F%BA%E7%A1%80/","content":"day01Vue 是什么？\nVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架\nvue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合\n\n使用Vue将helloworld  渲染到页面上\n\n指令\n本质就是自定义属性\nVue中指定都是以 v- 开头 \n\nv-cloak\n防止页面加载时出现闪烁问题\n &lt;style type=&quot;text/css&quot;&gt;  /*     1、通过属性选择器 选择到 带有属性 v-cloak的标签  让他隐藏 */  [v-cloak]&#123;    /* 元素隐藏    */    display: none;  &#125;  &lt;/style&gt;&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;!-- 2、 让带有插值 语法的   添加 v-cloak 属性          在 数据渲染完场之后，v-cloak 属性会被自动去除，         v-cloak一旦移除也就是没有这个属性了  属性选择器就选择不到该标签\t\t 也就是对应的标签会变为可见    --&gt;    &lt;div  v-cloak  &gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;  &lt;/div&gt;  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    var vm = new Vue(&#123;      //  el   指定元素 id 是 app 的元素        el: &#x27;#app&#x27;,      //  data  里面存储的是数据      data: &#123;        msg: &#x27;Hello Vue&#x27;      &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nv-text\nv-text指令用于将数据填充到标签中，作用于插值表达式类似，但是没有闪动问题\n如果数据中有HTML标签会将html标签一并输出\n注意：此处为单向绑定，数据对象上的值改变，插值会发生变化；但是当插值发生变化并不会影响数据对象的值\n\n&lt;div id=&quot;app&quot;&gt;    &lt;!--  \t\t注意:在指令中不要写插值语法  直接写对应的变量名称         在 v-text 中 赋值的时候不要在写 插值语法\t\t一般属性中不加 &#123;&#123;&#125;&#125;  直接写 对应 的数据名 \t--&gt;    &lt;p v-text=&quot;msg&quot;&gt;&lt;/p&gt;    &lt;p&gt;        &lt;!-- Vue  中只有在标签的 内容中 才用插值语法 --&gt;        &#123;&#123;msg&#125;&#125;    &lt;/p&gt;&lt;/div&gt;&lt;script&gt;    new Vue(&#123;        el: &#x27;#app&#x27;,        data: &#123;            msg: &#x27;Hello Vue.js&#x27;        &#125;    &#125;);&lt;/script&gt;\n\nv-html\n用法和v-text 相似  但是他可以将HTML片段填充到标签中\n\n可能有安全问题, 一般只在可信任内容上使用 v-html，永不用在用户提交的内容上\n\n它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。\n&lt;div id=&quot;app&quot;&gt;　　&lt;p v-html=&quot;html&quot;&gt;&lt;/p&gt; &lt;!-- 输出：html标签在渲染的时候被解析 --&gt;        &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;!-- 输出：&lt;span&gt;通过双括号绑定&lt;/span&gt; --&gt;    　　&lt;p v-text=&quot;text&quot;&gt;&lt;/p&gt; &lt;!-- 输出：&lt;span&gt;html标签在渲染的时候被源码输出&lt;/span&gt; --&gt;&lt;/div&gt;&lt;script&gt;　　let app = new Vue(&#123;　　el: &quot;#app&quot;,　　data: &#123;　　　　message: &quot;&lt;span&gt;通过双括号绑定&lt;/span&gt;&quot;,　　　　html: &quot;&lt;span&gt;html标签在渲染的时候被解析&lt;/span&gt;&quot;,　　　　text: &quot;&lt;span&gt;html标签在渲染的时候被源码输出&lt;/span&gt;&quot;,　　&#125; &#125;);&lt;/script&gt;\n\nv-pre\n显示原始信息跳过编译过程\n跳过这个元素和它的子元素的编译过程。\n一些静态的内容不需要编译加这个指令可以加快渲染\n\n    &lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;/span&gt;    \t&lt;!--  显示的是&#123;&#123; this will not be compiled &#125;&#125;  --&gt;\t&lt;span v-pre&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;       &lt;!--   即使data里面定义了msg这里仍然是显示的&#123;&#123;msg&#125;&#125;  --&gt;&lt;script&gt;    new Vue(&#123;        el: &#x27;#app&#x27;,        data: &#123;            msg: &#x27;Hello Vue.js&#x27;        &#125;    &#125;);&lt;/script&gt;\n\nv-once\n执行一次性的插值【当数据改变时，插值处的内容不会继续更新】\n\n  &lt;!-- 即使data里面定义了msg 后期我们修改了 仍然显示的是第一次data里面存储的数据即 Hello Vue.js  --&gt;     &lt;span v-once&gt;&#123;&#123; msg&#125;&#125;&lt;/span&gt;    &lt;script&gt;    new Vue(&#123;        el: &#x27;#app&#x27;,        data: &#123;            msg: &#x27;Hello Vue.js&#x27;        &#125;    &#125;);&lt;/script&gt;\n\n\n\n双向数据绑定\n当数据发生变化的时候，视图也就发生变化\n当视图发生变化的时候，数据也会跟着同步变化\n\nv-model\nv-model是一个指令，限制在 &lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;、components中使用\n\n&lt;div id=&quot;app&quot;&gt;     &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;     &lt;div&gt;         当输入框中内容改变的时候，  页面上的msg  会自动更新       &lt;input type=&quot;text&quot; v-model=&#x27;msg&#x27;&gt;     &lt;/div&gt; &lt;/div&gt;\n\nmvvm\nMVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel\nm   model  \n数据层   Vue  中 数据层 都放在 data 里面\n\n\nv   view     视图   \nVue  中  view      即 我们的HTML页面  \n\n\nvm   （view-model）     控制器     将数据和视图层建立联系      \nvm 即  Vue 的实例  就是 vm  \n\n\n\nv-on\n用来绑定事件的\n形式如：v-on:click  缩写为 @click;\n\n\n\nv-on事件函数中传入参数&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;div&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt;        &lt;div&gt;            &lt;!-- 如果事件直接绑定函数名称，那么默认会传递事件对象作为事件函数的第一个参数 --&gt;            &lt;button v-on:click=&#x27;handle1&#x27;&gt;点击1&lt;/button&gt;            &lt;!-- 2、如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递，                 并且事件对象的名称必须是$event             --&gt;            &lt;button v-on:click=&#x27;handle2(123, 456, $event)&#x27;&gt;点击2&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                num: 0            &#125;,            methods: &#123;                handle1: function(event) &#123;                    console.log(event.target.innerHTML)                &#125;,                handle2: function(p, p1, event) &#123;                    console.log(p, p1)                    console.log(event.target.innerHTML)                    this.num++;                &#125;            &#125;        &#125;);    &lt;/script&gt;\n\n事件修饰符\n在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。\nVue 不推荐我们操作DOM    为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符\n修饰符是由点开头的指令后缀来表示的\n\n&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联   即阻止冒泡也阻止默认事件 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。\n\n按键修饰符\n在做项目中有时会用到键盘事件，在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符\n\n&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.13=&quot;submit&quot;&gt;&lt;!-- -当点击enter 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;&lt;!--当点击enter或者space时  时调用 `vm.alertMe()`   --&gt;&lt;input type=&quot;text&quot; v-on:keyup.enter.space=&quot;alertMe&quot; &gt;常用的按键修饰符.enter =&gt;    enter键.tab =&gt; tab键.delete (捕获“删除”和“退格”按键) =&gt;  删除键.esc =&gt; 取消键.space =&gt;  空格键.up =&gt;  上.down =&gt;  下.left =&gt;  左.right =&gt;  右&lt;script&gt;\tvar vm = new Vue(&#123;        el:&quot;#app&quot;,        methods: &#123;              submit:function()&#123;&#125;,              alertMe:function()&#123;&#125;,        &#125;    &#125;)&lt;/script&gt;\n\n自定义按键修饰符别名\n在Vue中可以通过config.keyCodes自定义按键修饰符别名\n\n&lt;div id=&quot;app&quot;&gt;    预先定义了keycode 116（即F5）的别名为f5，因此在文字输入框中按下F5，会触发prompt方法    &lt;input type=&quot;text&quot; v-on:keydown.f5=&quot;prompt()&quot;&gt;&lt;/div&gt;&lt;script&gt;\t    Vue.config.keyCodes.f5 = 116;    let app = new Vue(&#123;        el: &#x27;#app&#x27;,        methods: &#123;            prompt: function() &#123;                alert(&#x27;我是 F5！&#x27;);            &#125;        &#125;    &#125;);&lt;/script&gt;\n\nv-bind\nv-bind 指令被用来响应地更新 HTML 属性\nv-bind:href    可以缩写为    :href;\n\n&lt;!-- 绑定一个属性 --&gt;&lt;img v-bind:src=&quot;imageSrc&quot;&gt;&lt;!-- 缩写 --&gt;&lt;img :src=&quot;imageSrc&quot;&gt;\n\n绑定对象\n我们可以给v-bind:class 一个对象，以动态地切换class。\n注意：v-bind:class指令可以与普通的class特性共存\n\n1、 v-bind 中支持绑定一个对象 \t如果绑定的是一个对象 则 键为 对应的类名  值 为对应data中的数据 &lt;!-- \tHTML最终渲染为 &lt;ul class=&quot;box textColor textSize&quot;&gt;&lt;/ul&gt;\t注意：\t\ttextColor，textSize  对应的渲染到页面上的CSS类名\t\t\tisColor，isSize  对应vue data中的数据  如果为true 则对应的类名 渲染到页面上 \t\t当 isColor 和 isSize 变化时，class列表将相应的更新，\t\t例如，将isSize改成false，\t\tclass列表将变为 &lt;ul class=&quot;box textColor&quot;&gt;&lt;/ul&gt;--&gt;&lt;ul class=&quot;box&quot; v-bind:class=&quot;&#123;textColor:isColor, textSize:isSize&#125;&quot;&gt;    &lt;li&gt;学习Vue&lt;/li&gt;    &lt;li&gt;学习Node&lt;/li&gt;    &lt;li&gt;学习React&lt;/li&gt;&lt;/ul&gt;  &lt;div v-bind:style=&quot;&#123;color:activeColor,fontSize:activeSize&#125;&quot;&gt;对象语法&lt;/div&gt;&lt;sript&gt;var vm= new Vue(&#123;    el:&#x27;.box&#x27;,    data:&#123;        isColor:true,        isSize:true，    \tactiveColor:&quot;red&quot;,        activeSize:&quot;25px&quot;,    &#125;&#125;)&lt;/sript&gt;&lt;style&gt;    .box&#123;        border:1px dashed #f0f;    &#125;    .textColor&#123;        color:#f00;        background-color:#eef;    &#125;    .textSize&#123;        font-size:30px;        font-weight:bold;    &#125;&lt;/style&gt;\n\n绑定class2、  v-bind 中支持绑定一个数组    数组中classA和 classB 对应为data中的数据这里的classA  对用data 中的  classA这里的classB  对用data 中的  classB&lt;ul class=&quot;box&quot; :class=&quot;[classA, classB]&quot;&gt;    &lt;li&gt;学习Vue&lt;/li&gt;    &lt;li&gt;学习Node&lt;/li&gt;    &lt;li&gt;学习React&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var vm= new Vue(&#123;    el:&#x27;.box&#x27;,    data:&#123;        classA:‘textColor‘,        classB:‘textSize‘    &#125;&#125;)&lt;/script&gt;&lt;style&gt;    .box&#123;        border:1px dashed #f0f;    &#125;    .textColor&#123;        color:#f00;        background-color:#eef;    &#125;    .textSize&#123;        font-size:30px;        font-weight:bold;    &#125;&lt;/style&gt;\n\n绑定对象和绑定数组 的区别\n绑定对象的时候 对象的属性 即要渲染的类名 对象的属性值对应的是 data 中的数据 \n绑定数组的时候数组里面存的是data 中的数据 \n\n绑定style &lt;div v-bind:style=&quot;styleObject&quot;&gt;绑定样式对象&lt;/div&gt;&#x27; &lt;!-- CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来)    --&gt; &lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize,background:&#x27;red&#x27; &#125;&quot;&gt;内联样式&lt;/div&gt;&lt;!--组语法可以将多个样式对象应用到同一个元素 --&gt;&lt;div v-bind:style=&quot;[styleObj1, styleObj2]&quot;&gt;&lt;/div&gt;&lt;script&gt;\tnew Vue(&#123;      el: &#x27;#app&#x27;,      data: &#123;        styleObject: &#123;          color: &#x27;green&#x27;,          fontSize: &#x27;30px&#x27;,          background:&#x27;red&#x27;        &#125;，        activeColor: &#x27;green&#x27;,   \t\tfontSize: &quot;30px&quot;      &#125;,      styleObj1: &#123;             color: &#x27;red&#x27;       &#125;,       styleObj2: &#123;            fontSize: &#x27;30px&#x27;       &#125;&lt;/script&gt;\n\n分支结构v-if 使用场景\n1- 多个元素 通过条件判断展示或者隐藏某个元素。或者多个元素\n2- 进行两个视图之间的切换\n\n&lt;div id=&quot;app&quot;&gt;        &lt;!--  判断是否加载，如果为真，就加载，否则不加载--&gt;        &lt;span v-if=&quot;flag&quot;&gt;           如果flag为true则显示,false不显示!        &lt;/span&gt;&lt;/div&gt;&lt;script&gt;    var vm = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            flag:true        &#125;    &#125;)&lt;/script&gt;----------------------------------------------------------    &lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt;       A    &lt;/div&gt;  &lt;!-- v-else-if紧跟在v-if或v-else-if之后   表示v-if条件不成立时执行--&gt;    &lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;       B    &lt;/div&gt;    &lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;       C    &lt;/div&gt;  &lt;!-- v-else紧跟在v-if或v-else-if之后--&gt;    &lt;div v-else&gt;       Not A/B/C    &lt;/div&gt;&lt;script&gt;    new Vue(&#123;      el: &#x27;#app&#x27;,      data: &#123;        type: &#x27;C&#x27;      &#125;    &#125;)&lt;/script&gt;\n\nv-show 和 v-if的区别\nv-show本质就是标签display设置为none，控制隐藏\nv-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故v-show性能更好一点。\n\n\nv-if是动态的向DOM树内添加或者删除DOM元素\nv-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件\n\n\n\n循环结构v-for\n用于循环的数组里面的值可以是对象，也可以是普通元素  \n\n&lt;ul id=&quot;example-1&quot;&gt;   &lt;!-- 循环结构-遍历数组  \titem 是我们自己定义的一个名字  代表数组里面的每一项  \titems对应的是 data中的数组--&gt;  &lt;li v-for=&quot;item in items&quot;&gt;    &#123;&#123; item.message &#125;&#125;  &lt;/li&gt; &lt;/ul&gt;&lt;script&gt; new Vue(&#123;  el: &#x27;#example-1&#x27;,  data: &#123;    items: [      &#123; message: &#x27;Foo&#x27; &#125;,      &#123; message: &#x27;Bar&#x27; &#125;    ]，     &#125;&#125;)&lt;/script&gt;\n\n\n不推荐同时使用 v-if 和 v-for\n当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。\n\n   &lt;!--  循环结构-遍历对象\t\tv 代表   对象的value\t\tk  代表对象的 键 \t\ti  代表索引\t\t---&gt;      &lt;div v-if=&#x27;v==13&#x27; v-for=&#x27;(v,k,i) in obj&#x27;&gt;&#123;&#123;v + &#x27;---&#x27; + k + &#x27;---&#x27; + i&#125;&#125;&lt;/div&gt;&lt;script&gt; new Vue(&#123;  el: &#x27;#example-1&#x27;,  data: &#123;    items: [      &#123; message: &#x27;Foo&#x27; &#125;,      &#123; message: &#x27;Bar&#x27; &#125;    ]，    obj: &#123;        uname: &#x27;zhangsan&#x27;,        age: 13,        gender: &#x27;female&#x27;    &#125;  &#125;&#125;)&lt;/script&gt;\n\n\nkey 的作用\nkey来给每个节点做一个唯一标识\nkey的作用主要是为了高效的更新虚拟DOM\n\n\n\n&lt;ul&gt;  &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;...&lt;/li&gt;&lt;/ul&gt;\n\n\n\n案例选项卡1、 HTML 结构`    &lt;div id=&quot;app&quot;&gt;        &lt;div class=&quot;tab&quot;&gt;            &lt;!--  tab栏  --&gt;            &lt;ul&gt;                &lt;li class=&quot;active&quot;&gt;apple&lt;/li&gt;                &lt;li class=&quot;&quot;&gt;orange&lt;/li&gt;                &lt;li class=&quot;&quot;&gt;lemon&lt;/li&gt;            &lt;/ul&gt;              &lt;!--  对应显示的图片 --&gt;            &lt;div class=&quot;current&quot;&gt;&lt;img src=&quot;img/apple.png&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;&quot;&gt;&lt;img src=&quot;img/orange.png&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;&quot;&gt;&lt;img src=&quot;img/lemon.png&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;`\n\n2、 提供的数据list: [&#123;           id: 1,           title: &#x27;apple&#x27;,           path: &#x27;img/apple.png&#x27;       &#125;, &#123;           id: 2,           title: &#x27;orange&#x27;,           path: &#x27;img/orange.png&#x27;       &#125;, &#123;           id: 3,           title: &#x27;lemon&#x27;,           path: &#x27;img/lemon.png&#x27;       &#125;]\n\n\n\n3、 把数据渲染到页面\n把tab栏 中的数替换到页面上\n\n把 data 中 title  利用 v-for 循环渲染到页面上 \n把 data 中 path利用 v-for 循环渲染到页面上 \n\n    &lt;div id=&quot;app&quot;&gt;        &lt;div class=&quot;tab&quot;&gt;              &lt;ul&gt;                  &lt;!--                      1、绑定key的作用 提高Vue的性能                     2、 key 需要是唯一的标识 所以需要使用id， 也可以使用index ，\t\t\t\t\t\tindex 也是唯一的                     3、 item 是 数组中对应的每一项                      4、 index 是 每一项的 索引                --&gt;                   &lt;li :key=&#x27;item.id&#x27; v-for=&#x27;(item,index) in list&#x27;&gt;&#123;&#123;item.title&#125;&#125;&lt;/li&gt;              &lt;/ul&gt;              &lt;div  :key=&#x27;item.id&#x27; v-for=&#x27;(item, index) in list&#x27;&gt;                    &lt;!-- :  是 v-bind 的简写   绑定属性使用 v-bind --&gt;                    &lt;img :src=&quot;item.path&quot;&gt;              &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;script&gt;    new  Vue(&#123;        //  指定 操作元素 是 id 为app 的         el: &#x27;#app&#x27;,            data: &#123;                list: [&#123;                    id: 1,                    title: &#x27;apple&#x27;,                    path: &#x27;img/apple.png&#x27;                &#125;, &#123;                    id: 2,                    title: &#x27;orange&#x27;,                    path: &#x27;img/orange.png&#x27;                &#125;, &#123;                    id: 3,                    title: &#x27;lemon&#x27;,                    path: &#x27;img/lemon.png&#x27;                &#125;]            &#125;    &#125;)&lt;/script&gt;\n\n4、 给每一个tab栏添加事件,并让选中的高亮\n4.1 、让默认的第一项tab栏高亮\n\ntab栏高亮 通过添加类名active 来实现   （CSS  active 的样式已经提前写好）\n在data 中定义一个 默认的  索引 currentIndex  为  0 \n给第一个li 添加 active 的类名  \n通过动态绑定class 来实现   第一个li 的索引为 0     和 currentIndex   的值刚好相等\ncurrentIndex     ===  index  如果相等  则添加类名 active  否则 添加 空类名\n\n\n\n\n\n\n4.2 、让默认的第一项tab栏对应的div 显示 \n\n实现思路 和 第一个 tab 实现思路一样  只不过 这里控制第一个div 显示的类名是 current\n\n  &lt;ul&gt;\t   &lt;!-- 动态绑定class   有 active   类名高亮  无 active   不高亮--&gt;       &lt;li  :class=&#x27;currentIndex==index?&quot;active&quot;:&quot;&quot;&#x27;           :key=&#x27;item.id&#x27; v-for=&#x27;(item,index) in list&#x27;           &gt;&#123;&#123;item.title&#125;&#125;&lt;/li&gt;  &lt;/ul&gt;\t&lt;!-- 动态绑定class   有 current  类名显示  无 current  隐藏--&gt;  &lt;div :class=&#x27;currentIndex==index?&quot;current&quot;:&quot;&quot;&#x27;               :key=&#x27;item.id&#x27; v-for=&#x27;(item, index) in list&#x27;&gt;        &lt;!-- :  是 v-bind 的简写   绑定属性使用 v-bind --&gt;        &lt;img :src=&quot;item.path&quot;&gt;  &lt;/div&gt;&lt;script&gt;    new  Vue(&#123;        el: &#x27;#app&#x27;,            data: &#123;                currentIndex: 0, // 选项卡当前的索引  默认为 0                  list: [&#123;                    id: 1,                    title: &#x27;apple&#x27;,                    path: &#x27;img/apple.png&#x27;                &#125;, &#123;                    id: 2,                    title: &#x27;orange&#x27;,                    path: &#x27;img/orange.png&#x27;                &#125;, &#123;                    id: 3,                    title: &#x27;lemon&#x27;,                    path: &#x27;img/lemon.png&#x27;                &#125;]            &#125;    &#125;)&lt;/script&gt;\n4.3 、点击每一个tab栏 当前的高亮 其他的取消高亮 \n\n给每一个li添加点击事件    \n\n让当前的索引 index  和  当前 currentIndex 的  值 进项比较 \n\n如果相等 则当前li  添加active 类名 当前的 li 高亮  当前对应索引的 div 添加 current 当前div 显示 其他隐藏\n    &lt;div id=&quot;app&quot;&gt;        &lt;div class=&quot;tab&quot;&gt;            &lt;ul&gt;                &lt;!--  通过v-on 添加点击事件   需要把当前li 的索引传过去 \t\t\t\t--&gt;                &lt;li v-on:click=&#x27;change(index)&#x27;\t\t           \t\t\t                    :class=&#x27;currentIndex==index?&quot;active&quot;:&quot;&quot;&#x27;                                       :key=&#x27;item.id&#x27;                     v-for=&#x27;(item,index) in list&#x27;&gt;&#123;&#123;item.title&#125;&#125;&lt;/li&gt;            &lt;/ul&gt;            &lt;div :class=&#x27;currentIndex==index?&quot;current&quot;:&quot;&quot;&#x27;                  :key=&#x27;item.id&#x27; v-for=&#x27;(item, index) in list&#x27;&gt;                &lt;img :src=&quot;item.path&quot;&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;script&gt;    new  Vue(&#123;        el: &#x27;#app&#x27;,            data: &#123;                currentIndex: 0, // 选项卡当前的索引  默认为 0                  list: [&#123;                    id: 1,                    title: &#x27;apple&#x27;,                    path: &#x27;img/apple.png&#x27;                &#125;, &#123;                    id: 2,                    title: &#x27;orange&#x27;,                    path: &#x27;img/orange.png&#x27;                &#125;, &#123;                    id: 3,                    title: &#x27;lemon&#x27;,                    path: &#x27;img/lemon.png&#x27;                &#125;]            &#125;,            methods: &#123;                change: function(index) &#123;                    // 通过传入过来的索引来让当前的  currentIndex  和点击的index 值 相等                     //  从而实现 控制类名                        this.currentIndex = index;                &#125;            &#125;        &#125;)&lt;/script&gt;\n\n\n\nday02Vue常用特性表单基本操作\n获取单选框中的值\n\n通过v-model\n\n \t&lt;!-- \t\t1、 两个单选框需要同时通过v-model 双向绑定 一个值         2、 每一个单选框必须要有value属性  且value 值不能一样 \t\t3、 当某一个单选框选中的时候 v-model  会将当前的 value值 改变 data 中的 数据\t\tgender 的值就是选中的值，我们只需要实时监控他的值就可以了\t--&gt;   &lt;input type=&quot;radio&quot; id=&quot;male&quot; value=&quot;1&quot; v-model=&#x27;gender&#x27;&gt;   &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;   &lt;input type=&quot;radio&quot; id=&quot;female&quot; value=&quot;2&quot; v-model=&#x27;gender&#x27;&gt;   &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt;&lt;script&gt;    new Vue(&#123;         data: &#123;             // 默认会让当前的 value 值为 2 的单选框选中                gender: 2,              &#125;,    &#125;)&lt;/script&gt;\n获取复选框中的值\n\n通过v-model\n和获取单选框中的值一样 \n复选框 checkbox 这种的组合时   data 中的 hobby 我们要定义成数组 否则无法实现多选\n\n\t&lt;!-- \t\t1、 复选框需要同时通过v-model 双向绑定 一个值         2、 每一个复选框必须要有value属性  且value 值不能一样 \t\t3、 当某一个单选框选中的时候 v-model  会将当前的 value值 改变 data 中的 数据\t\thobby 的值就是选中的值，我们只需要实时监控他的值就可以了\t--&gt;&lt;div&gt;   &lt;span&gt;爱好：&lt;/span&gt;   &lt;input type=&quot;checkbox&quot; id=&quot;ball&quot; value=&quot;1&quot; v-model=&#x27;hobby&#x27;&gt;   &lt;label for=&quot;ball&quot;&gt;篮球&lt;/label&gt;   &lt;input type=&quot;checkbox&quot; id=&quot;sing&quot; value=&quot;2&quot; v-model=&#x27;hobby&#x27;&gt;   &lt;label for=&quot;sing&quot;&gt;唱歌&lt;/label&gt;   &lt;input type=&quot;checkbox&quot; id=&quot;code&quot; value=&quot;3&quot; v-model=&#x27;hobby&#x27;&gt;   &lt;label for=&quot;code&quot;&gt;写代码&lt;/label&gt; &lt;/div&gt;&lt;script&gt;    new Vue(&#123;         data: &#123;                // 默认会让当前的 value 值为 2 和 3 的复选框选中                hobby: [&#x27;2&#x27;, &#x27;3&#x27;],            &#125;,    &#125;)&lt;/script&gt;\n获取下拉框和文本框中的值\n\n通过v-model\n\n   &lt;div&gt;      &lt;span&gt;职业：&lt;/span&gt;       &lt;!--\t\t\t1、 需要给select  通过v-model 双向绑定 一个值             2、 每一个option  必须要有value属性  且value 值不能一样 \t\t    3、 当某一个option选中的时候 v-model  会将当前的 value值 改变 data 中的 数据\t\t     occupation 的值就是选中的值，我们只需要实时监控他的值就可以了\t\t--&gt;       &lt;!-- multiple  多选 --&gt;      &lt;select v-model=&#x27;occupation&#x27; multiple&gt;          &lt;option value=&quot;0&quot;&gt;请选择职业...&lt;/option&gt;          &lt;option value=&quot;1&quot;&gt;教师&lt;/option&gt;          &lt;option value=&quot;2&quot;&gt;软件工程师&lt;/option&gt;          &lt;option value=&quot;3&quot;&gt;律师&lt;/option&gt;      &lt;/select&gt;         &lt;!-- textarea 是 一个双标签   不需要绑定value 属性的  --&gt;        &lt;textarea v-model=&#x27;desc&#x27;&gt;&lt;/textarea&gt;  &lt;/div&gt;&lt;script&gt;    new Vue(&#123;         data: &#123;                // 默认会让当前的 value 值为 2 和 3 的下拉框选中                 occupation: [&#x27;2&#x27;, &#x27;3&#x27;],             \t desc: &#x27;nihao&#x27;            &#125;,    &#125;)&lt;/script&gt;\n\n表单修饰符\n.number  转换为数值\n\n注意点：    \n当开始输入非数字的字符串时，因为Vue无法将字符串转换成数值\n所以属性值将实时更新成相同的字符串。即使后面输入数字，也将被视作字符串。\n\n\n.trim  自动过滤用户输入的首尾空白字符\n\n只能去掉首尾的 不能去除中间的空格\n\n\n.lazy   将input事件切换成change事件\n\n.lazy 修饰符延迟了同步更新属性值的时机。即将原本绑定在 input 事件的同步逻辑转变为绑定在 change 事件上\n\n\n在失去焦点 或者 按下回车键时才更新\n&lt;!-- 自动将用户的输入值转为数值类型 --&gt;&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;&lt;!--自动过滤用户输入的首尾空白字符   --&gt;&lt;input v-model.trim=&quot;msg&quot;&gt;&lt;!-- 在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot; &gt;\n\n自定义指令\n内置指令不能满足我们特殊的需求\nVue允许我们自定义指令\n\nVue.directive  注册全局指令&lt;!--   使用自定义的指令，只需在对用的元素中，加上&#x27;v-&#x27;的前缀形成类似于内部指令&#x27;v-if&#x27;，&#x27;v-text&#x27;的形式。 --&gt;&lt;input type=&quot;text&quot; v-focus&gt;&lt;script&gt;// 注意点： //   1、 在自定义指令中  如果以驼峰命名的方式定义 如  Vue.directive(&#x27;focusA&#x27;,function()&#123;&#125;) //   2、 在HTML中使用的时候 只能通过 v-focus-a 来使用     // 注册一个全局自定义指令 v-focusVue.directive(&#x27;focus&#x27;, &#123;  \t// 当绑定元素插入到 DOM 中。 其中 el为dom元素  \tinserted: function (el) &#123;    \t\t// 聚焦元素    \t\tel.focus(); \t&#125;&#125;);new Vue(&#123;　　el:&#x27;#app&#x27;&#125;);&lt;/script&gt;\n\nVue.directive  注册全局指令 带参数 &lt;input type=&quot;text&quot; v-color=&#x27;msg&#x27;&gt;&lt;script type=&quot;text/javascript&quot;&gt;   /*     自定义指令-带参数     bind - 只调用一次，在指令第一次绑定到元素上时候调用   */   Vue.directive(&#x27;color&#x27;, &#123;     // bind声明周期, 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置     // el 为当前自定义指令的DOM元素       // binding 为自定义的函数形参   通过自定义属性传递过来的值 存在 binding.value 里面     bind: function(el, binding)&#123;       // 根据指令的参数设置背景色       // console.log(binding.value.color)       el.style.backgroundColor = binding.value.color;     &#125;   &#125;);   var vm = new Vue(&#123;     el: &#x27;#app&#x27;,     data: &#123;       msg: &#123;         color: &#x27;blue&#x27;       &#125;     &#125;   &#125;); &lt;/script&gt;\n\n自定义指令局部指令\n局部指令，需要定义在  directives 的选项   用法和全局用法一样 \n局部指令只能在当前组件里面使用\n当全局指令和局部指令同名时以局部指令为准\n\n&lt;input type=&quot;text&quot; v-color=&#x27;msg&#x27;&gt; &lt;input type=&quot;text&quot; v-focus&gt; &lt;script type=&quot;text/javascript&quot;&gt;    /*      自定义指令-局部指令    */    var vm = new Vue(&#123;      el: &#x27;#app&#x27;,      data: &#123;        msg: &#123;          color: &#x27;red&#x27;        &#125;      &#125;,   \t  //局部指令，需要定义在  directives 的选项      directives: &#123;        color: &#123;          bind: function(el, binding)&#123;            el.style.backgroundColor = binding.value.color;          &#125;        &#125;,        focus: &#123;          inserted: function(el) &#123;            el.focus();          &#125;        &#125;      &#125;    &#125;);  &lt;/script&gt;\n\n计算属性   computed\n模板中放入太多的逻辑会让模板过重且难以维护  使用计算属性可以让模板更加的简洁\n计算属性是基于它们的响应式依赖进行缓存的\ncomputed比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化\n\n&lt;div id=&quot;app&quot;&gt;    &lt;!--         当多次调用 reverseString  的时候        只要里面的 num 值不改变 他会把第一次计算的结果直接返回\t直到data 中的num值改变 计算属性才会重新发生计算    --&gt;   &lt;div&gt;&#123;&#123;reverseString&#125;&#125;&lt;/div&gt;   &lt;div&gt;&#123;&#123;reverseString&#125;&#125;&lt;/div&gt;    &lt;!-- 调用methods中的方法的时候  他每次会重新调用 --&gt;   &lt;div&gt;&#123;&#123;reverseMessage()&#125;&#125;&lt;/div&gt;   &lt;div&gt;&#123;&#123;reverseMessage()&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt;   /*     计算属性与方法的区别:计算属性是基于依赖进行缓存的，而方法不缓存   */   var vm = new Vue(&#123;     el: &#x27;#app&#x27;,     data: &#123;       msg: &#x27;Nihao&#x27;,       num: 100     &#125;,     methods: &#123;       reverseMessage: function()&#123;         console.log(&#x27;methods&#x27;)         return this.msg.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);       &#125;     &#125;,     //computed  属性 定义 和 data 已经 methods 平级      computed: &#123;       //  reverseString   这个是我们自己定义的名字        reverseString: function()&#123;         console.log(&#x27;computed&#x27;)         var total = 0;         //  当data 中的 num 的值改变的时候  reverseString  会自动发生计算           for(var i=0;i&lt;=this.num;i++)&#123;           total += i;         &#125;         // 这里一定要有return 否则 调用 reverseString 的 时候无法拿到结果             return total;       &#125;     &#125;   &#125;); &lt;/script&gt;\n\n侦听器   watch\n使用watch来响应数据的变化\n一般用于异步或者开销较大的操作\nwatch 中的属性 一定是data 中 已经存在的数据 \n当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变，只有data中的数据才能够监听到变化，此时就需要deep属性对对象进行深度监听\n\n&lt;div id=&quot;app&quot;&gt;       &lt;div&gt;           &lt;span&gt;名：&lt;/span&gt;           &lt;span&gt;       &lt;input type=&quot;text&quot; v-model=&#x27;firstName&#x27;&gt;     &lt;/span&gt;       &lt;/div&gt;       &lt;div&gt;           &lt;span&gt;姓：&lt;/span&gt;           &lt;span&gt;       &lt;input type=&quot;text&quot; v-model=&#x27;lastName&#x27;&gt;     &lt;/span&gt;       &lt;/div&gt;       &lt;div&gt;&#123;&#123;fullName&#125;&#125;&lt;/div&gt;   &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt;       /*             侦听器           */       var vm = new Vue(&#123;           el: &#x27;#app&#x27;,           data: &#123;               firstName: &#x27;Jim&#x27;,               lastName: &#x27;Green&#x27;,               // fullName: &#x27;Jim Green&#x27;           &#125;,            //watch  属性 定义 和 data 已经 methods 平级            watch: &#123;               //   注意：  这里firstName  对应着data 中的 firstName                //   当 firstName 值 改变的时候  会自动触发 watch               firstName: function(val) &#123;                   this.fullName = val + &#x27; &#x27; + this.lastName;               &#125;,               //   注意：  这里 lastName 对应着data 中的 lastName                lastName: function(val) &#123;                   this.fullName = this.firstName + &#x27; &#x27; + val;               &#125;           &#125;       &#125;);   &lt;/script&gt;\n\n\n\n过滤器\nVue.js允许自定义过滤器，可被用于一些常见的文本格式化。\n过滤器可以用在两个地方：双花括号插值和v-bind表达式。\n过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示\n支持级联操作\n过滤器不改变真正的data，而只是改变渲染的结果，并返回过滤后的版本\n全局注册时是filter，没有s的。而局部过滤器是filters，是有s的\n\n  &lt;div id=&quot;app&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&#x27;msg&#x27;&gt;      &lt;!-- upper 被定义为接收单个参数的过滤器函数，表达式  msg  的值将作为参数传入到函数中 --&gt;    &lt;div&gt;&#123;&#123;msg | upper&#125;&#125;&lt;/div&gt;    &lt;!--        支持级联操作      upper  被定义为接收单个参数的过滤器函数，表达式msg 的值将作为参数传入到函数中。\t  然后继续调用同样被定义为接收单个参数的过滤器 lower ，将upper 的结果传递到lower中 \t--&gt;    &lt;div&gt;&#123;&#123;msg | upper | lower&#125;&#125;&lt;/div&gt;    &lt;div :abc=&#x27;msg | upper&#x27;&gt;测试数据&lt;/div&gt;  &lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;   //  lower  为全局过滤器        Vue.filter(&#x27;lower&#x27;, function(val) &#123;      return val.charAt(0).toLowerCase() + val.slice(1);    &#125;);    var vm = new Vue(&#123;      el: &#x27;#app&#x27;,      data: &#123;        msg: &#x27;&#x27;      &#125;,       //filters  属性 定义 和 data 已经 methods 平级        //  定义filters 中的过滤器为局部过滤器       filters: &#123;        //   upper  自定义的过滤器名字         //    upper 被定义为接收单个参数的过滤器函数，表达式  msg  的值将作为参数传入到函数中        upper: function(val) &#123;         //  过滤器中一定要有返回值 这样外界使用过滤器的时候才能拿到结果          return val.charAt(0).toUpperCase() + val.slice(1);        &#125;      &#125;    &#125;);  &lt;/script&gt;\n\n过滤器中传递参数  &lt;div id=&quot;box&quot;&gt;      &lt;!--\tfilterA 被定义为接收三个参数的过滤器函数。\t\t\t其中 message 的值作为第一个参数，\t普通字符串 &#x27;arg1&#x27; 作为第二个参数，表达式 arg2 的值作为第三个参数。--&gt;      &#123;&#123; message | filterA(&#x27;arg1&#x27;, &#x27;arg2&#x27;) &#125;&#125;  &lt;/div&gt;  &lt;script&gt;      // 在过滤器中 第一个参数 对应的是  管道符前面的数据   n  此时对应 message      // 第2个参数  a 对应 实参  arg1 字符串      // 第3个参数  b 对应 实参  arg2 字符串      Vue.filter(&#x27;filterA&#x27;,function(n,a,b)&#123;          if(n&lt;10)&#123;              return n+a;          &#125;else&#123;              return n+b;          &#125;      &#125;);            new Vue(&#123;          el:&quot;#box&quot;,          data:&#123;              message: &quot;哈哈哈&quot;          &#125;      &#125;)  &lt;/script&gt;\n\n\n\n\n\n生命周期\n事物从出生到死亡的过程\nVue实例从创建 到销毁的过程 ，这些过程中会伴随着一些函数的自调用。我们称这些函数为钩子函数\n\n####常用的 钩子函数\n\n\n\nbeforeCreate\n在实例初始化之后，数据观测和事件配置之前被调用 此时data 和 methods 以及页面的DOM结构都没有初始化   什么都做不了\n\n\n\ncreated\n在实例创建完成后被立即调用此时data 和 methods已经可以使用  但是页面还没有渲染出来\n\n\nbeforeMount\n在挂载开始之前被调用   此时页面上还看不到真实数据 只是一个模板页面而已\n\n\nmounted\nel被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。  数据已经真实渲染到页面上  在这个钩子函数里面我们可以使用一些第三方的插件\n\n\nbeforeUpdate\n数据更新时调用，发生在虚拟DOM打补丁之前。   页面上数据还是旧的\n\n\nupdated\n由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。 页面上数据已经替换成最新的\n\n\nbeforeDestroy\n实例销毁之前调用\n\n\ndestroyed\n实例销毁后调用\n\n\n数组变异方法\n在 Vue 中，直接修改对象属性的值无法触发响应式。当你直接修改了对象属性的值，你会发现，只有数据改了，但是页面内容并没有改变\n变异数组方法即保持数组方法原有功能不变的前提下对其进行功能拓展\n\n\n\n\npush()\n往数组最后面添加一个元素，成功返回当前数组的长度\n\n\n\npop()\n删除数组的最后一个元素，成功返回删除元素的值\n\n\nshift()\n删除数组的第一个元素，成功返回删除元素的值\n\n\nunshift()\n往数组最前面添加一个元素，成功返回当前数组的长度\n\n\nsplice()\n有三个参数，第一个是想要删除的元素的下标（必选），第二个是想要删除的个数（必选），第三个是删除 后想要在原位置替换的值\n\n\nsort()\nsort()  使数组按照字符编码默认从小到大排序,成功返回排序后的数组\n\n\nreverse()\nreverse()  将数组倒序，成功返回倒序后的数组\n\n\n替换数组\n不会改变原始数组，但总是返回一个新数组\n\n\n\n\nfilter\nfilter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。\n\n\n\nconcat\nconcat() 方法用于连接两个或多个数组。该方法不会改变现有的数组\n\n\nslice\nslice() 方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子数组\n\n\n动态数组响应式数据\nVue.set(a,b,c)    让 触发视图重新更新一遍，数据动态起来\na是要更改的数据 、   b是数据的第几项、   c是更改后的数据\n\n图书列表案例\n静态列表效果\n基于数据实现模板效果\n处理每行的操作按钮\n\n1、 提供的静态数据\n数据存放在vue 中 data 属性中\n\nvar vm = new Vue(&#123;     el: &#x27;#app&#x27;,     data: &#123;       books: [&#123;         id: 1,         name: &#x27;三国演义&#x27;,         date: &#x27;&#x27;       &#125;,&#123;         id: 2,         name: &#x27;水浒传&#x27;,         date: &#x27;&#x27;       &#125;,&#123;         id: 3,         name: &#x27;红楼梦&#x27;,         date: &#x27;&#x27;       &#125;,&#123;         id: 4,         name: &#x27;西游记&#x27;,         date: &#x27;&#x27;       &#125;]     &#125;   &#125;); var vm = new Vue(&#123;     el: &#x27;#app&#x27;,     data: &#123;       books: [&#123;         id: 1,         name: &#x27;三国演义&#x27;,         date: &#x27;&#x27;       &#125;,&#123;         id: 2,         name: &#x27;水浒传&#x27;,         date: &#x27;&#x27;       &#125;,&#123;         id: 3,         name: &#x27;红楼梦&#x27;,         date: &#x27;&#x27;       &#125;,&#123;         id: 4,         name: &#x27;西游记&#x27;,         date: &#x27;&#x27;       &#125;]     &#125;   &#125;);\n\n2、 把提供好的数据渲染到页面上\n利用 v-for循环 遍历 books 将每一项数据渲染到对应的数据中\n\n &lt;tbody&gt;    &lt;tr :key=&#x27;item.id&#x27; v-for=&#x27;item in books&#x27;&gt;       &lt;!-- 对应的id 渲染到页面上 --&gt;       &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;        &lt;!-- 对应的name 渲染到页面上 --&gt;       &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;       &lt;td&gt;&#123;&#123;item.date&#125;&#125;&lt;/td&gt;       &lt;td&gt;         &lt;!-- 阻止 a 标签的默认跳转 --&gt;         &lt;a href=&quot;&quot; @click.prevent&gt;修改&lt;/a&gt;         &lt;span&gt;|&lt;/span&gt;       \t  &lt;a href=&quot;&quot; @click.prevent&gt;删除&lt;/a&gt;       &lt;/td&gt;     &lt;/tr&gt;&lt;/tbody&gt;\n\n3、 添加图书\n通过双向绑定获取到输入框中的输入内容 \n给按钮添加点击事件 \n把输入框中的数据存储到 data 中的 books  里面\n\n&lt;div&gt;  &lt;h1&gt;图书管理&lt;/h1&gt;  &lt;div class=&quot;book&quot;&gt;       &lt;div&gt;         &lt;label for=&quot;id&quot;&gt;           编号：         &lt;/label&gt;          &lt;!-- 3.1、通过双向绑定获取到输入框中的输入的 id  --&gt;         &lt;input type=&quot;text&quot; id=&quot;id&quot; v-model=&#x27;id&#x27;&gt;         &lt;label for=&quot;name&quot;&gt;           名称：         &lt;/label&gt;           &lt;!-- 3.2、通过双向绑定获取到输入框中的输入的 name  --&gt;         &lt;input type=&quot;text&quot; id=&quot;name&quot; v-model=&#x27;name&#x27;&gt;            &lt;!-- 3.3、给按钮添加点击事件  --&gt;         &lt;button @click=&#x27;handle&#x27;&gt;提交&lt;/button&gt;       &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    /*      图书管理-添加图书    */    var vm = new Vue(&#123;      el: &#x27;#app&#x27;,      data: &#123;        id: &#x27;&#x27;,        name: &#x27;&#x27;,        books: [&#123;          id: 1,          name: &#x27;三国演义&#x27;,          date: &#x27;&#x27;        &#125;,&#123;          id: 2,          name: &#x27;水浒传&#x27;,          date: &#x27;&#x27;        &#125;,&#123;          id: 3,          name: &#x27;红楼梦&#x27;,          date: &#x27;&#x27;        &#125;,&#123;          id: 4,          name: &#x27;西游记&#x27;,          date: &#x27;&#x27;        &#125;]      &#125;,      methods: &#123;        handle: function()&#123;          // 3.4 定义一个新的对象book 存储 获取到输入框中 书 的id和名字           var book = &#123;&#125;;          book.id = this.id;          book.name = this.name;          book.date = &#x27;&#x27;;         // 3.5 把book  通过数组的变异方法 push 放到    books 里面          this.books.push(book);          //3.6 清空输入框          this.id = &#x27;&#x27;;          this.name = &#x27;&#x27;;        &#125;      &#125;    &#125;);  &lt;/script&gt;\n\n4 修改图书-上\n点击修改按钮的时候 获取到要修改的书籍名单\n4.1  给修改按钮添加点击事件，  需要把当前的图书的id 传递过去 这样才知道需要修改的是哪一本书籍\n\n\n把需要修改的书籍名单填充到表单里面\n4.2  根据传递过来的id 查出books 中 对应书籍的详细信息\n4.3 把获取到的信息填充到表单\n\n\n\n&lt;div id=&quot;app&quot;&gt;   &lt;div class=&quot;grid&quot;&gt;     &lt;div&gt;       &lt;h1&gt;图书管理&lt;/h1&gt;       &lt;div class=&quot;book&quot;&gt;         &lt;div&gt;           &lt;label for=&quot;id&quot;&gt;             编号：           &lt;/label&gt;           &lt;input type=&quot;text&quot; id=&quot;id&quot; v-model=&#x27;id&#x27; :disabled=&quot;flag&quot;&gt;           &lt;label for=&quot;name&quot;&gt;             名称：           &lt;/label&gt;           &lt;input type=&quot;text&quot; id=&quot;name&quot; v-model=&#x27;name&#x27;&gt;           &lt;button @click=&#x27;handle&#x27;&gt;提交&lt;/button&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;     &lt;table&gt;       &lt;thead&gt;         &lt;tr&gt;           &lt;th&gt;编号&lt;/th&gt;           &lt;th&gt;名称&lt;/th&gt;           &lt;th&gt;时间&lt;/th&gt;           &lt;th&gt;操作&lt;/th&gt;         &lt;/tr&gt;       &lt;/thead&gt;       &lt;tbody&gt;         &lt;tr :key=&#x27;item.id&#x27; v-for=&#x27;item in books&#x27;&gt;           &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;           &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;           &lt;td&gt;&#123;&#123;item.date&#125;&#125;&lt;/td&gt;           &lt;td&gt;             &lt;!--- \t\t\t4.1  给修改按钮添加点击事件，  需要把当前的图书的id 传递过去 \t\t\t这样才知道需要修改的是哪一本书籍 \t\t\t\t---&gt;               &lt;a href=&quot;&quot; @click.prevent=&#x27;toEdit(item.id)&#x27;&gt;修改&lt;/a&gt;             &lt;span&gt;|&lt;/span&gt;             &lt;a href=&quot;&quot; @click.prevent&gt;删除&lt;/a&gt;           &lt;/td&gt;         &lt;/tr&gt;       &lt;/tbody&gt;     &lt;/table&gt;   &lt;/div&gt; &lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;   /*     图书管理-添加图书   */   var vm = new Vue(&#123;     el: &#x27;#app&#x27;,     data: &#123;       flag: false,       id: &#x27;&#x27;,       name: &#x27;&#x27;,       books: [&#123;         id: 1,         name: &#x27;三国演义&#x27;,         date: &#x27;&#x27;       &#125;,&#123;         id: 2,         name: &#x27;水浒传&#x27;,         date: &#x27;&#x27;       &#125;,&#123;         id: 3,         name: &#x27;红楼梦&#x27;,         date: &#x27;&#x27;       &#125;,&#123;         id: 4,         name: &#x27;西游记&#x27;,         date: &#x27;&#x27;       &#125;]     &#125;,     methods: &#123;       handle: function()&#123;         // 3.4 定义一个新的对象book 存储 获取到输入框中 书 的id和名字          var book = &#123;&#125;;         book.id = this.id;         book.name = this.name;         book.date = &#x27;&#x27;;        // 3.5 把book  通过数组的变异方法 push 放到    books 里面         this.books.push(book);         //3.6 清空输入框         this.id = &#x27;&#x27;;         this.name = &#x27;&#x27;;       &#125;,       toEdit: function(id)&#123;         console.log(id)         //4.2  根据传递过来的id 查出books 中 对应书籍的详细信息         var book = this.books.filter(function(item)&#123;           return item.id == id;         &#125;);         console.log(book)         //4.3 把获取到的信息填充到表单         // this.id   和  this.name 通过双向绑定 绑定到了表单中  一旦数据改变视图自动更新         this.id = book[0].id;         this.name = book[0].name;       &#125;     &#125;   &#125;); &lt;/script&gt;\n\n5  修改图书-下\n5.1  定义一个标识符， 主要是控制 编辑状态下当前编辑书籍的id 不能被修改 即 处于编辑状态下 当前控制书籍编号的输入框禁用  \n5.2  通过属性绑定给书籍编号的 绑定 disabled 的属性  flag 为 true 即为禁用\n5.3  flag 默认值为false   处于编辑状态 要把 flag 改为true 即当前表单为禁用 \n5.4  复用添加方法   用户点击提交的时候依然执行 handle 中的逻辑如果 flag为true 即 表单处于不可输入状态 此时执行的用户编辑数据数据\n\n&lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;grid&quot;&gt;      &lt;div&gt;        &lt;h1&gt;图书管理&lt;/h1&gt;        &lt;div class=&quot;book&quot;&gt;          &lt;div&gt;            &lt;label for=&quot;id&quot;&gt;              编号：            &lt;/label&gt;              &lt;!-- 5.2 通过属性绑定 绑定 disabled 的属性  flag 为 true 即为禁用      --&gt;            &lt;input type=&quot;text&quot; id=&quot;id&quot; v-model=&#x27;id&#x27; :disabled=&quot;flag&quot;&gt;            &lt;label for=&quot;name&quot;&gt;              名称：            &lt;/label&gt;            &lt;input type=&quot;text&quot; id=&quot;name&quot; v-model=&#x27;name&#x27;&gt;            &lt;button @click=&#x27;handle&#x27;&gt;提交&lt;/button&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;table&gt;        &lt;thead&gt;          &lt;tr&gt;            &lt;th&gt;编号&lt;/th&gt;            &lt;th&gt;名称&lt;/th&gt;            &lt;th&gt;时间&lt;/th&gt;            &lt;th&gt;操作&lt;/th&gt;          &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;          &lt;tr :key=&#x27;item.id&#x27; v-for=&#x27;item in books&#x27;&gt;            &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;            &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;            &lt;td&gt;&#123;&#123;item.date&#125;&#125;&lt;/td&gt;            &lt;td&gt;              &lt;a href=&quot;&quot; @click.prevent=&#x27;toEdit(item.id)&#x27;&gt;修改&lt;/a&gt;              &lt;span&gt;|&lt;/span&gt;              &lt;a href=&quot;&quot; @click.prevent&gt;删除&lt;/a&gt;            &lt;/td&gt;          &lt;/tr&gt;        &lt;/tbody&gt;      &lt;/table&gt;    &lt;/div&gt;  &lt;/div&gt;   &lt;script type=&quot;text/javascript&quot;&gt;        /*图书管理-添加图书*/        var vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                // 5.1  定义一个标识符， 主要是控制 编辑状态下当前编辑书籍的id 不能被修改                 // 即 处于编辑状态下 当前控制书籍编号的输入框禁用                 flag: false,                id: &#x27;&#x27;,                name: &#x27;&#x27;,                          &#125;,            methods: &#123;                handle: function() &#123;                   /*                     5.4  复用添加方法   用户点击提交的时候依然执行 handle 中的逻辑                 \t\t 如果 flag为true 即 表单处于不可输入状态 此时执行的用户编辑数据数据\t                   */                     if (this.flag) &#123;                        // 编辑图书                        // 5.5  根据当前的ID去更新数组中对应的数据                          this.books.some((item) =&gt; &#123;                            if (item.id == this.id) &#123;                                // 箭头函数中 this 指向父级作用域的this                                 item.name = this.name;                                // 完成更新操作之后，需要终止循环                                return true;                            &#125;                        &#125;);                        // 5.6 编辑完数据后表单要处以可以输入的状态                        this.flag = false;                    //  5.7  如果 flag为false  表单处于输入状态 此时执行的用户添加数据                        &#125; else &#123;                         var book = &#123;&#125;;                        book.id = this.id;                        book.name = this.name;                        book.date = &#x27;&#x27;;                        this.books.push(book);                        // 清空表单                        this.id = &#x27;&#x27;;                        this.name = &#x27;&#x27;;                    &#125;                    // 清空表单                    this.id = &#x27;&#x27;;                    this.name = &#x27;&#x27;;                &#125;,                toEdit: function(id) &#123;                     /*                     5.3  flag 默认值为false   处于编辑状态 要把 flag 改为true 即当前表单为禁\t\t\t\t\t  用                      */                     this.flag = true;                    console.log(id)                    var book = this.books.filter(function(item) &#123;                        return item.id == id;                    &#125;);                    console.log(book)                    this.id = book[0].id;                    this.name = book[0].name;                &#125;            &#125;        &#125;);    &lt;/script&gt;\n\n6 删除图书\n6.1 给删除按钮添加事件 把当前需要删除的书籍id 传递过来\n6.2 根据id从数组中查找元素的索引\n6.3 根据索引删除数组元素\n\n  &lt;tbody&gt;          &lt;tr :key=&#x27;item.id&#x27; v-for=&#x27;item in books&#x27;&gt;            &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;            &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;            &lt;td&gt;&#123;&#123;item.date&#125;&#125;&lt;/td&gt;            &lt;td&gt;              &lt;a href=&quot;&quot; @click.prevent=&#x27;toEdit(item.id)&#x27;&gt;修改&lt;/a&gt;              &lt;span&gt;|&lt;/span&gt;               &lt;!--  6.1 给删除按钮添加事件 把当前需要删除的书籍id 传递过来  --&gt;               &lt;a href=&quot;&quot; @click.prevent=&#x27;deleteBook(item.id)&#x27;&gt;删除&lt;/a&gt;            &lt;/td&gt;          &lt;/tr&gt;&lt;/tbody&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    /*      图书管理-添加图书    */    var vm = new Vue(&#123;      methods: &#123;        deleteBook: function(id)&#123;          // 删除图书          #// 6.2 根据id从数组中查找元素的索引          // var index = this.books.findIndex(function(item)&#123;          //   return item.id == id;          // &#125;);          #// 6.3 根据索引删除数组元素          // this.books.splice(index, 1);          // -------------------------         #// 方法二：通过filter方法进行删除\t\t          # 6.4  根据filter 方法 过滤出来id 不是要删除书籍的id           # 因为 filter 是替换数组不会修改原始数据 所以需要 把 不是要删除书籍的id  赋值给 books           this.books = this.books.filter(function(item)&#123;            return item.id != id;          &#125;);        &#125;      &#125;    &#125;);  &lt;/script&gt;\n\n\n\n常用特性应用场景1 过滤器\nVue.filter  定义一个全局过滤器\n\n &lt;tr :key=&#x27;item.id&#x27; v-for=&#x27;item in books&#x27;&gt;            &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;            &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;     \t\t&lt;!-- 1.3  调用过滤器 --&gt;            &lt;td&gt;&#123;&#123;item.date | format(&#x27;yyyy-MM-dd hh:mm:ss&#x27;)&#125;&#125;&lt;/td&gt;            &lt;td&gt;              &lt;a href=&quot;&quot; @click.prevent=&#x27;toEdit(item.id)&#x27;&gt;修改&lt;/a&gt;              &lt;span&gt;|&lt;/span&gt;              &lt;a href=&quot;&quot; @click.prevent=&#x27;deleteBook(item.id)&#x27;&gt;删除&lt;/a&gt;            &lt;/td&gt;&lt;/tr&gt;&lt;script&gt;    \t#1.1  Vue.filter  定义一个全局过滤器\t    Vue.filter(&#x27;format&#x27;, function(value, arg) &#123;              function dateFormat(date, format) &#123;                if (typeof date === &quot;string&quot;) &#123;                  var mts = date.match(/(\\/Date\\((\\d+)\\)\\/)/);                  if (mts &amp;&amp; mts.length &gt;= 3) &#123;                    date = parseInt(mts[2]);                  &#125;                &#125;                date = new Date(date);                if (!date || date.toUTCString() == &quot;Invalid Date&quot;) &#123;                  return &quot;&quot;;                &#125;                var map = &#123;                  &quot;M&quot;: date.getMonth() + 1, //月份                   &quot;d&quot;: date.getDate(), //日                   &quot;h&quot;: date.getHours(), //小时                   &quot;m&quot;: date.getMinutes(), //分                   &quot;s&quot;: date.getSeconds(), //秒                   &quot;q&quot;: Math.floor((date.getMonth() + 3) / 3), //季度                   &quot;S&quot;: date.getMilliseconds() //毫秒                 &#125;;                format = format.replace(/([yMdhmsqS])+/g, function(all, t) &#123;                  var v = map[t];                  if (v !== undefined) &#123;                    if (all.length &gt; 1) &#123;                      v = &#x27;0&#x27; + v;                      v = v.substr(v.length - 2);                    &#125;                    return v;                  &#125; else if (t === &#x27;y&#x27;) &#123;                    return (date.getFullYear() + &#x27;&#x27;).substr(4 - all.length);                  &#125;                  return all;                &#125;);                return format;              &#125;              return dateFormat(value, arg);            &#125;)#1.2  提供的数据 包含一个时间戳   为毫秒数   [&#123;          id: 1,          name: &#x27;三国演义&#x27;,          date: 2525609975000        &#125;,&#123;          id: 2,          name: &#x27;水浒传&#x27;,          date: 2525609975000        &#125;,&#123;          id: 3,          name: &#x27;红楼梦&#x27;,          date: 2525609975000        &#125;,&#123;          id: 4,          name: &#x27;西游记&#x27;,          date: 2525609975000        &#125;];&lt;/script&gt;\n\n2 自定义指令\n让表单自动获取焦点\n通过Vue.directive 自定义指定\n\n&lt;!-- 2.2  通过v-自定义属性名 调用自定义指令 --&gt;&lt;input type=&quot;text&quot; id=&quot;id&quot; v-model=&#x27;id&#x27; :disabled=&quot;flag&quot; v-focus&gt;&lt;script&gt;    # 2.1   通过Vue.directive 自定义指定\tVue.directive(&#x27;focus&#x27;, &#123;      inserted: function (el) &#123;        el.focus();      &#125;    &#125;);&lt;/script&gt;\n\n3 计算属性\n通过计算属性计算图书的总数\n图书的总数就是计算数组的长度 \n\n\n\n &lt;div class=&quot;total&quot;&gt;        &lt;span&gt;图书总数：&lt;/span&gt;     \t&lt;!-- 3.2 在页面上 展示出来 --&gt;        &lt;span&gt;&#123;&#123;total&#125;&#125;&lt;/span&gt;&lt;/div&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    /*      计算属性与方法的区别:计算属性是基于依赖进行缓存的，而方法不缓存    */    var vm = new Vue(&#123;      data: &#123;        flag: false,        submitFlag: false,        id: &#x27;&#x27;,        name: &#x27;&#x27;,        books: []      &#125;,      computed: &#123;        total: function()&#123;          // 3.1  计算图书的总数          return this.books.length;        &#125;      &#125;,    &#125;);  &lt;/script&gt;\n\n\n\n生命周期day03组件\n组件 (Component) 是 Vue.js 最强大的功能之一\n组件可以扩展 HTML 元素，封装可重用的代\n\n组件注册全局注册\nVue.component(‘组件名称’, { })     第1个参数是标签名称，第2个参数是一个选项对象\n全局组件注册后，任何vue实例都可以用\n\n组件基础用&lt;div id=&quot;example&quot;&gt;  &lt;!-- 2、 组件使用 组件名称 是以HTML标签的形式使用  --&gt;    &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;    //   注册组件     // 1、 my-component 就是组件中自定义的标签名\tVue.component(&#x27;my-component&#x27;, &#123;      template: &#x27;&lt;div&gt;A custom component!&lt;/div&gt;&#x27;    &#125;)    // 创建根实例    new Vue(&#123;      el: &#x27;#example&#x27;    &#125;)&lt;/script&gt;\n\n组件注意事项\n组件参数的data值必须是函数同时这个函数要求返回一个对象 \n组件模板必须是单个根元素\n组件模板的内容可以是模板字符串\n\n  &lt;div id=&quot;app&quot;&gt;     &lt;!-- \t\t4、  组件可以重复使用多次 \t      因为data中返回的是一个对象所以每个组件中的数据是私有的\t\t  即每个实例可以维护一份被返回对象的独立的拷贝   \t--&gt;     &lt;button-counter&gt;&lt;/button-counter&gt;    &lt;button-counter&gt;&lt;/button-counter&gt;    &lt;button-counter&gt;&lt;/button-counter&gt;      &lt;!-- 8、必须使用短横线的方式使用组件 --&gt;     &lt;hello-world&gt;&lt;/hello-world&gt;  &lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;\t//5  如果使用驼峰式命名组件，那么在使用组件的时候，只能在字符串模板中用驼峰的方式使用组件，    // 7、但是在普通的标签模板中，必须使用短横线的方式使用组件     Vue.component(&#x27;HelloWorld&#x27;, &#123;      data: function()&#123;        return &#123;          msg: &#x27;HelloWorld&#x27;        &#125;      &#125;,      template: &#x27;&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&#x27;    &#125;);                Vue.component(&#x27;button-counter&#x27;, &#123;      // 1、组件参数的data值必须是函数       // 同时这个函数要求返回一个对象        data: function()&#123;        return &#123;          count: 0        &#125;      &#125;,      //  2、组件模板必须是单个根元素      //  3、组件模板的内容可以是模板字符串        template: `        &lt;div&gt;          &lt;button @click=&quot;handle&quot;&gt;点击了&#123;&#123;count&#125;&#125;次&lt;/button&gt;          &lt;button&gt;测试123&lt;/button&gt;\t\t\t#  6 在字符串模板中可以使用驼峰的方式使用组件\t\t\t   &lt;HelloWorld&gt;&lt;/HelloWorld&gt;        &lt;/div&gt;      `,      methods: &#123;        handle: function()&#123;          this.count += 2;        &#125;      &#125;    &#125;)    var vm = new Vue(&#123;      el: &#x27;#app&#x27;,      data: &#123;              &#125;    &#125;);  &lt;/script&gt;\n\n\n\n局部注册\n只能在当前注册它的vue实例中使用\n\n  &lt;div id=&quot;app&quot;&gt;      &lt;my-component&gt;&lt;/my-component&gt;  &lt;/div&gt;&lt;script&gt;    // 定义组件的模板    var Child = &#123;      template: &#x27;&lt;div&gt;A custom component!&lt;/div&gt;&#x27;    &#125;    new Vue(&#123;      //局部注册组件        components: &#123;        // &lt;my-component&gt; 将只在父模板可用  一定要在实例上注册了才能在html文件中使用        &#x27;my-component&#x27;: Child      &#125;    &#125;) &lt;/script&gt;\n\n\n\nVue 调试工具Vue组件之间传值父组件向子组件传值\n父组件发送的形式是以属性的形式绑定值到子组件身上。\n然后子组件用属性props接收\n在props中使用驼峰形式，模板中需要使用短横线的形式字符串形式的模板中没有这个限制\n\n &lt;div id=&quot;app&quot;&gt;   &lt;div&gt;&#123;&#123;pmsg&#125;&#125;&lt;/div&gt;    &lt;!--1、menu-item  在 APP中嵌套着 故 menu-item   为  子组件      --&gt;    &lt;!-- 给子组件传入一个静态的值 --&gt;   &lt;menu-item title=&#x27;来自父组件的值&#x27;&gt;&lt;/menu-item&gt;   &lt;!-- 2、 需要动态的数据的时候 需要属性绑定的形式设置 此时 ptitle  来自父组件data 中的数据 . \t  传的值可以是数字、对象、数组等等--&gt;   &lt;menu-item :title=&#x27;ptitle&#x27; content=&#x27;hello&#x27;&gt;&lt;/menu-item&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt;   Vue.component(&#x27;menu-item&#x27;, &#123;     // 3、 子组件用属性props接收父组件传递过来的数据       props: [&#x27;title&#x27;, &#x27;content&#x27;],     data: function() &#123;       return &#123;         msg: &#x27;子组件本身的数据&#x27;       &#125;     &#125;,     template: &#x27;&lt;div&gt;&#123;&#123;msg + &quot;----&quot; + title + &quot;-----&quot; + content&#125;&#125;&lt;/div&gt;&#x27;   &#125;);   var vm = new Vue(&#123;     el: &#x27;#app&#x27;,     data: &#123;       pmsg: &#x27;父组件中内容&#x27;,       ptitle: &#x27;动态绑定属性&#x27;     &#125;   &#125;); &lt;/script&gt;\n\n子组件向父组件传值\n子组件用$emit()触发事件\n$emit()  第一个参数为 自定义的事件名称     第二个参数为需要传递的数据\n父组件用v-on 监听子组件的事件\n\n&lt;div id=&quot;app&quot;&gt;   &lt;div :style=&#x27;&#123;fontSize: fontSize + &quot;px&quot;&#125;&#x27;&gt;&#123;&#123;pmsg&#125;&#125;&lt;/div&gt;    &lt;!-- 2 父组件用v-on 监听子组件的事件\t这里 enlarge-text  是从 $emit 中的第一个参数对应   handle 为对应的事件处理函数\t--&gt;\t   &lt;menu-item :parr=&#x27;parr&#x27; @enlarge-text=&#x27;handle($event)&#x27;&gt;&lt;/menu-item&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;   /*     子组件向父组件传值-携带参数   */      Vue.component(&#x27;menu-item&#x27;, &#123;     props: [&#x27;parr&#x27;],     template: `       &lt;div&gt;         &lt;ul&gt;           &lt;li :key=&#x27;index&#x27; v-for=&#x27;(item,index) in parr&#x27;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;         &lt;/ul&gt;\t\t###  1、子组件用$emit()触发事件\t\t### 第一个参数为 自定义的事件名称   第二个参数为需要传递的数据           &lt;button @click=&#x27;$emit(&quot;enlarge-text&quot;, 5)&#x27;&gt;扩大父组件中字体大小&lt;/button&gt;         &lt;button @click=&#x27;$emit(&quot;enlarge-text&quot;, 10)&#x27;&gt;扩大父组件中字体大小&lt;/button&gt;       &lt;/div&gt;     `   &#125;);   var vm = new Vue(&#123;     el: &#x27;#app&#x27;,     data: &#123;       pmsg: &#x27;父组件中内容&#x27;,       parr: [&#x27;apple&#x27;,&#x27;orange&#x27;,&#x27;banana&#x27;],       fontSize: 10     &#125;,     methods: &#123;       handle: function(val)&#123;         // 扩大字体大小         this.fontSize += val;       &#125;     &#125;   &#125;); &lt;/script&gt;\n\n兄弟之间的传递\n兄弟之间传递数据需要借助于事件中心，通过事件中心传递数据   \n提供事件中心    var hub = new Vue()\n\n\n传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据)\n接收数据方，通过mounted(){} 钩子中  触发hub.$on()方法名\n销毁事件 通过hub.$off()方法名销毁之后无法进行传递数据\n\n&lt;div id=&quot;app&quot;&gt;   &lt;div&gt;父组件&lt;/div&gt;   &lt;div&gt;     &lt;button @click=&#x27;handle&#x27;&gt;销毁事件&lt;/button&gt;   &lt;/div&gt;   &lt;test-tom&gt;&lt;/test-tom&gt;   &lt;test-jerry&gt;&lt;/test-jerry&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;   /*     兄弟组件之间数据传递   */   //1、 提供事件中心   var hub = new Vue();   Vue.component(&#x27;test-tom&#x27;, &#123;     data: function()&#123;       return &#123;         num: 0       &#125;     &#125;,     template: `       &lt;div&gt;         &lt;div&gt;TOM:&#123;&#123;num&#125;&#125;&lt;/div&gt;         &lt;div&gt;           &lt;button @click=&#x27;handle&#x27;&gt;点击&lt;/button&gt;         &lt;/div&gt;       &lt;/div&gt;     `,     methods: &#123;       handle: function()&#123;         //2、传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据)   触发兄弟组件的事件         hub.$emit(&#x27;jerry-event&#x27;, 2);       &#125;     &#125;,     mounted: function() &#123;      // 3、接收数据方，通过mounted()&#123;&#125; 钩子中  触发hub.$on(方法名       hub.$on(&#x27;tom-event&#x27;, (val) =&gt; &#123;         this.num += val;       &#125;);     &#125;   &#125;);   Vue.component(&#x27;test-jerry&#x27;, &#123;     data: function()&#123;       return &#123;         num: 0       &#125;     &#125;,     template: `       &lt;div&gt;         &lt;div&gt;JERRY:&#123;&#123;num&#125;&#125;&lt;/div&gt;         &lt;div&gt;           &lt;button @click=&#x27;handle&#x27;&gt;点击&lt;/button&gt;         &lt;/div&gt;       &lt;/div&gt;     `,     methods: &#123;       handle: function()&#123;         //2、传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据)   触发兄弟组件的事件         hub.$emit(&#x27;tom-event&#x27;, 1);       &#125;     &#125;,     mounted: function() &#123;       // 3、接收数据方，通过mounted()&#123;&#125; 钩子中  触发hub.$on()方法名       hub.$on(&#x27;jerry-event&#x27;, (val) =&gt; &#123;         this.num += val;       &#125;);     &#125;   &#125;);   var vm = new Vue(&#123;     el: &#x27;#app&#x27;,     data: &#123;            &#125;,     methods: &#123;       handle: function()&#123;         //4、销毁事件 通过hub.$off()方法名销毁之后无法进行传递数据           hub.$off(&#x27;tom-event&#x27;);         hub.$off(&#x27;jerry-event&#x27;);       &#125;     &#125;   &#125;); &lt;/script&gt;\n\n组件插槽\n组件的最大特性就是复用性，而用好插槽能大大提高组件的可复用能力\n\n匿名插槽  &lt;div id=&quot;app&quot;&gt;    &lt;!-- 这里的所有组件标签中嵌套的内容会替换掉slot  如果不传值 则使用 slot 中的默认值  --&gt;      &lt;alert-box&gt;有bug发生&lt;/alert-box&gt;    &lt;alert-box&gt;有一个警告&lt;/alert-box&gt;    &lt;alert-box&gt;&lt;/alert-box&gt;  &lt;/div&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    /*      组件插槽：父组件向子组件传递内容    */    Vue.component(&#x27;alert-box&#x27;, &#123;      template: `        &lt;div&gt;          &lt;strong&gt;ERROR:&lt;/strong&gt;\t\t# 当组件渲染的时候，这个 &lt;slot&gt; 元素将会被替换为“组件标签中嵌套的内容”。\t\t# 插槽内可以包含任何模板代码，包括 HTML          &lt;slot&gt;默认内容&lt;/slot&gt;        &lt;/div&gt;      `    &#125;);    var vm = new Vue(&#123;      el: &#x27;#app&#x27;,      data: &#123;              &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n具名插槽\n具有名字的插槽 \n使用  中的 “name” 属性绑定元素\n\n  &lt;div id=&quot;app&quot;&gt;    &lt;base-layout&gt;       &lt;!-- 2、 通过slot属性来指定, 这个slot的值必须和下面slot组件得name值对应上\t\t\t\t如果没有匹配到 则放到匿名的插槽中   --&gt;       &lt;p slot=&#x27;header&#x27;&gt;标题信息&lt;/p&gt;      &lt;p&gt;主要内容1&lt;/p&gt;      &lt;p&gt;主要内容2&lt;/p&gt;      &lt;p slot=&#x27;footer&#x27;&gt;底部信息信息&lt;/p&gt;    &lt;/base-layout&gt;    &lt;base-layout&gt;      &lt;!-- 注意点：template临时的包裹标签最终不会渲染到页面上     --&gt;        &lt;template slot=&#x27;header&#x27;&gt;        &lt;p&gt;标题信息1&lt;/p&gt;        &lt;p&gt;标题信息2&lt;/p&gt;      &lt;/template&gt;      &lt;p&gt;主要内容1&lt;/p&gt;      &lt;p&gt;主要内容2&lt;/p&gt;      &lt;template slot=&#x27;footer&#x27;&gt;        &lt;p&gt;底部信息信息1&lt;/p&gt;        &lt;p&gt;底部信息信息2&lt;/p&gt;      &lt;/template&gt;    &lt;/base-layout&gt;  &lt;/div&gt;  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    /*      具名插槽    */    Vue.component(&#x27;base-layout&#x27;, &#123;      template: `        &lt;div&gt;          &lt;header&gt;\t\t\t###\t1、 使用 &lt;slot&gt; 中的 &quot;name&quot; 属性绑定元素 指定当前插槽的名字            &lt;slot name=&#x27;header&#x27;&gt;&lt;/slot&gt;          &lt;/header&gt;          &lt;main&gt;            &lt;slot&gt;&lt;/slot&gt;          &lt;/main&gt;          &lt;footer&gt;\t\t\t###  注意点： \t\t\t###  具名插槽的渲染顺序，完全取决于模板，而不是取决于父组件中元素的顺序            &lt;slot name=&#x27;footer&#x27;&gt;&lt;/slot&gt;          &lt;/footer&gt;        &lt;/div&gt;      `    &#125;);    var vm = new Vue(&#123;      el: &#x27;#app&#x27;,      data: &#123;              &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n作用域插槽\n父组件对子组件加工处理\n既可以复用子组件的slot，又可以使slot内容不一致\n\n  &lt;div id=&quot;app&quot;&gt;    &lt;!-- \t\t1、当我们希望li 的样式由外部使用组件的地方定义，因为可能有多种地方要使用该组件，\t\t但样式希望不一样 这个时候我们需要使用作用域插槽 \t\t\t--&gt;      &lt;fruit-list :list=&#x27;list&#x27;&gt;       &lt;!-- 2、 父组件中使用了&lt;template&gt;元素,而且包含scope=&quot;slotProps&quot;,\t\t\tslotProps在这里只是临时变量   \t\t---&gt; \t      &lt;template slot-scope=&#x27;slotProps&#x27;&gt;        &lt;strong v-if=&#x27;slotProps.info.id==3&#x27; class=&quot;current&quot;&gt;            &#123;&#123;slotProps.info.name&#125;&#125;\t\t                  &lt;/strong&gt;        &lt;span v-else&gt;&#123;&#123;slotProps.info.name&#125;&#125;&lt;/span&gt;      &lt;/template&gt;    &lt;/fruit-list&gt;  &lt;/div&gt;  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    /*      作用域插槽    */    Vue.component(&#x27;fruit-list&#x27;, &#123;      props: [&#x27;list&#x27;],      template: `        &lt;div&gt;          &lt;li :key=&#x27;item.id&#x27; v-for=&#x27;item in list&#x27;&gt;\t\t\t###  3、 在子组件模板中,&lt;slot&gt;元素上有一个类似props传递数据给组件的写法msg=&quot;xxx&quot;,\t\t\t###   插槽可以提供一个默认内容，如果如果父组件没有为这个插槽提供了内容，会显示默认的内容。\t\t\t\t\t如果父组件为这个插槽提供了内容，则默认的内容会被替换掉            &lt;slot :info=&#x27;item&#x27;&gt;&#123;&#123;item.name&#125;&#125;&lt;/slot&gt;          &lt;/li&gt;        &lt;/div&gt;      `    &#125;);    var vm = new Vue(&#123;      el: &#x27;#app&#x27;,      data: &#123;        list: [&#123;          id: 1,          name: &#x27;apple&#x27;        &#125;,&#123;          id: 2,          name: &#x27;orange&#x27;        &#125;,&#123;          id: 3,          name: &#x27;banana&#x27;        &#125;]      &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n购物车案例1.  实现组件化布局\n把静态页面转换成组件化模式\n把组件渲染到页面上\n\n&lt;div id=&quot;app&quot;&gt;   &lt;div class=&quot;container&quot;&gt;     &lt;!-- 2、把组件渲染到页面上 --&gt;      &lt;my-cart&gt;&lt;/my-cart&gt;   &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;   # 1、 把静态页面转换成组件化模式   # 1.1  标题组件    var CartTitle = &#123;     template: `       &lt;div class=&quot;title&quot;&gt;我的商品&lt;/div&gt;     `   &#125;   # 1.2  商品列表组件    var CartList = &#123;     #  注意点 ：  组件模板必须是单个根元素       template: `       &lt;div&gt;         &lt;div class=&quot;item&quot;&gt;           &lt;img src=&quot;img/a.jpg&quot;/&gt;           &lt;div class=&quot;name&quot;&gt;&lt;/div&gt;           &lt;div class=&quot;change&quot;&gt;             &lt;a href=&quot;&quot;&gt;－&lt;/a&gt;             &lt;input type=&quot;text&quot; class=&quot;num&quot; /&gt;             &lt;a href=&quot;&quot;&gt;＋&lt;/a&gt;           &lt;/div&gt;           &lt;div class=&quot;del&quot;&gt;×&lt;/div&gt;         &lt;/div&gt;         &lt;div class=&quot;item&quot;&gt;           &lt;img src=&quot;img/b.jpg&quot;/&gt;           &lt;div class=&quot;name&quot;&gt;&lt;/div&gt;           &lt;div class=&quot;change&quot;&gt;             &lt;a href=&quot;&quot;&gt;－&lt;/a&gt;             &lt;input type=&quot;text&quot; class=&quot;num&quot; /&gt;             &lt;a href=&quot;&quot;&gt;＋&lt;/a&gt;           &lt;/div&gt;           &lt;div class=&quot;del&quot;&gt;×&lt;/div&gt;         &lt;/div&gt;         &lt;div class=&quot;item&quot;&gt;           &lt;img src=&quot;img/c.jpg&quot;/&gt;           &lt;div class=&quot;name&quot;&gt;&lt;/div&gt;           &lt;div class=&quot;change&quot;&gt;             &lt;a href=&quot;&quot;&gt;－&lt;/a&gt;             &lt;input type=&quot;text&quot; class=&quot;num&quot; /&gt;             &lt;a href=&quot;&quot;&gt;＋&lt;/a&gt;           &lt;/div&gt;           &lt;div class=&quot;del&quot;&gt;×&lt;/div&gt;         &lt;/div&gt;         &lt;div class=&quot;item&quot;&gt;           &lt;img src=&quot;img/d.jpg&quot;/&gt;           &lt;div class=&quot;name&quot;&gt;&lt;/div&gt;           &lt;div class=&quot;change&quot;&gt;             &lt;a href=&quot;&quot;&gt;－&lt;/a&gt;             &lt;input type=&quot;text&quot; class=&quot;num&quot; /&gt;             &lt;a href=&quot;&quot;&gt;＋&lt;/a&gt;           &lt;/div&gt;           &lt;div class=&quot;del&quot;&gt;×&lt;/div&gt;         &lt;/div&gt;         &lt;div class=&quot;item&quot;&gt;           &lt;img src=&quot;img/e.jpg&quot;/&gt;           &lt;div class=&quot;name&quot;&gt;&lt;/div&gt;           &lt;div class=&quot;change&quot;&gt;             &lt;a href=&quot;&quot;&gt;－&lt;/a&gt;             &lt;input type=&quot;text&quot; class=&quot;num&quot; /&gt;             &lt;a href=&quot;&quot;&gt;＋&lt;/a&gt;           &lt;/div&gt;           &lt;div class=&quot;del&quot;&gt;×&lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     `   &#125;   # 1.3  商品结算组件    var CartTotal = &#123;     template: `       &lt;div class=&quot;total&quot;&gt;         &lt;span&gt;总价：123&lt;/span&gt;         &lt;button&gt;结算&lt;/button&gt;       &lt;/div&gt;     `   &#125;   ## 1.4  定义一个全局组件 my-cart   Vue.component(&#x27;my-cart&#x27;,&#123;     ##  1.6 引入子组件       template: `       &lt;div class=&#x27;cart&#x27;&gt;         &lt;cart-title&gt;&lt;/cart-title&gt;         &lt;cart-list&gt;&lt;/cart-list&gt;         &lt;cart-total&gt;&lt;/cart-total&gt;       &lt;/div&gt;     `,     # 1.5  注册子组件        components: &#123;       &#x27;cart-title&#x27;: CartTitle,       &#x27;cart-list&#x27;: CartList,       &#x27;cart-total&#x27;: CartTotal     &#125;   &#125;);   var vm = new Vue(&#123;     el: &#x27;#app&#x27;,     data: &#123;     &#125;   &#125;); &lt;/script&gt;\n\n2、实现 标题和结算功能组件\n标题组件实现动态渲染\n从父组件把标题数据传递过来 即 父向子组件传值\n把传递过来的数据渲染到页面上  \n\n\n结算功能组件\n从父组件把商品列表list 数据传递过来 即 父向子组件传值\n把传递过来的数据计算最终价格渲染到页面上  \n\n\n\n&lt;div id=&quot;app&quot;&gt;   &lt;div class=&quot;container&quot;&gt;     &lt;my-cart&gt;&lt;/my-cart&gt;   &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;    # 2.2  标题组件     子组件通过props形式接收父组件传递过来的uname数据   var CartTitle = &#123;     props: [&#x27;uname&#x27;],     template: `       &lt;div class=&quot;title&quot;&gt;&#123;&#123;uname&#125;&#125;的商品&lt;/div&gt;     `   &#125;# 2.3  商品结算组件  子组件通过props形式接收父组件传递过来的list数据      var CartTotal = &#123;     props: [&#x27;list&#x27;],     template: `       &lt;div class=&quot;total&quot;&gt;         &lt;span&gt;总价：&#123;&#123;total&#125;&#125;&lt;/span&gt;         &lt;button&gt;结算&lt;/button&gt;       &lt;/div&gt;     `,     computed: &#123;       # 2.4    计算商品的总价  并渲染到页面上        total: function() &#123;         var t = 0;         this.list.forEach(item =&gt; &#123;           t += item.price * item.num;         &#125;);         return t;       &#125;     &#125;   &#125;   Vue.component(&#x27;my-cart&#x27;,&#123;     data: function() &#123;       return &#123;         uname: &#x27;张三&#x27;,         list: [&#123;           id: 1,           name: &#x27;TCL彩电&#x27;,           price: 1000,           num: 1,           img: &#x27;img/a.jpg&#x27;         &#125;,&#123;           id: 2,           name: &#x27;机顶盒&#x27;,           price: 1000,           num: 1,           img: &#x27;img/b.jpg&#x27;         &#125;,&#123;           id: 3,           name: &#x27;海尔冰箱&#x27;,           price: 1000,           num: 1,           img: &#x27;img/c.jpg&#x27;         &#125;,&#123;           id: 4,           name: &#x27;小米手机&#x27;,           price: 1000,           num: 1,           img: &#x27;img/d.jpg&#x27;         &#125;,&#123;           id: 5,           name: &#x27;PPTV电视&#x27;,           price: 1000,           num: 2,           img: &#x27;img/e.jpg&#x27;         &#125;]       &#125;     &#125;,     #  2.1  父组件向子组件以属性传递的形式 传递数据     #   向 标题组件传递 uname 属性   向 商品结算组件传递 list  属性       template: `       &lt;div class=&#x27;cart&#x27;&gt;         &lt;cart-title :uname=&#x27;uname&#x27;&gt;&lt;/cart-title&gt;         &lt;cart-list&gt;&lt;/cart-list&gt;         &lt;cart-total :list=&#x27;list&#x27;&gt;&lt;/cart-total&gt;       &lt;/div&gt;     `,     components: &#123;       &#x27;cart-title&#x27;: CartTitle,       &#x27;cart-list&#x27;: CartList,       &#x27;cart-total&#x27;: CartTotal     &#125;   &#125;);   var vm = new Vue(&#123;     el: &#x27;#app&#x27;,     data: &#123;     &#125;   &#125;); &lt;/script&gt;\n\n3.  实现列表组件删除功能\n从父组件把商品列表list 数据传递过来 即 父向子组件传值\n把传递过来的数据渲染到页面上    \n点击删除按钮的时候删除对应的数据 \n给按钮添加点击事件把需要删除的id传递过来  \n子组件中不推荐操作父组件的数据有可能多个子组件使用父组件的数据  我们需要把数据传递给父组件让父组件操作数据 \n父组件删除对应的数据\n\n\n\n\n\n &lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;my-cart&gt;&lt;/my-cart&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;  &lt;script type=&quot;text/javascript&quot;&gt;        var CartTitle = &#123;      props: [&#x27;uname&#x27;],      template: `        &lt;div class=&quot;title&quot;&gt;&#123;&#123;uname&#125;&#125;的商品&lt;/div&gt;      `    &#125;    #  3.2 把列表数据动态渲染到页面上      var CartList = &#123;      props: [&#x27;list&#x27;],      template: `        &lt;div&gt;          &lt;div :key=&#x27;item.id&#x27; v-for=&#x27;item in list&#x27; class=&quot;item&quot;&gt;            &lt;img :src=&quot;item.img&quot;/&gt;            &lt;div class=&quot;name&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;            &lt;div class=&quot;change&quot;&gt;              &lt;a href=&quot;&quot;&gt;－&lt;/a&gt;              &lt;input type=&quot;text&quot; class=&quot;num&quot; /&gt;              &lt;a href=&quot;&quot;&gt;＋&lt;/a&gt;            &lt;/div&gt;\t\t\t# 3.3  给按钮添加点击事件把需要删除的id传递过来            &lt;div class=&quot;del&quot; @click=&#x27;del(item.id)&#x27;&gt;×&lt;/div&gt;          &lt;/div&gt;        &lt;/div&gt;      `,      methods: &#123;        del: function(id)&#123;           # 3.4 子组件中不推荐操作父组件的数据有可能多个子组件使用父组件的数据           # \t  我们需要把数据传递给父组件 让父组件操作数据           this.$emit(&#x27;cart-del&#x27;, id);        &#125;      &#125;    &#125;    var CartTotal = &#123;      props: [&#x27;list&#x27;],      template: `        &lt;div class=&quot;total&quot;&gt;          &lt;span&gt;总价：&#123;&#123;total&#125;&#125;&lt;/span&gt;          &lt;button&gt;结算&lt;/button&gt;        &lt;/div&gt;      `,      computed: &#123;        total: function() &#123;          // 计算商品的总价          var t = 0;          this.list.forEach(item =&gt; &#123;            t += item.price * item.num;          &#125;);          return t;        &#125;      &#125;    &#125;    Vue.component(&#x27;my-cart&#x27;,&#123;      data: function() &#123;        return &#123;          uname: &#x27;张三&#x27;,          list: [&#123;            id: 1,            name: &#x27;TCL彩电&#x27;,            price: 1000,            num: 1,            img: &#x27;img/a.jpg&#x27;          &#125;,&#123;            id: 2,            name: &#x27;机顶盒&#x27;,            price: 1000,            num: 1,            img: &#x27;img/b.jpg&#x27;          &#125;,&#123;            id: 3,            name: &#x27;海尔冰箱&#x27;,            price: 1000,            num: 1,            img: &#x27;img/c.jpg&#x27;          &#125;,&#123;            id: 4,            name: &#x27;小米手机&#x27;,            price: 1000,            num: 1,            img: &#x27;img/d.jpg&#x27;          &#125;,&#123;            id: 5,            name: &#x27;PPTV电视&#x27;,            price: 1000,            num: 2,            img: &#x27;img/e.jpg&#x27;          &#125;]        &#125;      &#125;,      # 3.1 从父组件把商品列表list 数据传递过来 即 父向子组件传值        template: `        &lt;div class=&#x27;cart&#x27;&gt;          &lt;cart-title :uname=&#x27;uname&#x27;&gt;&lt;/cart-title&gt;\t\t  #  3.5  父组件通过事件绑定 接收子组件传递过来的数据           &lt;cart-list :list=&#x27;list&#x27; @cart-del=&#x27;delCart($event)&#x27;&gt;&lt;/cart-list&gt;          &lt;cart-total :list=&#x27;list&#x27;&gt;&lt;/cart-total&gt;        &lt;/div&gt;      `,      components: &#123;        &#x27;cart-title&#x27;: CartTitle,        &#x27;cart-list&#x27;: CartList,        &#x27;cart-total&#x27;: CartTotal      &#125;,      methods: &#123;        # 3.6    根据id删除list中对应的数据                delCart: function(id) &#123;          // 1、找到id所对应数据的索引          var index = this.list.findIndex(item=&gt;&#123;            return item.id == id;          &#125;);          // 2、根据索引删除对应数据          this.list.splice(index, 1);        &#125;      &#125;    &#125;);    var vm = new Vue(&#123;      el: &#x27;#app&#x27;,      data: &#123;      &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n4.   实现组件更新数据功能  上\n将输入框中的默认数据动态渲染出来\n输入框失去焦点的时候 更改商品的数量 \n子组件中不推荐操作数据 把这些数据传递给父组件 让父组件处理这些数据\n父组件中接收子组件传递过来的数据并处理 \n\n&lt;div id=&quot;app&quot;&gt;   &lt;div class=&quot;container&quot;&gt;     &lt;my-cart&gt;&lt;/my-cart&gt;   &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;      var CartTitle = &#123;     props: [&#x27;uname&#x27;],     template: `       &lt;div class=&quot;title&quot;&gt;&#123;&#123;uname&#125;&#125;的商品&lt;/div&gt;     `   &#125;   var CartList = &#123;     props: [&#x27;list&#x27;],     template: `       &lt;div&gt;         &lt;div :key=&#x27;item.id&#x27; v-for=&#x27;item in list&#x27; class=&quot;item&quot;&gt;           &lt;img :src=&quot;item.img&quot;/&gt;           &lt;div class=&quot;name&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;           &lt;div class=&quot;change&quot;&gt;             &lt;a href=&quot;&quot;&gt;－&lt;/a&gt;\t\t\t# 1. 将输入框中的默认数据动态渲染出来\t\t\t# 2. 输入框失去焦点的时候 更改商品的数量  需要将当前商品的id 传递过来             &lt;input type=&quot;text&quot; class=&quot;num&quot; :value=&#x27;item.num&#x27; @blur=&#x27;changeNum(item.id, $event)&#x27;/&gt;             &lt;a href=&quot;&quot;&gt;＋&lt;/a&gt;           &lt;/div&gt;           &lt;div class=&quot;del&quot; @click=&#x27;del(item.id)&#x27;&gt;×&lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     `,     methods: &#123;       changeNum: function(id, event)&#123;         # 3 子组件中不推荐操作数据  因为别的组件可能也引用了这些数据         #  把这些数据传递给父组件 让父组件处理这些数据         this.$emit(&#x27;change-num&#x27;, &#123;           id: id,           num: event.target.value         &#125;);       &#125;,       del: function(id)&#123;         // 把id传递给父组件         this.$emit(&#x27;cart-del&#x27;, id);       &#125;     &#125;   &#125;   var CartTotal = &#123;     props: [&#x27;list&#x27;],     template: `       &lt;div class=&quot;total&quot;&gt;         &lt;span&gt;总价：&#123;&#123;total&#125;&#125;&lt;/span&gt;         &lt;button&gt;结算&lt;/button&gt;       &lt;/div&gt;     `,     computed: &#123;       total: function() &#123;         // 计算商品的总价         var t = 0;         this.list.forEach(item =&gt; &#123;           t += item.price * item.num;         &#125;);         return t;       &#125;     &#125;   &#125;   Vue.component(&#x27;my-cart&#x27;,&#123;     data: function() &#123;       return &#123;         uname: &#x27;张三&#x27;,         list: [&#123;           id: 1,           name: &#x27;TCL彩电&#x27;,           price: 1000,           num: 1,           img: &#x27;img/a.jpg&#x27;         &#125;]     &#125;,     template: `       &lt;div class=&#x27;cart&#x27;&gt;         &lt;cart-title :uname=&#x27;uname&#x27;&gt;&lt;/cart-title&gt;\t\t# 4  父组件中接收子组件传递过来的数据          &lt;cart-list :list=&#x27;list&#x27; @change-num=&#x27;changeNum($event)&#x27; @cart-del=&#x27;delCart($event)&#x27;&gt;&lt;/cart-list&gt;         &lt;cart-total :list=&#x27;list&#x27;&gt;&lt;/cart-total&gt;       &lt;/div&gt;     `,     components: &#123;       &#x27;cart-title&#x27;: CartTitle,       &#x27;cart-list&#x27;: CartList,       &#x27;cart-total&#x27;: CartTotal     &#125;,     methods: &#123;       changeNum: function(val) &#123;         //4.1 根据子组件传递过来的数据，跟新list中对应的数据         this.list.some(item=&gt;&#123;           if(item.id == val.id) &#123;             item.num = val.num;             // 终止遍历             return true;           &#125;         &#125;);       &#125;,       delCart: function(id) &#123;         // 根据id删除list中对应的数据         // 1、找到id所对应数据的索引         var index = this.list.findIndex(item=&gt;&#123;           return item.id == id;         &#125;);         // 2、根据索引删除对应数据         this.list.splice(index, 1);       &#125;     &#125;   &#125;);   var vm = new Vue(&#123;     el: &#x27;#app&#x27;,     data: &#123;     &#125;   &#125;); &lt;/script&gt;\n\n5. 实现组件更新数据功能  下\n子组件通过一个标识符来标记对用的用户点击  + - 或者输入框输入的内容\n父组件拿到标识符更新对应的组件\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;style type=&quot;text/css&quot;&gt;    .container &#123;    &#125;    .container .cart &#123;      width: 300px;      margin: auto;    &#125;    .container .title &#123;      background-color: lightblue;      height: 40px;      line-height: 40px;      text-align: center;      /*color: #fff;*/      &#125;    .container .total &#123;      background-color: #FFCE46;      height: 50px;      line-height: 50px;      text-align: right;    &#125;    .container .total button &#123;      margin: 0 10px;      background-color: #DC4C40;      height: 35px;      width: 80px;      border: 0;    &#125;    .container .total span &#123;      color: red;      font-weight: bold;    &#125;    .container .item &#123;      height: 55px;      line-height: 55px;      position: relative;      border-top: 1px solid #ADD8E6;    &#125;    .container .item img &#123;      width: 45px;      height: 45px;      margin: 5px;    &#125;    .container .item .name &#123;      position: absolute;      width: 90px;      top: 0;left: 55px;      font-size: 16px;    &#125;    .container .item .change &#123;      width: 100px;      position: absolute;      top: 0;      right: 50px;    &#125;    .container .item .change a &#123;      font-size: 20px;      width: 30px;      text-decoration:none;      background-color: lightgray;      vertical-align: middle;    &#125;    .container .item .change .num &#123;      width: 40px;      height: 25px;    &#125;    .container .item .del &#123;      position: absolute;      top: 0;      right: 0px;      width: 40px;      text-align: center;      font-size: 40px;      cursor: pointer;      color: red;    &#125;    .container .item .del:hover &#123;      background-color: orange;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;my-cart&gt;&lt;/my-cart&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;  &lt;script type=&quot;text/javascript&quot;&gt;        var CartTitle = &#123;      props: [&#x27;uname&#x27;],      template: `        &lt;div class=&quot;title&quot;&gt;&#123;&#123;uname&#125;&#125;的商品&lt;/div&gt;      `    &#125;    var CartList = &#123;      props: [&#x27;list&#x27;],      template: `        &lt;div&gt;          &lt;div :key=&#x27;item.id&#x27; v-for=&#x27;item in list&#x27; class=&quot;item&quot;&gt;            &lt;img :src=&quot;item.img&quot;/&gt;            &lt;div class=&quot;name&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;            &lt;div class=&quot;change&quot;&gt;\t\t\t  # 1.  + - 按钮绑定事件               &lt;a href=&quot;&quot; @click.prevent=&#x27;sub(item.id)&#x27;&gt;－&lt;/a&gt;              &lt;input type=&quot;text&quot; class=&quot;num&quot; :value=&#x27;item.num&#x27; @blur=&#x27;changeNum(item.id, $event)&#x27;/&gt;              &lt;a href=&quot;&quot; @click.prevent=&#x27;add(item.id)&#x27;&gt;＋&lt;/a&gt;            &lt;/div&gt;            &lt;div class=&quot;del&quot; @click=&#x27;del(item.id)&#x27;&gt;×&lt;/div&gt;          &lt;/div&gt;        &lt;/div&gt;      `,      methods: &#123;        changeNum: function(id, event)&#123;          this.$emit(&#x27;change-num&#x27;, &#123;            id: id,            type: &#x27;change&#x27;,            num: event.target.value          &#125;);        &#125;,        sub: function(id)&#123;          # 2 数量的增加和减少通过父组件来计算   每次都是加1 和 减1 不需要传递数量   父组件需要一个类型来判断 是 加一 还是减1  以及是输入框输入的数据  我们通过type 标识符来标记 不同的操作             this.$emit(&#x27;change-num&#x27;, &#123;            id: id,            type: &#x27;sub&#x27;          &#125;);        &#125;,        add: function(id)&#123;         # 2 数量的增加和减少通过父组件来计算   每次都是加1 和 减1 不需要传递数量   父组件需要一个类型来判断 是 加一 还是减1  以及是输入框输入的数据  我们通过type 标识符来标记 不同的操作          this.$emit(&#x27;change-num&#x27;, &#123;            id: id,            type: &#x27;add&#x27;          &#125;);        &#125;,        del: function(id)&#123;          // 把id传递给父组件          this.$emit(&#x27;cart-del&#x27;, id);        &#125;      &#125;    &#125;    var CartTotal = &#123;      props: [&#x27;list&#x27;],      template: `        &lt;div class=&quot;total&quot;&gt;          &lt;span&gt;总价：&#123;&#123;total&#125;&#125;&lt;/span&gt;          &lt;button&gt;结算&lt;/button&gt;        &lt;/div&gt;      `,      computed: &#123;        total: function() &#123;          // 计算商品的总价          var t = 0;          this.list.forEach(item =&gt; &#123;            t += item.price * item.num;          &#125;);          return t;        &#125;      &#125;    &#125;    Vue.component(&#x27;my-cart&#x27;,&#123;      data: function() &#123;        return &#123;          uname: &#x27;张三&#x27;,          list: [&#123;            id: 1,            name: &#x27;TCL彩电&#x27;,            price: 1000,            num: 1,            img: &#x27;img/a.jpg&#x27;          &#125;,&#123;            id: 2,            name: &#x27;机顶盒&#x27;,            price: 1000,            num: 1,            img: &#x27;img/b.jpg&#x27;          &#125;,&#123;            id: 3,            name: &#x27;海尔冰箱&#x27;,            price: 1000,            num: 1,            img: &#x27;img/c.jpg&#x27;          &#125;,&#123;            id: 4,            name: &#x27;小米手机&#x27;,            price: 1000,            num: 1,            img: &#x27;img/d.jpg&#x27;          &#125;,&#123;            id: 5,            name: &#x27;PPTV电视&#x27;,            price: 1000,            num: 2,            img: &#x27;img/e.jpg&#x27;          &#125;]        &#125;      &#125;,      template: `        &lt;div class=&#x27;cart&#x27;&gt;          &lt;cart-title :uname=&#x27;uname&#x27;&gt;&lt;/cart-title&gt;\t\t\t# 3 父组件通过事件监听   接收子组件的数据            &lt;cart-list :list=&#x27;list&#x27; @change-num=&#x27;changeNum($event)&#x27; @cart-del=&#x27;delCart($event)&#x27;&gt;&lt;/cart-list&gt;          &lt;cart-total :list=&#x27;list&#x27;&gt;&lt;/cart-total&gt;        &lt;/div&gt;      `,      components: &#123;        &#x27;cart-title&#x27;: CartTitle,        &#x27;cart-list&#x27;: CartList,        &#x27;cart-total&#x27;: CartTotal      &#125;,      methods: &#123;        changeNum: function(val) &#123;          #4 分为三种情况：输入框变更、加号变更、减号变更          if(val.type==&#x27;change&#x27;) &#123;            // 根据子组件传递过来的数据，跟新list中对应的数据            this.list.some(item=&gt;&#123;              if(item.id == val.id) &#123;                item.num = val.num;                // 终止遍历                return true;              &#125;            &#125;);          &#125;else if(val.type==&#x27;sub&#x27;)&#123;            // 减一操作            this.list.some(item=&gt;&#123;              if(item.id == val.id) &#123;                item.num -= 1;                // 终止遍历                return true;              &#125;            &#125;);          &#125;else if(val.type==&#x27;add&#x27;)&#123;            // 加一操作            this.list.some(item=&gt;&#123;              if(item.id == val.id) &#123;                item.num += 1;                // 终止遍历                return true;              &#125;            &#125;);          &#125;        &#125;      &#125;    &#125;);    var vm = new Vue(&#123;      el: &#x27;#app&#x27;,      data: &#123;      &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\nday04接口调用方式\n原生ajax\n基于jQuery的ajax\nfetch\naxios\n\n异步\nJavaScript的执行环境是「单线程」\n所谓单线程，是指JS引擎中负责解释和执行JavaScript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程\n异步模式可以一起执行多个任务\nJS中常见的异步调用\n定时任何\najax\n事件函数\n\n\n\npromise\n主要解决异步深层嵌套的问题\npromise 提供了简洁的API  使得异步操作更加容易\n\n &lt;script type=&quot;text/javascript&quot;&gt;  /*   1. Promise基本使用         我们使用new来构建一个Promise  Promise的构造函数接收一个参数，是函数，并且传入两个参数：\t\t   resolve，reject， 分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数  */  var p = new Promise(function(resolve, reject)&#123;    //2. 这里用于实现异步任务  setTimeout    setTimeout(function()&#123;      var flag = false;      if(flag) &#123;        //3. 正常情况        resolve(&#x27;hello&#x27;);      &#125;else&#123;        //4. 异常情况        reject(&#x27;出错了&#x27;);      &#125;    &#125;, 100);  &#125;);  //  5 Promise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数   //  在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了    p.then(function(data)&#123;    console.log(data)  &#125;,function(info)&#123;    console.log(info)  &#125;);&lt;/script&gt;\n\n基于Promise发送Ajax请求 &lt;script type=&quot;text/javascript&quot;&gt;   /*     基于Promise发送Ajax请求   */   function queryData(url) &#123;    #   1.1 创建一个Promise实例     var p = new Promise(function(resolve, reject)&#123;       var xhr = new XMLHttpRequest();       xhr.onreadystatechange = function()&#123;         if(xhr.readyState != 4) return;         if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;           # 1.2 处理正常的情况           resolve(xhr.responseText);         &#125;else&#123;           # 1.3 处理异常情况           reject(&#x27;服务器错误&#x27;);         &#125;       &#125;;       xhr.open(&#x27;get&#x27;, url);       xhr.send(null);     &#125;);     return p;   &#125;# 注意：  这里需要开启一个服务    # 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了   queryData(&#x27;http://localhost:3000/data&#x27;)     .then(function(data)&#123;       console.log(data)       #  1.4 想要继续链式编程下去 需要 return         return queryData(&#x27;http://localhost:3000/data1&#x27;);     &#125;)     .then(function(data)&#123;       console.log(data);       return queryData(&#x27;http://localhost:3000/data2&#x27;);     &#125;)     .then(function(data)&#123;       console.log(data)     &#125;); &lt;/script&gt;\n\nPromise  基本API实例方法.then()\n得到异步任务正确的结果\n\n.catch()\n获取异常信息\n\n.finally()\n成功与否都会执行（不是正式标准） \n\n&lt;script type=&quot;text/javascript&quot;&gt;  /*    Promise常用API-实例方法  */  // console.dir(Promise);  function foo() &#123;    return new Promise(function(resolve, reject)&#123;      setTimeout(function()&#123;        // resolve(123);        reject(&#x27;error&#x27;);      &#125;, 100);    &#125;)  &#125;  // foo()  //   .then(function(data)&#123;  //     console.log(data)  //   &#125;)  //   .catch(function(data)&#123;  //     console.log(data)  //   &#125;)  //   .finally(function()&#123;  //     console.log(&#x27;finished&#x27;)  //   &#125;);  // --------------------------  // 两种写法是等效的  foo()    .then(function(data)&#123;      # 得到异步任务正确的结果      console.log(data)    &#125;,function(data)&#123;      # 获取异常信息      console.log(data)    &#125;)    # 成功与否都会执行（不是正式标准）     .finally(function()&#123;      console.log(&#x27;finished&#x27;)    &#125;);&lt;/script&gt;\n\n静态方法.all()\nPromise.all方法接受一个数组作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定\n\n.race()\nPromise.race方法同样接受一个数组作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数\n\n​    \n&lt;script type=&quot;text/javascript&quot;&gt;  /*    Promise常用API-对象方法  */  // console.dir(Promise)  function queryData(url) &#123;    return new Promise(function(resolve, reject)&#123;      var xhr = new XMLHttpRequest();      xhr.onreadystatechange = function()&#123;        if(xhr.readyState != 4) return;        if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;          // 处理正常的情况          resolve(xhr.responseText);        &#125;else&#123;          // 处理异常情况          reject(&#x27;服务器错误&#x27;);        &#125;      &#125;;      xhr.open(&#x27;get&#x27;, url);      xhr.send(null);    &#125;);  &#125;  var p1 = queryData(&#x27;http://localhost:3000/a1&#x27;);  var p2 = queryData(&#x27;http://localhost:3000/a2&#x27;);  var p3 = queryData(&#x27;http://localhost:3000/a3&#x27;);   Promise.all([p1,p2,p3]).then(function(result)&#123;     //   all 中的参数  [p1,p2,p3]   和 返回的结果一 一对应[&quot;HELLO TOM&quot;, &quot;HELLO JERRY&quot;, &quot;HELLO SPIKE&quot;]     console.log(result) //[&quot;HELLO TOM&quot;, &quot;HELLO JERRY&quot;, &quot;HELLO SPIKE&quot;]   &#125;)  Promise.race([p1,p2,p3]).then(function(result)&#123;    // 由于p1执行较快，Promise的then()将获得结果&#x27;P1&#x27;。p2,p3仍在继续执行，但执行结果将被丢弃。    console.log(result) // &quot;HELLO TOM&quot;  &#125;)&lt;/script&gt;\n\nfetch\nFetch API是新的ajax解决方案 Fetch会返回Promise\nfetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。\nfetch(url, options).then(）\n\n&lt;script type=&quot;text/javascript&quot;&gt;  /*    Fetch API 基本用法    \tfetch(url).then()   \t第一个参数请求的路径   Fetch会返回Promise   所以我们可以使用then 拿到请求成功的结果   */  fetch(&#x27;http://localhost:3000/fdata&#x27;).then(function(data)&#123;    // text()方法属于fetchAPI的一部分，它返回一个Promise实例对象，用于获取后台返回的数据    return data.text();  &#125;).then(function(data)&#123;    //   在这个then里面我们能拿到最终的数据      console.log(data);  &#125;)&lt;/script&gt;\n\nfetch API  中的 HTTP  请求\nfetch(url, options).then(）\nHTTP协议，它给我们提供了很多的方法，如POST，GET，DELETE，UPDATE，PATCH和PUT\n默认的是 GET 请求\n需要在 options 对象中 指定对应的 method       method:请求使用的方法 \npost 和 普通 请求的时候 需要在options 中 设置  请求头 headers   和  body\n\n\n\n&lt;script type=&quot;text/javascript&quot;&gt;     /*           Fetch API 调用接口传递参数     */    #1.1 GET参数传递 - 传统URL  通过url  ？ 的形式传参      fetch(&#x27;http://localhost:3000/books?id=123&#x27;, &#123;         \t# get 请求可以省略不写 默认的是GET              method: &#x27;get&#x27;         &#125;)         .then(function(data) &#123;         \t# 它返回一个Promise实例对象，用于获取后台返回的数据             return data.text();         &#125;).then(function(data) &#123;         \t# 在这个then里面我们能拿到最终的数据               console.log(data)         &#125;);   #1.2  GET参数传递  restful形式的URL  通过/ 的形式传递参数  即  id = 456 和id后台的配置有关        fetch(&#x27;http://localhost:3000/books/456&#x27;, &#123;         \t# get 请求可以省略不写 默认的是GET              method: &#x27;get&#x27;         &#125;)         .then(function(data) &#123;             return data.text();         &#125;).then(function(data) &#123;             console.log(data)         &#125;);    #2.1  DELETE请求方式参数传递      删除id  是  id=789     fetch(&#x27;http://localhost:3000/books/789&#x27;, &#123;             method: &#x27;delete&#x27;         &#125;)         .then(function(data) &#123;             return data.text();         &#125;).then(function(data) &#123;             console.log(data)         &#125;);    #3 POST请求传参     fetch(&#x27;http://localhost:3000/books&#x27;, &#123;             method: &#x27;post&#x27;,         \t# 3.1  传递数据              body: &#x27;uname=lisi&amp;pwd=123&#x27;,         \t#  3.2  设置请求头              headers: &#123;                 &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;             &#125;         &#125;)         .then(function(data) &#123;             return data.text();         &#125;).then(function(data) &#123;             console.log(data)         &#125;);    # POST请求传参     fetch(&#x27;http://localhost:3000/books&#x27;, &#123;             method: &#x27;post&#x27;,             body: JSON.stringify(&#123;                 uname: &#x27;张三&#x27;,                 pwd: &#x27;456&#x27;             &#125;),             headers: &#123;                 &#x27;Content-Type&#x27;: &#x27;application/json&#x27;             &#125;         &#125;)         .then(function(data) &#123;             return data.text();         &#125;).then(function(data) &#123;             console.log(data)         &#125;);     # PUT请求传参     修改id 是 123 的      fetch(&#x27;http://localhost:3000/books/123&#x27;, &#123;             method: &#x27;put&#x27;,             body: JSON.stringify(&#123;                 uname: &#x27;张三&#x27;,                 pwd: &#x27;789&#x27;             &#125;),             headers: &#123;                 &#x27;Content-Type&#x27;: &#x27;application/json&#x27;             &#125;         &#125;)         .then(function(data) &#123;             return data.text();         &#125;).then(function(data) &#123;             console.log(data)         &#125;); &lt;/script&gt;\n\nfetchAPI 中 响应格式\n用fetch来获取数据，如果响应正常返回，我们首先看到的是一个response对象，其中包括返回的一堆原始字节，这些字节需要在收到后，需要我们通过调用方法将其转换为相应格式的数据，比如JSON，BLOB或者TEXT等等\n\n/*  Fetch响应结果的数据格式*/fetch(&#x27;http://localhost:3000/json&#x27;).then(function(data)&#123;  // return data.json();   //  将获取到的数据使用 json 转换对象  return data.text(); //  //  将获取到的数据 转换成字符串 &#125;).then(function(data)&#123;  // console.log(data.uname)  // console.log(typeof data)  var obj = JSON.parse(data);  console.log(obj.uname,obj.age,obj.gender)&#125;)\n\naxios\n基于promise用于浏览器和node.js的http客户端\n支持浏览器和node.js\n支持promise\n能拦截请求和响应\n自动转换JSON数据\n能转换请求和响应数据\n\naxios基础用法\nget和 delete请求传递参数\n通过传统的url  以 ? 的形式传递参数\nrestful 形式传递参数 \n通过params  形式传递参数 \n\n\npost  和 put  请求传递参数\n通过选项传递参数\n通过 URLSearchParams  传递参数 \n\n\n\n   # 1. 发送get 请求 axios.get(&#x27;http://localhost:3000/adata&#x27;).then(function(ret)&#123;      #  拿到 ret 是一个对象      所有的对象都存在 ret 的data 属性里面     // 注意data属性是固定的用法，用于获取后台的实际数据     // console.log(ret.data)     console.log(ret)   &#125;)# 2.  get 请求传递参数   # 2.1  通过传统的url  以 ? 的形式传递参数axios.get(&#x27;http://localhost:3000/axios?id=123&#x27;).then(function(ret)&#123;     console.log(ret.data)   &#125;)   # 2.2  restful 形式传递参数    axios.get(&#x27;http://localhost:3000/axios/123&#x27;).then(function(ret)&#123;     console.log(ret.data)   &#125;)# 2.3  通过params  形式传递参数    axios.get(&#x27;http://localhost:3000/axios&#x27;, &#123;     params: &#123;       id: 789     &#125;   &#125;).then(function(ret)&#123;     console.log(ret.data)   &#125;)#3 axios delete 请求传参     传参的形式和 get 请求一样   axios.delete(&#x27;http://localhost:3000/axios&#x27;, &#123;     params: &#123;       id: 111     &#125;   &#125;).then(function(ret)&#123;     console.log(ret.data)   &#125;)# 4  axios 的 post 请求   # 4.1  通过选项传递参数   axios.post(&#x27;http://localhost:3000/axios&#x27;, &#123;     uname: &#x27;lisi&#x27;,     pwd: 123   &#125;).then(function(ret)&#123;     console.log(ret.data)   &#125;)# 4.2  通过 URLSearchParams  传递参数    var params = new URLSearchParams();   params.append(&#x27;uname&#x27;, &#x27;zhangsan&#x27;);   params.append(&#x27;pwd&#x27;, &#x27;111&#x27;);   axios.post(&#x27;http://localhost:3000/axios&#x27;, params).then(function(ret)&#123;     console.log(ret.data)   &#125;)\t#5  axios put 请求传参   和 post 请求一样    axios.put(&#x27;http://localhost:3000/axios/123&#x27;, &#123;     uname: &#x27;lisi&#x27;,     pwd: 123   &#125;).then(function(ret)&#123;     console.log(ret.data)   &#125;)\n\naxios 全局配置#  配置公共的请求头 axios.defaults.baseURL = &#x27;https://api.example.com&#x27;;#  配置 超时时间axios.defaults.timeout = 2500;#  配置公共的请求头axios.defaults.headers.common[&#x27;Authorization&#x27;] = AUTH_TOKEN;# 配置公共的 post 的 Content-Typeaxios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded&#x27;;\n\naxios 拦截器\n请求拦截器\n请求拦截器的作用是在请求发送前进行一些操作\n例如在每个请求体里加上token，统一做了处理如果以后要改也非常容易\n\n\n\n\n响应拦截器\n响应拦截器的作用是在接收到响应后进行一些操作\n例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页\n\n\n\n\n\n# 1. 请求拦截器 axios.interceptors.request.use(function(config) &#123;     console.log(config.url)     # 1.1  任何请求都会经过这一步   在发送请求之前做些什么        config.headers.mytoken = &#x27;nihao&#x27;;     # 1.2  这里一定要return   否则配置不成功       return config;   &#125;, function(err)&#123;      #1.3 对请求错误做点什么         console.log(err)   &#125;)#2. 响应拦截器    axios.interceptors.response.use(function(res) &#123;     #2.1  在接收响应做些什么       var data = res.data;     return data;   &#125;, function(err)&#123;     #2.2 对响应错误做点什么       console.log(err)   &#125;)\n\nasync  和 await\nasync作为一个关键字放到函数前面\n任何一个async函数都会隐式返回一个promise\n\n\nawait关键字只能在使用async定义的函数中使用\n​    await后面可以直接跟一个 Promise实例对象\n​     await函数不能单独使用\n\n\nasync/await 让异步代码看起来、表现起来更像同步代码\n\n\t# 1.  async 基础用法   # 1.1 async作为一个关键字放到函数前面async function queryData() &#123;     # 1.2 await关键字只能在使用async定义的函数中使用      await后面可以直接跟一个 Promise实例对象     var ret = await new Promise(function(resolve, reject)&#123;       setTimeout(function()&#123;         resolve(&#x27;nihao&#x27;)       &#125;,1000);     &#125;)     // console.log(ret.data)     return ret;   &#125;# 1.3 任何一个async函数都会隐式返回一个promise   我们可以使用then 进行链式编程   queryData().then(function(data)&#123;     console.log(data)   &#125;)#2.  async    函数处理多个异步函数   axios.defaults.baseURL = &#x27;http://localhost:3000&#x27;;   async function queryData() &#123;     # 2.1  添加await之后 当前的await 返回结果之后才会执行后面的代码             var info = await axios.get(&#x27;async1&#x27;);     #2.2  让异步代码看起来、表现起来更像同步代码     var ret = await axios.get(&#x27;async2?info=&#x27; + info.data);     return ret.data;   &#125;   queryData().then(function(data)&#123;     console.log(data)   &#125;)\n\n图书列表案例1. 基于接口案例-获取图书列表\n导入axios   用来发送ajax \n把获取到的数据渲染到页面上 \n\n &lt;div id=&quot;app&quot;&gt;       &lt;div class=&quot;grid&quot;&gt;           &lt;table&gt;               &lt;thead&gt;                   &lt;tr&gt;                       &lt;th&gt;编号&lt;/th&gt;                       &lt;th&gt;名称&lt;/th&gt;                       &lt;th&gt;时间&lt;/th&gt;                       &lt;th&gt;操作&lt;/th&gt;                   &lt;/tr&gt;               &lt;/thead&gt;               &lt;tbody&gt;                   &lt;!-- 5.  把books  中的数据渲染到页面上   --&gt;                   &lt;tr :key=&#x27;item.id&#x27; v-for=&#x27;item in books&#x27;&gt;                       &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;                       &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;                       &lt;td&gt;&#123;&#123;item.date &#125;&#125;&lt;/td&gt;                       &lt;td&gt;                           &lt;a href=&quot;&quot;&gt;修改&lt;/a&gt;                           &lt;span&gt;|&lt;/span&gt;                           &lt;a href=&quot;&quot;&gt;删除&lt;/a&gt;                       &lt;/td&gt;                   &lt;/tr&gt;               &lt;/tbody&gt;           &lt;/table&gt;       &lt;/div&gt;   &lt;/div&gt;   &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;1.  导入axios      &lt;script type=&quot;text/javascript&quot; src=&quot;js/axios.js&quot;&gt;&lt;/script&gt;   &lt;script type=&quot;text/javascript&quot;&gt;       /*            图书管理-添加图书        */       # 2   配置公共的url地址  简化后面的调用方式       axios.defaults.baseURL = &#x27;http://localhost:3000/&#x27;;       axios.interceptors.response.use(function(res) &#123;           return res.data;       &#125;, function(error) &#123;           console.log(error)       &#125;);       var vm = new Vue(&#123;           el: &#x27;#app&#x27;,           data: &#123;               flag: false,               submitFlag: false,               id: &#x27;&#x27;,               name: &#x27;&#x27;,               books: []           &#125;,           methods: &#123;               # 3 定义一个方法 用来发送 ajax                # 3.1  使用 async  来 让异步的代码  以同步的形式书写                queryData: async function() &#123;                   // 调用后台接口获取图书列表数据                   // var ret = await axios.get(&#x27;books&#x27;);                   // this.books = ret.data;\t\t\t\t# 3.2  发送ajax请求  把拿到的数据放在books 里面                      this.books = await axios.get(&#x27;books&#x27;);               &#125;           &#125;,           mounted: function() &#123;\t\t\t#  4 mounted  里面 DOM已经加载完毕  在这里调用函数                 this.queryData();           &#125;       &#125;);   &lt;/script&gt;\n\n2   添加图书\n获取用户输入的数据   发送到后台\n渲染最新的数据到页面上\n\nmethods: &#123;   handle: async function()&#123;         if(this.flag) &#123;           // 编辑图书           // 就是根据当前的ID去更新数组中对应的数据           this.books.some((item) =&gt; &#123;             if(item.id == this.id) &#123;               item.name = this.name;               // 完成更新操作之后，需要终止循环               return true;             &#125;           &#125;);           this.flag = false;         &#125;else&#123;           # 1.1  在前面封装好的 handle 方法中  发送ajax请求             # 1.2  使用async  和 await 简化操作 需要在 function 前面添加 async              var ret = await axios.post(&#x27;books&#x27;, &#123;             name: this.name           &#125;)           # 1.3  根据后台返回的状态码判断是否加载数据            if(ret.status == 200) &#123;            # 1.4  调用 queryData 这个方法  渲染最新的数据              this.queryData();           &#125;         &#125;         // 清空表单         this.id = &#x27;&#x27;;         this.name = &#x27;&#x27;;       &#125;,        &#125;         \n\n3  验证图书名称是否存在\n添加图书之前发送请求验证图示是否已经存在\n如果不存在 往后台里面添加图书名称\n图书存在与否只需要修改submitFlag的值即可\n\n\n\n watch: &#123;        name: async function(val) &#123;          // 验证图书名称是否已经存在          // var flag = this.books.some(function(item)&#123;          //   return item.name == val;          // &#125;);          var ret = await axios.get(&#x27;/books/book/&#x27; + this.name);          if(ret.status == 1) &#123;            // 图书名称存在            this.submitFlag = true;          &#125;else&#123;            // 图书名称不存在            this.submitFlag = false;          &#125;        &#125;&#125;,\n\n4.  编辑图书\n根据当前书的id 查询需要编辑的书籍\n需要根据状态位判断是添加还是编辑 \n\nmethods: &#123;       handle: async function()&#123;         if(this.flag) &#123;           #4.3 编辑图书   把用户输入的信息提交到后台           var ret = await axios.put(&#x27;books/&#x27; + this.id, &#123;             name: this.name           &#125;);           if(ret.status == 200)&#123;             #4.4  完成添加后 重新加载列表数据             this.queryData();           &#125;           this.flag = false;         &#125;else&#123;           // 添加图书           var ret = await axios.post(&#x27;books&#x27;, &#123;             name: this.name           &#125;)           if(ret.status == 200) &#123;             // 重新加载列表数据             this.queryData();           &#125;         &#125;         // 清空表单         this.id = &#x27;&#x27;;         this.name = &#x27;&#x27;;       &#125;,       toEdit: async function(id)&#123;         #4.1  flag状态位用于区分编辑和添加操作         this.flag = true;         #4.2  根据id查询出对应的图书信息  页面中可以加载出来最新的信息         # 调用接口发送ajax 请求           var ret = await axios.get(&#x27;books/&#x27; + id);         this.id = ret.id;         this.name = ret.name;       &#125;,\n\n5 删除图书\n把需要删除的id书籍 通过参数的形式传递到后台\n\ndeleteBook: async function(id)&#123;       // 删除图书       var ret = await axios.delete(&#x27;books/&#x27; + id);       if(ret.status == 200) &#123;         // 重新加载列表数据         this.queryData();       &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["黑马前端"],"tags":["Vue"]},{"title":"黑马前端-Web Api笔记","url":"/2021/10/16/%E9%BB%91%E9%A9%AC%E5%89%8D%E7%AB%AF-Web-Api%E7%AC%94%E8%AE%B0/","content":"Web APIs 和 JS 基础关联性JS 的组成![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-11_00-12-30.png)\nJS 基础阶段以及 Web APIs 阶段![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-11_00-13-45.png)\nJS 基础学习 ECMAScript 基础语法为后面作铺垫， Web APIs 是 JS 的应用，大量使用 JS \n基础语法做交互效果。\nAPI 和 Web APIAPIAPI（Application Programming Interface,应用程序编程接口）是一些预先定义的函\n数，目的是提供应用程序 与开发人员基于某软件或硬件得以访问一组例程的能力，而又\n无需访问源码，或理解内部工作机制的细节。 \n简单理解： API 是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能。 \n比如手机充电的接口： \n我们要实现充电这个功能： \n\n我们不关心手机内部变压器，内部怎么存储电等\n我们不关心这个充电线怎么制作的\n我们只知道，我们拿着充电线插进充电接口就可以充电\n这个充电接口就是一个 API \n\nWeb APIWeb API 是浏览器提供的一套操作浏览器功能和页面元素的 API ( BOM 和 DOM )。 \n现阶段我们主要针对于浏览器讲解常用的 API , 主要针对浏览器做交互效果。\n比如我们想要浏览器弹出一个警示框， 直接使用 alert(‘弹出’) \nMDN 详细 API : https://developer.mozilla.org/zh-CN/docs/Web/API \n因为 Web API 很多，所以我们将这个阶段称为 Web APIs \nAPI 和 Web API 总结\nAPI 是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以\n了，不必纠结内部如何实现\n\nWeb API 主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果\n\nWeb API 一般都有输入和输出（函数的传参和返回值），Web API 很多都是方法\n（函数）\n\n学习 Web API 可以结合前面学习内置对象方法的思路学习\n\n\nDOMDOM简介什么是 DOM文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩\n展标记语言（HTML 或者XML）的标准编程接口。\nW3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构\n和样式。\nDOM 树![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-11_00-22-54.png)\n\n文档：一个页面就是一个文档，DOM 中使用 document 表示\n\n元素：页面中的所有标签都是元素，DOM 中使用 element 表示\n\n节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM 中使用 \nnode 表示 \n\n\nDOM 把以上内容都看做是对象\n获取元素如何获取页面元素DOM在我们实际开发中主要用来操作元素。 \n获取页面中的元素可以使用以下几种方式: \n\n根据 ID 获取\n根据标签名获取\n通过 HTML5 新增的方法获取\n特殊元素获取\n\n根据 ID 获取使用 getElementById() 方法可以获取带有 ID 的元素对象。 \ndocument.getElementById(&#x27;id&#x27;);\n\n\n因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面\nget 获得 element 元素 by 通过 驼峰命名法\n参数 id是大小写敏感的字符串\n返回的是一个元素对象\n\n使用 console.dir() 可以打印我们获取的元素对象，更好的查看对象里面的属性和方法。 \nconsole.dir(timer);\n\n根据标签名获取使用 getElementsByTagName() 方法可以返回带有指定标签名的对象的集合。 \ndocument.getElementsByTagName(&#x27;标签名&#x27;); \n\n注意：\n\n因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。\n得到元素对象是动态的\n如果获取不到元素,则返回为空的伪数组(因为获取不到对象) \n\n还可以获取某个元素(父元素)内部所有指定标签名的子元素。\nelement.getElementsByTagName(&#x27;标签名&#x27;); \n\n注意：父元素必须是单个对象(必须指明是哪一个元素对象)。获取的时候不包括父元素自\n己。 \n通过 HTML5 新增的方法获取1. document.getElementsByClassName(‘类名’)；// 根据类名返回元素对象集合\n\n2. document.querySelector(&#x27;选择器&#x27;);    // 根据指定选择器返回第一个元素对象 \n\n3. document.querySelectorAll(&#x27;选择器&#x27;);   // 根据指定选择器返回所有元素对象 \n\n注意：\nquerySelector 和 querySelectorAll里面的选择器需要加符号,比如：document.querySelector(‘#nav’)；\n获取特殊元素（body，html）获取 body 元素\ndoucumnet.body  // 返回body元素对象 \n\n获取 html 元素\ndocument.documentElement  // 返回html元素对象 \n\n事件基础事件概述JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。\n简单理解： 触发— 响应机制。 \n网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。 \n事件三要素\n事件源 （谁） \n事件类型 （什么事件） \n事件处理程序 （做啥）\n\n&lt;button id=&quot;btn&quot;&gt;唐伯虎&lt;/button&gt;&lt;script&gt;    // 点击一个按钮，弹出对话框    // 1. 事件是有三部分组成  事件源  事件类型  事件处理程序   我们也称为事件三要素    //(1) 事件源 事件被触发的对象   谁  按钮    var btn = document.getElementById(&#x27;btn&#x27;);    //(2) 事件类型  如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下    //(3) 事件处理程序  通过一个函数赋值的方式 完成    btn.onclick = function() &#123;        alert(&#x27;点秋香&#x27;);    &#125;&lt;/script&gt;\n\n执行事件的步骤\n获取事件源 \n注册事件（绑定事件） \n添加事件处理程序（采取函数赋值形式） \n\n&lt;div&gt;123&lt;/div&gt;&lt;script&gt;    // 执行事件步骤    // 点击div 控制台输出 我被选中了    // 1. 获取事件源    var div = document.querySelector(&#x27;div&#x27;);    // 2.绑定事件 注册事件    // div.onclick     // 3.添加事件处理程序     div.onclick = function() &#123;        console.log(&#x27;我被选中了&#x27;);    &#125;&lt;/script&gt;\n\n常见的鼠标事件\n\n\n鼠标事件\n触发条件\n\n\n\nonlick\n鼠标点击左键触发\n\n\nonmouseover\n鼠标经过触发\n\n\nonmouseout\n鼠标离开触发\n\n\nonfocus\n获得鼠标焦点触发\n\n\nonblur\n失去鼠标焦点触发\n\n\nonmousemove\n鼠标移动触发\n\n\nonmouseup\n鼠标弹起触发\n\n\nonmousedown\n鼠标按下触发\n\n\n操作元素JavaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内 容 、属性等。注意以下都是属性\n改变元素内容element.innerText\n\n从起始位置到终止位置的内容, 但它去除 html 标签， 同时空格和换行也会去掉 \nelement.innerHTML \n\n起始位置到终止位置的全部内容，包括 html 标签，同时保留空格和换行\n// 我们元素可以不用添加事件var p = document.querySelector(&#x27;p&#x27;);p.innerHTML = getDate();\n\n常用元素的属性操作\n1. innerText、innerHTML 改变元素内容 2. src、href 3. id、alt、title \n\n表单元素的属性操作利用 DOM 可以操作如下表单元素的属性： \ntype、value、checked、selected、disabled \n\n案例：仿京东显示密码点击按钮将密码框切换为文本框，并可以查看密码明文。\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-11_21-45-08.png)\n案例分析：\n\n核心思路：  点击眼睛按钮，把密码框类型改为文本框就可以看见里面的密码\n一个按钮两个状态，点击一次，切换为文本框，继续点击一次切换为密码框\n算法：利用一个flag变量，来判断flag的值，如果是1 就切换为文本框，flag 设置为0，如 果是0 就切换为密码框，flag设置为1 \n\n&lt;script&gt;    // 1. 获取元素    var eye = document.getElementById(&#x27;eye&#x27;);    var pwd = document.getElementById(&#x27;pwd&#x27;);    // 2. 注册事件 处理程序    var flag = 0;    eye.onclick = function() &#123;        // 点击一次之后， flag 一定要变化        if (flag == 0) &#123;            pwd.type = &#x27;text&#x27;;            eye.src = &#x27;images/open.png&#x27;;            flag = 1; // 赋值操作        &#125; else &#123;            pwd.type = &#x27;password&#x27;;            eye.src = &#x27;images/close.png&#x27;;            flag = 0;        &#125;    &#125;&lt;/script&gt;\n\n样式属性操作我们可以通过 JS 修改元素的大小、颜色、位置等样式。 \n1. element.style      行内样式操作2. element.className  类名样式操作\n\n注意：\n\nJS 里面的样式采取驼峰命名法 比如 fontSize、 backgroundColor\nJS 修改 style 样式操作，产生的是行内样式，CSS 权重比较高\n如果样式修改较多，可以采取操作类名方式更改元素样式\nclass因为是个保留字，因此使用className来操作元素类名属性\nclassName 会直接更改元素的类名，会覆盖原先的类名\n\n   &lt;style&gt;       div &#123;           width: 100px;           height: 100px;           background-color: pink;       &#125;              .change &#123;           background-color: purple;           color: #fff;           font-size: 25px;           margin-top: 100px;       &#125;   &lt;/style&gt;&lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt;   &lt;script&gt;       // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用       var test = document.querySelector(&#x27;div&#x27;);       test.onclick = function() &#123;           // this.style.backgroundColor = &#x27;purple&#x27;;           // this.style.color = &#x27;#fff&#x27;;           // this.style.fontSize = &#x27;25px&#x27;;           // this.style.marginTop = &#x27;100px&#x27;;           // 让我们当前元素的类名改为了 change           // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况           // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器           // this.className = &#x27;change&#x27;;           this.className = &#x27;first change&#x27;;       &#125;   &lt;/script&gt;\n\n案例：循环精灵图可以利用 for 循环设置一组元素的精灵图背景\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-11_21-47-53.png)\n案例分析：\n\n首先精灵图图片排列有规律的\n核心思路： 利用for循环  修改精灵图片的 背景位置 background-position\n剩下的就是考验你的数学功底了\n让循环里面的 i 索引号 * 44 就是每个图片的y坐标\n\n&lt;script&gt;    // 1. 获取元素 所有的小li     var lis = document.querySelectorAll(&#x27;li&#x27;);    for (var i = 0; i &lt; lis.length; i++) &#123;        // 让索引号 乘以 44 就是每个li 的背景y坐标  index就是我们的y坐标        var index = i * 44;        lis[i].style.backgroundPosition = &#x27;0 -&#x27; + index + &#x27;px&#x27;;    &#125;&lt;/script&gt;\n\n案例：显示隐藏文本框内容当鼠标点击文本框时，里面的默认文字隐藏，当鼠标离开文本框时，里面的文字显示。\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-11_21-49-57.png)\n案例分析：\n\n首先表单需要2个新事件，获得焦点 onfocus  失去焦点 onblur\n如果获得焦点， 判断表单里面内容是否为默认文字，如果是默认文字，就清空表单内容\n如果失去焦点， 判断表单内容是否为空，如果为空，则表单内容改为默认文字\n\n&lt;style&gt;    input &#123;        color: #999;    &#125;&lt;/style&gt;&lt;input type=&quot;text&quot; value=&quot;手机&quot;&gt;&lt;script&gt;    // 1.获取元素    var text = document.querySelector(&#x27;input&#x27;);    // 2.注册事件 获得焦点事件 onfocus     text.onfocus = function() &#123;            // console.log(&#x27;得到了焦点&#x27;);            if (this.value === &#x27;手机&#x27;) &#123;                this.value = &#x27;&#x27;;            &#125;            // 获得焦点需要把文本框里面的文字颜色变黑            this.style.color = &#x27;#333&#x27;;        &#125;        // 3. 注册事件 失去焦点事件 onblur    text.onblur = function() &#123;        // console.log(&#x27;失去了焦点&#x27;);        if (this.value === &#x27;&#x27;) &#123;            this.value = &#x27;手机&#x27;;        &#125;        // 失去焦点需要把文本框里面的文字颜色变浅色        this.style.color = &#x27;#999&#x27;;    &#125;&lt;/script&gt;\n\n案例：密码框格式提示错误信息用户如果离开密码框，里面输入个数不是6~16，则提示错误信息，否则提示输入正确信息 \n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-12_13-48-15.png)\n案例分析：\n\n首先判断的事件是表单失去焦点 onblur\n如果输入正确则提示正确的信息颜色为绿色小图标变化\n如果输入不是6到16位，则提示错误信息颜色为红色 小图标变化\n因为里面变化样式较多，我们采取className修改样式\n\n&lt;div class=&quot;register&quot;&gt;    &lt;input type=&quot;password&quot; class=&quot;ipt&quot;&gt;    &lt;p class=&quot;message&quot;&gt;请输入6~16位密码&lt;/p&gt;&lt;/div&gt;&lt;script&gt;    // 首先判断的事件是表单失去焦点 onblur    // 如果输入正确则提示正确的信息颜色为绿色小图标变化    // 如果输入不是6到16位，则提示错误信息颜色为红色 小图标变化    // 因为里面变化样式较多，我们采取className修改样式    // 1.获取元素    var ipt = document.querySelector(&#x27;.ipt&#x27;);    var message = document.querySelector(&#x27;.message&#x27;);    //2. 注册事件 失去焦点    ipt.onblur = function() &#123;        // 根据表单里面值的长度 ipt.value.length        if (this.value.length &lt; 6 || this.value.length &gt; 16) &#123;            // console.log(&#x27;错误&#x27;);            message.className = &#x27;message wrong&#x27;;            message.innerHTML = &#x27;您输入的位数不对要求6~16位&#x27;;        &#125; else &#123;            message.className = &#x27;message right&#x27;;            message.innerHTML = &#x27;您输入的正确&#x27;;        &#125;    &#125;&lt;/script&gt;\n\n操作元素总结操作元素是 DOM 核心内容。\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-11_16-21-18.png)\n排他思想![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-12_13-53-39.png)\n如果有同一组元素，我们想要某一个元素实现某种样式， 需要用到循环的排他思想算法：\n\n所有元素全部清除样式（干掉其他人） \n给当前元素设置样式 （留下我自己） \n注意顺序不能颠倒，首先干掉其他人，再设置自己 \n\n&lt;button&gt;按钮1&lt;/button&gt;&lt;button&gt;按钮2&lt;/button&gt;&lt;button&gt;按钮3&lt;/button&gt;&lt;script&gt;    // 1. 获取所有按钮元素    var btns = document.getElementsByTagName(&#x27;button&#x27;);    // btns得到的是伪数组  里面的每一个元素 btns[i]    for (var i = 0; i &lt; btns.length; i++) &#123;        btns[i].onclick = function() &#123;            // (1) 我们先把所有的按钮背景颜色去掉  干掉所有人            for (var i = 0; i &lt; btns.length; i++) &#123;                btns[i].style.backgroundColor = &#x27;&#x27;;            &#125;            // (2) 然后才让当前的元素背景颜色为pink 留下我自己            this.style.backgroundColor = &#x27;pink&#x27;;        &#125;    &#125;    //2. 首先先排除其他人，然后才设置自己的样式 这种排除其他人的思想我们成为排他思想&lt;/script&gt;\n\n案例：百度换肤\n这个案例练习的是给一组元素注册事件\n给4个小图片利用循环注册点击事件\n当我们点击了这个图片，让我们页面背景改为当前的图片\n核心算法： 把当前图片的src 路径取过来，给 body 做为背景即可\n\n// 1. 获取元素 var imgs = document.querySelector(&#x27;.baidu&#x27;).querySelectorAll(&#x27;img&#x27;);// console.log(imgs);// 2. 循环注册事件 for (var i = 0; i &lt; imgs.length; i++) &#123;imgs[i].onclick = function() &#123;// this.src 就是我们点击图片的路径   images/2.jpg// console.log(this.src);// 把这个路径 this.src 给body 就可以了document.body.style.backgroundImage = &#x27;url(&#x27; + this.src + &#x27;)&#x27;;&#125;&#125;\n\n案例：表格隔行变色\n用到新的鼠标事件 鼠标经过 onmouseover 鼠标离开 onmouseout\n核心思路：鼠标经过 tr 行，当前的行变背景颜色， 鼠标离开去掉当前的背景颜色\n注意： 第一行（thead里面的行）不需要变换颜色，因此我们获取的是 tbody 里面的行 \n\n// 1.获取元素 获取的是 tbody 里面所有的行var trs = document.querySelector(&#x27;tbody&#x27;).querySelectorAll(&#x27;tr&#x27;);// 2. 利用循环绑定注册事件        for (var i = 0; i &lt; trs.length; i++) &#123;            // 3. 鼠标经过事件 onmouseover            trs[i].onmouseover = function() &#123;                    // console.log(11);                    this.className = &#x27;bg&#x27;;                &#125;                // 4. 鼠标离开事件 onmouseout            trs[i].onmouseout = function() &#123;                this.className = &#x27;&#x27;;            &#125;        &#125;\n\n案例:表单全选取消全选案例\n点击上面全选复选框，下面所有的复选框都选中（全选） \n再次点击全选复选框，下面所有的复选框都不中选（取消全选） \n如果下面复选框全部选中，上面全选按钮就自动选中 \n如果下面复选框有一个没有选中，上面全选按钮就不选中 \n所有复选框一开始默认都没选中状态 \n\n案例分析：\n\n全选和取消全选做法：  让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可\n下面复选框需要全部选中， 上面全选才能选中做法： 给下面所有复选框绑定点击事件，每次点击，都 要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的， 上面全选就不选中。\n可以设置一个变量，来控制全选是否选中 \n\n自定义属性的操作获取属性的属性值\nelement.属性  获取属性值 \nelement.getAttribute(‘属性’); \n\n区别：\n\nelement.属性  获取内置属性值（元素本身自带的属性）\nelement.getAttribute(‘属性’)    主要获得自定义的属性 （标准） 我们程序员自定义的属性 \n\n设置属性属性值\nelement.属性 = ‘值’  设置内置属性值\nelement.setAttribute(‘属性’, ‘值’)\n\n区别：\n\nelement.属性  设置内置属性值\nelement.setAttribute(‘属性’);  主要设置自定义的属性 （标准）\n\n移除属性element.removeAttribute(‘属性’)\n案例：tab 栏切换（重点案例）当鼠标点击上面相应的选项卡（tab），下面内容跟随变化 \n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-12_16-18-51.png)\n\nTab栏切换有2个大的模块\n上的模块选项卡，点击某一个，当前这一个底色会是红色，其余不变（排他思想） 修改类 名的方式\n下面的模块内容，会跟随上面的选项卡变化。所以下面模块变化写到点击事件里面。\n规律：下面的模块显示内容和上面的选项卡一一对应，相匹配。\n核心思路： 给上面的tab_list 里面的所有小li 添加自定义属性，属性值从0开始编号。\n当我们点击tab_list 里面的某个小li，让tab_con 里面对应序号的 内容显示，其余隐藏（排他思想） \n\n// 获取元素var tab_list = document.querySelector(&#x27;.tab_list&#x27;);var lis = tab_list.querySelectorAll(&#x27;li&#x27;);var items = document.querySelectorAll(&#x27;.item&#x27;);// for循环绑定点击事件     for (var i = 0; i &lt; lis.length; i++) &#123;// 开始给5个小li 设置索引号      lis[i].setAttribute(&#x27;index&#x27;, i);     lis[i].onclick = function() &#123;// 1. 上的模块选项卡，点击某一个，当前这一个底色会是红色，其余不变（排他思想） 修改类名的方式// 干掉所有人 其余的li清除 class 这个类      for (var i = 0; i &lt; lis.length; i++) &#123;             lis[i].className = &#x27;&#x27;;       &#125;                // 留下我自己                 this.className = &#x27;current&#x27;;                // 2. 下面的显示内容模块                var index = this.getAttribute(&#x27;index&#x27;);                console.log(index);                // 干掉所有人 让其余的item 这些div 隐藏                for (var i = 0; i &lt; items.length; i++) &#123;                    items[i].style.display = &#x27;none&#x27;;                &#125;                // 留下我自己 让对应的item 显示出来                items[index].style.display = &#x27;block&#x27;;            &#125;        &#125;\n\nH5 自定义属性自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。 \n自定义属性获取是通过getAttribute(‘属性’) 获取。\n但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。 \nH5给我们新增了自定义属性：\n设置H5自定义属性H5规定自定义属性data-开头做为属性名并且赋值\n比如  &lt; div data-index=”1” &gt;&lt; /div &gt; \n或者使用 JS 设置\nelement.setAttribute(‘data-index’, 2) \n获取H5自定义属性\n兼容性获取   element.getAttribute(‘data-index’); \nH5新增 element.dataset.index  或者 element.dataset[‘index’]   ie 11才开始支持 \n\ndataset 是一个集合里面存放了所有以data开头的自定义属性。它只能获取data-开头的。\n如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法。\n节点操作为什么学节点操作获取元素通常使用两种方式： \n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-12_16-22-30.png)\n这两种方式都可以获取元素节点，我们后面都会使用，但是节点操作更简单 \n节点概述网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。 \nHTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以 创建或删除。 \n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-11_00-22-54.png)\n一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个 基本属性。 \n\n元素节点  nodeType  为 1 \n属性节点  nodeType  为 2 \n文本节点  nodeType  为 3 （文本节点包含文字、空格、换行等）\n\n我们在实际开发中，节点操作主要操作的是元素节点。\n节点层级利用 DOM 树可以把节点划分为不同的层级关系，常见的是父子兄层级关系。 \n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-11_00-22-54.png)\n父级节点node.parentNode \n\n\nparentNode 属性可返回某节点的父节点，注意是最近的一个父节点\n如果指定的节点没有父节点则返回 null \n\n子节点1. parentNode.childNodes（标准）\n\nparentNode.childNodes 返回包含指定节点的子节点的集合，该集合为即时更新的集合。 \n注意：返回值里面包含了所有的子节点，包括元素节点，文本节点等。 \n如果只想要获得里面的元素节点，则需要专门处理。 所以我们一般不提倡使用childNodes \nvar ul = document. querySelector(‘ul’); for(var i = 0; i &lt; ul.childNodes.length;i++) &#123; if (ul.childNodes[i].nodeType == 1) &#123;     // ul.childNodes[i] 是元素节点     console.log(ul.childNodes[i]); &#125; &#125; \n\n2. parentNode.children（非标准）\n\n实际开发的写法  既没有兼容性问题又返回第一个子元素console.log(ol.children[0]);console.log(ol.children[ol.children.length - 1]);\n\nparentNode.children 是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回 （这个是我们重点掌握的，实际开发中用）。 \n虽然children 是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用。\n3. parentNode.firstChild \n\nfirstChild 返回第一个子节点，找不到则返回null。同样，也是包含所有的节点。 \n4. parentNode.lastChild\n\nlastChild 返回最后一个子节点，找不到则返回null。同样，也是包含所有的节点。\n5. parentNode.firstElementChild \n\nfirstElementChild  返回第一个子元素节点，找不到则返回null。  \n6. parentNode.lastElementChild  \n\nlastElementChild 返回最后一个子元素节点，找不到则返回null。\n注意：这两个方法有兼容性问题，IE9 以上才支持。\n实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？ \n解决方案： （实际开发的写法）\n\n如果想要第一个子元素节点，可以使用 parentNode.chilren[0]  \n如果想要最后一个子元素节点，可以使用 parentNode.chilren[parentNode.chilren.length - 1] \n\n案例：下拉菜单![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-12_16-28-20.png)\n\n导航栏里面的li 都要有鼠标经过效果，所以需要循环注册鼠标事件\n核心原理： 当鼠标经过li 里面的 第二个孩子 ul 显示， 当鼠标离开，则ul 隐藏 \n\n// 1. 获取元素var nav = document.querySelector(&#x27;.nav&#x27;);var lis = nav.children; // 得到4个小li// 2.循环注册事件for (var i = 0; i &lt; lis.length; i++) &#123;    lis[i].onmouseover = function() &#123;        this.children[1].style.display = &#x27;block&#x27;;    &#125;    lis[i].onmouseout = function() &#123;        this.children[1].style.display = &#x27;none&#x27;;    &#125;&#125;\n\n兄弟节点1. node.nextSibling \n\nnextSibling 返回当前元素的下一个兄弟节点，包含元素节点或者文本节点等。找不到则返回null。\n2. node.previousSibling\n\npreviousSibling 返回当前元素的上一个兄弟节点，包含元素节点或者文本节点等。找不到则返回null。\n3. node.nextElementSibling\n\nnextElementSibling 返回当前元素下一个兄弟元素节点，找不到则返回null。 \n4. node.previousElementSibling  \n\npreviousElementSibling 返回当前元素上一个兄弟节点，找不到则返回null。\n注意：这两个方法有兼容性问题， IE9 以上才支持。 \n问：如何解决兼容性问题 ？ \n答：自己封装一个兼容性的函数\nfunction getNextElementSibling(element) &#123;       \tvar el = element;       \twhile (el = el.nextSibling) &#123;         \t\tif (el.nodeType === 1) &#123;             \t\t\treturn el;         \t\t&#125;       \t&#125;       \treturn null;    &#125; \n\n创建节点document.createElement(&#x27;tagName&#x27;) \n\ndocument.createElement() 方法创建由 tagName 指定的 HTML 元素。因为这些元素原先不存在， 是根据我们的需求动态生成的，所以我们也称为动态创建元素节点。 \n添加节点1. node.appendChild(child) \n\nnode.appendChild() 方法将一个节点添加到指定父节点的子节点列表末尾。类似于 CSS 里面的 after 伪元素。\n2. node.insertBefore(child, 指定元素)\n\nnode.insertBefore() 方法将一个节点添加到父节点的指定子节点前面。类似于 CSS 里面的 before 伪元素。\n// 1. 创建节点元素节点var li = document.createElement(&#x27;li&#x27;);// 2. 添加节点 node.appendChild(child)  node 父级  child 是子级 后面追加元素  类似于数组中的pushvar ul = document.querySelector(&#x27;ul&#x27;);ul.appendChild(li);// 3. 添加节点 node.insertBefore(child, 指定元素);var lili = document.createElement(&#x27;li&#x27;);ul.insertBefore(lili, ul.children[0]);// 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素\n\n案例：简单版发布留言案例\n核心思路： 点击按钮之后，就动态创建一个li，添加到ul 里面。\n创建li 的同时，把文本域里面的值通过li.innerHTML 赋值给 li\n如果想要新的留言后面显示就用 appendChild 如果想要前面显示就用insertBefore\n\n// 1. 获取元素var btn = document.querySelector(&#x27;button&#x27;);var text = document.querySelector(&#x27;textarea&#x27;);var ul = document.querySelector(&#x27;ul&#x27;);// 2. 注册事件btn.onclick = function() &#123;    if (text.value == &#x27;&#x27;) &#123;        alert(&#x27;您没有输入内容&#x27;);        return false;    &#125; else &#123;        // console.log(text.value);        // (1) 创建元素        var li = document.createElement(&#x27;li&#x27;);        // 先有li 才能赋值        li.innerHTML = text.value;        // (2) 添加元素        // ul.appendChild(li);        ul.insertBefore(li, ul.children[0]);    &#125;&#125;\n\n删除节点node.removeChild(child) \n\nnode.removeChild() 方法从 DOM 中删除一个子节点，返回删除的节点。\n// 1.获取元素var ul = document.querySelector(&#x27;ul&#x27;);var btn = document.querySelector(&#x27;button&#x27;);// 2. 删除元素  node.removeChild(child)// ul.removeChild(ul.children[0]);// 3. 点击按钮依次删除里面的孩子btn.onclick = function() &#123;    if (ul.children.length == 0) &#123;        this.disabled = true;    &#125; else &#123;        ul.removeChild(ul.children[0]);    &#125;&#125;\n\n案例：删除留言案例\n当我们把文本域里面的值赋值给li 的时候，多添加一个删除的链接\n需要把所有的链接获取过来，当我们点击当前的链接的时候，删除当前链接所在的li \n阻止链接跳转需要添加 javascript:void(0); 或者  javascript:;\n\n        // 1. 获取元素        var btn = document.querySelector(&#x27;button&#x27;);        var text = document.querySelector(&#x27;textarea&#x27;);        var ul = document.querySelector(&#x27;ul&#x27;);        // 2. 注册事件        btn.onclick = function() &#123;            if (text.value == &#x27;&#x27;) &#123;                alert(&#x27;您没有输入内容&#x27;);                return false;            &#125; else &#123;                // console.log(text.value);        // (1) 创建元素        var li = document.createElement(&#x27;li&#x27;);       // 先有li 才能赋值       li.innerHTML = text.value + &quot;&lt;a href=&#x27;javascript:;&#x27;&gt;删除&lt;/a&gt;&quot;;                // (2) 添加元素                // ul.appendChild(li);                ul.insertBefore(li, ul.children[0]);                // (3) 删除元素 删除的是当前链接的li  它的父亲                var as = document.querySelectorAll(&#x27;a&#x27;);                for (var i = 0; i &lt; as.length; i++) &#123;                    as[i].onclick = function() &#123;// node.removeChild(child); 删除的是 li 当前a所在的li  this.parentNode;                        ul.removeChild(this.parentNode);                    &#125;                &#125;            &#125;        &#125;\n\n复制节点（克隆节点）node.cloneNode() \n\nnode.cloneNode() 方法返回调用该方法的节点的一个副本。 也称为克隆节点/拷贝节点 \n注意： \n\n如果括号参数为空或者为 false ，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点。 \n如果括号参数为 true ，则是深度拷贝，会复制节点本身以及里面所有的子节点。 \n\n&lt;ul&gt;     &lt;li&gt;1111&lt;/li&gt;     &lt;li&gt;2&lt;/li&gt;     &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var ul = document.querySelector(&#x27;ul&#x27;);// 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容// 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容var lili = ul.children[0].cloneNode(true);ul.appendChild(lili);&lt;/script&gt;\n\n案例：动态生成表格![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-13_12-19-44.png)\n\n因为里面的学生数据都是动态的，我们需要js 动态生成。 这里我们模拟数据，自己定义好 数据。 数据我们采取对象形式存储\n所有的数据都是放到tbody里面的行里面\n因为行很多，我们需要循环创建多个行（对应多少人）\n每个行里面又有很多单元格（对应里面的数据），我们还继续使用循环创建多个单元格， 并且把数据存入里面（双重for循环）\n最后一列单元格是删除，需要单独创建单元格\n最后添加删除操作，单击删除，可以删除当前行\n\n// 1.先去准备好学生的数据var datas = [&#123;    name: &#x27;魏璎珞&#x27;,    subject: &#x27;JavaScript&#x27;,    score: 100&#125;, &#123;    name: &#x27;弘历&#x27;,    subject: &#x27;JavaScript&#x27;,    score: 98&#125;, &#123;    name: &#x27;傅恒&#x27;,    subject: &#x27;JavaScript&#x27;,    score: 99&#125;, &#123;    name: &#x27;明玉&#x27;,    subject: &#x27;JavaScript&#x27;,    score: 88&#125;, &#123;    name: &#x27;大猪蹄子&#x27;,    subject: &#x27;JavaScript&#x27;,    score: 0&#125;];// 2. 往tbody 里面创建行： 有几个人（通过数组的长度）我们就创建几行var tbody = document.querySelector(&#x27;tbody&#x27;);for (var i = 0; i &lt; datas.length; i++) &#123; // 外面的for循环管行 tr    // 1. 创建 tr行    var tr = document.createElement(&#x27;tr&#x27;);    tbody.appendChild(tr);    // 2. 行里面创建单元格(跟数据有关系的3个单元格) td 单元格的数量取决于每个对象里面的属性个数  for循环遍历对象 datas[i]    for (var k in datas[i]) &#123; // 里面的for循环管列 td        // 创建单元格         var td = document.createElement(&#x27;td&#x27;);        // 把对象里面的属性值 datas[i][k] 给 td          // console.log(datas[i][k]);        td.innerHTML = datas[i][k];        tr.appendChild(td);    &#125;    // 3. 创建有删除2个字的单元格     var td = document.createElement(&#x27;td&#x27;);    td.innerHTML = &#x27;&lt;a href=&quot;javascript:;&quot;&gt;删除 &lt;/a&gt;&#x27;;    tr.appendChild(td);&#125;// 4. 删除操作 开始 var as = document.querySelectorAll(&#x27;a&#x27;);for (var i = 0; i &lt; as.length; i++) &#123;    as[i].onclick = function() &#123;        // 点击a 删除 当前a 所在的行(链接的爸爸的爸爸)  node.removeChild(child)          tbody.removeChild(this.parentNode.parentNode)    &#125;&#125;// for(var k in obj) &#123;//     k 得到的是属性名//     obj[k] 得到是属性值// &#125;\n\n三种动态创建元素区别\ndocument.write() \nelement.innerHTML \ndocument.createElement() \n\n区别：\n\ndocument.write 是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘（删除之前的代码，显示新添加的代码） \ninnerHTML 是将内容写入某个 DOM 节点，不会导致页面全部重绘 \ninnerHTML 创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂 \ncreateElement() 创建多个元素效率稍低一点点，但是结构更清晰\n\n总结：不同浏览器下，innerHTML 效率要比 creatElement 高\n// 2. innerHTML 创建元素var inner = document.querySelector(&#x27;.inner&#x27;);// for (var i = 0; i &lt;= 100; i++) &#123;//     inner.innerHTML += &#x27;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#x27;// &#125;var arr = [];for (var i = 0; i &lt;= 100; i++) &#123;    arr.push(&#x27;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#x27;);&#125;inner.innerHTML = arr.join(&#x27;&#x27;);// 3. document.createElement() 创建元素var create = document.querySelector(&#x27;.create&#x27;);for (var i = 0; i &lt;= 100; i++) &#123;    var a = document.createElement(&#x27;a&#x27;);    create.appendChild(a);&#125;\n\nDOM 重点核心文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言 （HTML或者XML）的标准编程接口。 \nW3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。 \n\n对于JavaScript，为了能够使JavaScript操作HTML，JavaScript就有了一套自己的dom编程接口。 \n对于HTML，dom使得html形成一棵dom树.  包含 文档、元素、节点\n\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-11_00-22-54.png)\n我们获取过来的DOM元素是 一个对象（object），所以称为文档对象模型。\n关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。\n创建\ndocument.write     （用不到）\ninnerHTML \ncreateElement \n\n增\nappendChild \ninsertBefore \n\n删\nremoveChild \n\n改主要修改dom的元素属性，dom元素的内容、属性, 表单的值等。\n\n修改元素属性： src、href、title等 \n修改普通元素内容： innerHTML 、innerText \n修改表单元素： value、type、disabled等 \n修改元素样式： style、className \n\n查主要获取查询dom的元素\n\nDOM提供的API 方法：  getElementById、getElementsByTagName  古老用法 不太推荐  \nH5提供的新方法： querySelector、querySelectorAll   提倡 \n利用节点操作获取元素： 父(parentNode)、子(children)、兄(previousElementSibling、 nextElementSibling)  提倡 \n\n属性操作主要针对于自定义属性。\n\nsetAttribute：设置dom的属性值 \ngetAttribute：得到dom的属性值 \nremoveAttribute移除属性 \n\n事件操作给元素注册事件， 采取  事件源.事件类型 = 事件处理程序 \n\n\n\n鼠标事件\n触发条件\n\n\n\nonlick\n鼠标点击左键触发\n\n\nonmouseover\n鼠标经过触发\n\n\nonmouseout\n鼠标离开触发\n\n\nonfocus\n获得鼠标焦点触发\n\n\nonblur\n失去鼠标焦点触发\n\n\nonmousemove\n鼠标移动触发\n\n\nonmouseup\n鼠标弹起触发\n\n\nonmousedown\n鼠标按下触发\n\n\n事件高级注册事件（绑定事件）注册事件概述给元素添加事件，称为注册事件或者绑定事件。\n注册事件有两种方式：传统方式和方法监听注册方式。\n传统方式：\n\n利用 on 开头的事件 onclick\n&lt;button onclick=“alert(‘hi~’)”&gt;&lt; /button &gt;\nbtn.onclick = function() {} \n特点： 注册事件的唯一性\n同一个元素同一个事件只能设置一个处理函数，最 后注册的处理函数将会覆盖前面注册的处理函\n\n方法监听注册方式：\n\nw3c 标准，推荐方式\naddEventListener() 它是一个方法\nIE9 之前的 IE 不支持此方法，可使用 attachEvent() 代替\n特点：同一个元素同一个事件可以注册多个监听器\n按注册顺序依次执行\n\n&lt;button&gt;传统注册事件&lt;/button&gt;&lt;button&gt;方法监听注册事件&lt;/button&gt;&lt;button&gt;ie9 attachEvent&lt;/button&gt;&lt;script&gt;    var btns = document.querySelectorAll(&#x27;button&#x27;);    // 1. 传统方式注册事件    btns[0].onclick = function() &#123;        alert(&#x27;hi&#x27;);    &#125;    btns[0].onclick = function() &#123;            alert(&#x27;hao a u&#x27;);        &#125;        // 2. 事件侦听注册事件 addEventListener         // (1) 里面的事件类型是字符串 必定加引号 而且不带on        // (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序）    btns[1].addEventListener(&#x27;click&#x27;, function() &#123;        alert(22);    &#125;)    btns[1].addEventListener(&#x27;click&#x27;, function() &#123;            alert(33);        &#125;)        // 3. attachEvent ie9以前的版本支持    btns[2].attachEvent(&#x27;onclick&#x27;, function() &#123;        alert(11);    &#125;)&lt;/script&gt;\n\naddEventListener 事件监听方式eventTarget.addEventListener(type, listener[, useCapture]) \n\neventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对 象触发指定的事件时，就会执行事件处理函数。\n该方法接收三个参数：\n\ntype：事件类型字符串，比如 click 、mouseover ，注意这里不要带 on\nlistener：事件处理函数，事件发生时，会调用该监听函数\nuseCapture：可选参数，是一个布尔值，默认是 false。学完 DOM 事件流后，我们再进一步学习\n\nattachEvent 事件监听方式（了解，用不到）evenTarget.attachEvent(eventNameWithOn, callback) \n\neventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触 发指定的事件时，指定的回调函数就会被执行。\n该方法接收两个参数： \n\neventNameWithOn：事件类型字符串，比如 onclick 、onmouseover ，这里要带 on\ncallback： 事件处理函数，当目标触发事件时回调函数被调用\n\n注意：IE8 及早期版本支持\n注册事件兼容性解决方案function addEventListener(element, eventName, fn) &#123;       // 判断当前浏览器是否支持 addEventListener 方法       if (element.addEventListener) &#123;         element.addEventListener(eventName, fn);  // 第三个参数 默认是false       &#125; else if (element.attachEvent) &#123;         element.attachEvent(&#x27;on&#x27; + eventName, fn);       &#125; else &#123;         // 相当于 element.onclick = fn;         element[&#x27;on&#x27; + eventName] = fn;  &#125;\n\n兼容性处理的原则： 首先照顾大多数浏览器，再处理特殊浏览器\n删除事件（解绑事件）删除事件的方式1.传统注册方式\neventTarget.onclick = null;\n2.方法监听方式\n① eventTarget.removeEventListener(type, listener[, useCapture]); \n② eventTarget.detachEvent(eventNameWithOn, callback); \n&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;script&gt;    var divs = document.querySelectorAll(&#x27;div&#x27;);    divs[0].onclick = function() &#123;            alert(11);            // 1. 传统方式删除事件            divs[0].onclick = null;        &#125;        // 2. removeEventListener 删除事件    divs[1].addEventListener(&#x27;click&#x27;, fn) // 里面的fn 不需要调用加小括号    function fn() &#123;        alert(22);        divs[1].removeEventListener(&#x27;click&#x27;, fn);    &#125;    // 3. detachEvent    divs[2].attachEvent(&#x27;onclick&#x27;, fn1);    function fn1() &#123;        alert(33);        divs[2].detachEvent(&#x27;onclick&#x27;, fn1);    &#125;&lt;/script&gt;\n\n删除事件兼容性解决方案function removeEventListener(element, eventName, fn) &#123;       // 判断当前浏览器是否支持 removeEventListener 方法       if (element.removeEventListener) &#123;         element.removeEventListener(eventName, fn);  // 第三个参数默是false       &#125; else if (element.detachEvent) &#123;         element.detachEvent(&#x27;on&#x27; + eventName, fn);       &#125; else &#123;         element[&#x27;on&#x27; + eventName] = null; &#125;  \n\nDOM 事件流事件流描述的是从页面中接收事件的顺序。 \n事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。 \n比如我们给一个div 注册了点击事件\nDOM 事件流分为3个阶段：  \n\n捕获阶段 \n当前目标阶段 \n冒泡阶段 \n\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-13_14-08-04.png)\n\n事件冒泡： IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程。\n事件捕获： 网景最早提出，由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。 \n\n我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具 体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过 程相当于事件冒泡。\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-13_14-08-41.png)\n事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。 \n注意：\n\nJS 代码中只能执行捕获或者冒泡其中的一个阶段。 \nonclick 和 attachEvent 只能得到冒泡阶段。 \naddEventListener(type, listener[, useCapture])第三个参数如果是 true，表示在事件捕 获阶段调用事件处理程序；如果是 false（不写默认就是false），表示在事件冒泡阶段调用事件处理 程序。 \n实际开发中我们很少使用事件捕获，我们更关注事件冒泡。 \n有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave \n事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件，我们后面讲解。\n\n&lt;div class=&quot;father&quot;&gt;    &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    // dom 事件流 三个阶段    // 1. JS 代码中只能执行捕获或者冒泡其中的一个阶段。    // 2. onclick 和 attachEvent（ie） 只能得到冒泡阶段。    // 3. 捕获阶段 如果addEventListener 第三个参数是 true 那么则处于捕获阶段  document -&gt; html -&gt; body -&gt; father -&gt; son    // var son = document.querySelector(&#x27;.son&#x27;);    // son.addEventListener(&#x27;click&#x27;, function() &#123;    //     alert(&#x27;son&#x27;);    // &#125;, true);    // var father = document.querySelector(&#x27;.father&#x27;);    // father.addEventListener(&#x27;click&#x27;, function() &#123;    //     alert(&#x27;father&#x27;);    // &#125;, true);    // 4. 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 那么则处于冒泡阶段  son -&gt; father -&gt;body -&gt; html -&gt; document    var son = document.querySelector(&#x27;.son&#x27;);    son.addEventListener(&#x27;click&#x27;, function() &#123;        alert(&#x27;son&#x27;);    &#125;, false);    var father = document.querySelector(&#x27;.father&#x27;);    father.addEventListener(&#x27;click&#x27;, function() &#123;        alert(&#x27;father&#x27;);    &#125;, false);    document.addEventListener(&#x27;click&#x27;, function() &#123;        alert(&#x27;document&#x27;);    &#125;)&lt;/script&gt;\n\n事件对象什么是事件对象eventTarget.onclick = function(event) &#123;&#125;  eventTarget.addEventListener(&#x27;click&#x27;, function(event) &#123;&#125;） // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt\n\n官方解释：event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。 \n简单理解：事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象 event，它有很多属性和方法。\n比如：   \n\n谁绑定了这个事件\n鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置\n键盘触发事件的话，会得到键盘的相关信息，如按了哪个键\n\n事件对象的使用语法eventTarget.onclick = function(event) &#123;    // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt  &#125;  eventTarget.addEventListener(&#x27;click&#x27;, function(event) &#123;   // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt  &#125;）\n\n这个 event  是个形参，系统帮我们设定为事件对象，不需要传递实参过去。 \n当我们注册事件时， event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）。 \n&lt;div&gt;123&lt;/div&gt;&lt;script&gt;    // 事件对象    var div = document.querySelector(&#x27;div&#x27;);    div.onclick = function(e) &#123;            // console.log(e);            // console.log(window.event);            // e = e || window.event;            console.log(e);        &#125;        // div.addEventListener(&#x27;click&#x27;, function(e) &#123;        //         console.log(e);    //     &#125;)    // 1. event 就是一个事件对象 写到我们侦听函数的 小括号里面 当形参来看    // 2. 事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数    // 3. 事件对象 是 我们事件的一系列相关数据的集合 跟事件相关的 比如鼠标点击里面就包含了鼠标的相关信息，鼠标坐标啊，如果是键盘事件里面就包含的键盘事件的信息 比如 判断用户按下了那个键    // 4. 这个事件对象我们可以自己命名 比如 event 、 evt、 e    // 5. 事件对象也有兼容性问题 ie678 通过 window.event 兼容性的写法  e = e || window.event;\n\n事件对象的兼容性方案事件对象本身的获取存在兼容问题： \n\n标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到\n在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找\n\n解决:  e = e || window.event; \n事件对象的常见属性和方法e.target 和 this 的区别： \n\nthis 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素）\ne.target 是事件触发的元素\n\n&lt;div&gt;123&lt;/div&gt;&lt;ul&gt;    &lt;li&gt;abc&lt;/li&gt;    &lt;li&gt;abc&lt;/li&gt;    &lt;li&gt;abc&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    // 常见事件对象的属性和方法    // 1. e.target 返回的是触发事件的对象（元素）  this 返回的是绑定事件的对象（元素）    // 区别 ： e.target 点击了那个元素，就返回那个元素 this 那个元素绑定了这个点击事件，那么就返回谁    var div = document.querySelector(&#x27;div&#x27;);    div.addEventListener(&#x27;click&#x27;, function(e) &#123;        console.log(e.target);        console.log(this);    &#125;)    var ul = document.querySelector(&#x27;ul&#x27;);    ul.addEventListener(&#x27;click&#x27;, function(e) &#123;            // 我们给ul 绑定了事件  那么this 就指向ul              console.log(this);            console.log(e.currentTarget);            // e.target 指向我们点击的那个对象 谁触发了这个事件 我们点击的是li e.target 指向的就是li            console.log(e.target);        &#125;)        // 了解兼容性        // div.onclick = function(e) &#123;        //     e = e || window.event;        //     var target = e.target || e.srcElement;        //     console.log(target);    // &#125;    // 2. 了解 跟 this 有个非常相似的属性 currentTarget  ie678不认识\n\n事件对象的常见属性和方法\n\n\n事件对象属性方法\n说明\n\n\n\ne.target\n返回触发事件的对象，标准\n\n\ne.srcElement\n返回触发事件的对象，非标准，IE 6~8 使用\n\n\ne.type\n返回事件的类型，比如 click，mouseover，不带 on\n\n\ne.cancelBubble\n该属性阻止冒泡，非标准 IE 6~8 使用\n\n\ne.returnValue\n该属性阻止默认事件（默认行为），非标准 IE 6~8  使用，比如不让链接跳转\n\n\ne.preventDefault()\n该属性阻止默认事件（默认行为），标准，比如不让链接跳转\n\n\ne.stopPropagation()\n阻止冒泡，标准\n\n\n&lt;div&gt;123&lt;/div&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;form action=&quot;http://www.baidu.com&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;sub&quot;&gt;&lt;/form&gt;&lt;script&gt;    // 常见事件对象的属性和方法    // 1. 返回事件类型    var div = document.querySelector(&#x27;div&#x27;);    div.addEventListener(&#x27;click&#x27;, fn);    div.addEventListener(&#x27;mouseover&#x27;, fn);    div.addEventListener(&#x27;mouseout&#x27;, fn);    function fn(e) &#123;        console.log(e.type);    &#125;    // 2. 阻止默认行为（事件） 让链接不跳转 或者让提交按钮不提交    var a = document.querySelector(&#x27;a&#x27;);    a.addEventListener(&#x27;click&#x27;, function(e) &#123;            e.preventDefault(); //  dom 标准写法        &#125;)        // 3. 传统的注册方式    a.onclick = function(e) &#123;        // 普通浏览器 e.preventDefault();  方法        // e.preventDefault();        // 低版本浏览器 ie678  returnValue  属性        // e.returnValue;        // 我们可以利用return false 也能阻止默认行为 没有兼容性问题 特点： return 后面的代码不执行了， 而且只限于传统的注册方式        return false;        alert(11);    &#125;&lt;/script&gt;\n\n阻止事件冒泡阻止事件冒泡的两种方式事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点。 \n事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。 \n标准写法：利用事件对象里面的 stopPropagation()方法\ne.stopPropagation() \n\n非标准写法：IE 6-8  利用事件对象 cancelBubble 属性\ne.cancelBubble = true;\n\n&lt;div class=&quot;father&quot;&gt;    &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    // 常见事件对象的属性和方法    // 阻止冒泡  dom 推荐的标准 stopPropagation()     var son = document.querySelector(&#x27;.son&#x27;);    son.addEventListener(&#x27;click&#x27;, function(e) &#123;        alert(&#x27;son&#x27;);        e.stopPropagation(); // stop 停止  Propagation 传播        e.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡    &#125;, false);    var father = document.querySelector(&#x27;.father&#x27;);    father.addEventListener(&#x27;click&#x27;, function() &#123;        alert(&#x27;father&#x27;);    &#125;, false);    document.addEventListener(&#x27;click&#x27;, function() &#123;        alert(&#x27;document&#x27;);    &#125;)&lt;/script&gt;\n\n阻止事件冒泡的兼容性解决方案if(e &amp;&amp; e.stopPropagation)&#123;     e.stopPropagation(); &#125;else&#123;     window.event.cancelBubble = true; &#125; \n\n事件委托（代理、委派）事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。生活中有如下场景：\n咱们班有100个学生， 快递员有100个快递， 如果一个个的送花费时间较长。同时每个学生领取的时候，也需 要排队领取，也花费时间较长，何如？ \n解决方案：  快递员把100个快递，委托给班主任，班主任把这些快递放到办公室，同学们下课自行领取即可。 \n优势：  快递员省事，委托给班主任就可以走了。 同学们领取也方便，因为相信班主任。\n事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。程序中也有如此场景： \n&lt;ul&gt;             &lt;li&gt;知否知否，应该有弹框在手&lt;/li&gt;             &lt;li&gt;知否知否，应该有弹框在手&lt;/li&gt;             &lt;li&gt;知否知否，应该有弹框在手&lt;/li&gt;             &lt;li&gt;知否知否，应该有弹框在手&lt;/li&gt;             &lt;li&gt;知否知否，应该有弹框在手&lt;/li&gt;   &lt;/ul&gt;    &lt;script&gt;        // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点        var ul = document.querySelector(&#x27;ul&#x27;);        ul.addEventListener(&#x27;click&#x27;, function(e) &#123;            // alert(&#x27;知否知否，点我应有弹框在手！&#x27;);            // e.target 这个可以得到我们点击的对象            e.target.style.backgroundColor = &#x27;pink&#x27;;        &#125;)    &lt;/script&gt;\n\n点击每个 li 都会弹出对话框，以前需要给每个 li 注册事件，是非常辛苦的，而且访问 DOM 的次数越多，这就 会延长整个页面的交互就绪时间。\n事件委托：事件委托也称为事件代理， 在 jQuery 里面称为事件委派。 \n事件委托的原理：\n不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。 \n以上案例：给 ul 注册点击事件，然后利用事件对象的 target 来找到当前点击的 li，因为点击 li，事件会冒泡到 ul 上， ul 有注册事件，就会触发事件监听器。 \n事件委托的作用 ：我们只操作了一次 DOM ，提高了程序的性能。\n常用的鼠标事件\n\n\n鼠标事件\n触发条件\n\n\n\nonlick\n鼠标点击左键触发\n\n\nonmouseover\n鼠标经过触发\n\n\nonmouseout\n鼠标离开触发\n\n\nonfocus\n获得鼠标焦点触发\n\n\nonblur\n失去鼠标焦点触发\n\n\nonmousemove\n鼠标移动触发\n\n\nonmouseup\n鼠标弹起触发\n\n\nonmousedown\n鼠标按下触发\n\n\n常用的事件1.禁止鼠标右键菜单 \ncontextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单 \ndocument.addEventListener(&#x27;contextmenu&#x27;, function(e) &#123; e.preventDefault(); &#125;)\n\n2.禁止鼠标选中（selectstart 开始选中）\ndocument.addEventListener(&#x27;selectstart&#x27;, function(e) &#123; e.preventDefault(); &#125;) \n\n鼠标事件对象event对象代表事件的状态，跟事件相关的一系列信息的集合。现阶段我们主要是用鼠标事件对象 MouseEvent 和键盘事件对象 KeyboardEvent。 \n\n\n\n鼠标事件对象\n说明\n\n\n\ne.clientX\n返回鼠标相对于浏览器窗口可视区的 X 坐标\n\n\ne.clientY\n返回鼠标相对于浏览器窗口可视区的 Y 坐标\n\n\ne.pageX\n返回鼠标相对于文档页面的 X 坐标，IE 9+ 支持\n\n\ne.pageY\n返回鼠标相对于文档页面的 Y 坐标，IE 9+ 支持\n\n\ne.screenX\n返回鼠标相对于电脑屏幕的 X 坐标\n\n\ne.screenY\n返回鼠标相对于电脑屏幕的 Y 坐标\n\n\n// 鼠标事件对象 MouseEventdocument.addEventListener(&#x27;click&#x27;, function(e) &#123;    // 1. client 鼠标在可视区的x和y坐标    console.log(e.clientX);    console.log(e.clientY);    console.log(&#x27;---------------------&#x27;);    // 2. page 鼠标在页面文档的x和y坐标    console.log(e.pageX);    console.log(e.pageY);    console.log(&#x27;---------------------&#x27;);    // 3. screen 鼠标在电脑屏幕的x和y坐标    console.log(e.screenX);    console.log(e.screenY);&#125;)\n\n案例：跟随鼠标的天使这个天使图片一直跟随鼠标移动\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-13_15-29-57.png)\n\n鼠标不断的移动，使用鼠标移动事件： mousemove\n在页面中移动，给document注册事件\n图片要移动距离，而且不占位置，我们使用绝对定位即可\n核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 把这个x和y坐标做为图片的 top和left 值就可以移动图片 \n\n      &lt;style&gt;        img &#123;            position: absolute;            top: 2px;        &#125;    &lt;/style&gt;&lt;body&gt;    &lt;img src=&quot;images/angel.gif&quot; alt=&quot;&quot;&gt;    &lt;script&gt;        var pic = document.querySelector(&#x27;img&#x27;);        document.addEventListener(&#x27;mousemove&#x27;, function(e) &#123;            // 1. mousemove只要我们鼠标移动1px 就会触发这个事件            // console.log(1);            // 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 把这个x和y坐标做为图片的top和left 值就可以移动图片            var x = e.pageX;            var y = e.pageY;            console.log(&#x27;x坐标是&#x27; + x, &#x27;y坐标是&#x27; + y);            //3 . 千万不要忘记给left 和top 添加px 单位            pic.style.left = x - 50 + &#x27;px&#x27;;            pic.style.top = y - 40 + &#x27;px&#x27;;        &#125;);    &lt;/script&gt;&lt;/body&gt;\n\n常用的键盘事件常用键盘事件事件除了使用鼠标触发，还可以使用键盘触发， 注意给文档 document 添加键盘事件。\n\n\n\n键盘事件\n触发条件\n\n\n\nonkeyup\n某个键盘按键被松开时触发\n\n\nonkeydown\n某个键盘按键被按下时触发\n\n\nonkeypress\n某个键盘按键被松开时并弹起时触发。但是它不识别功能键，比如 Ctrl、shift 箭头等\n\n\n注意：  onkeypress 和前面2个的区别是，它不识别功能键，比如左右箭头，shift 等。\n// 常用的键盘事件//1. keyup 按键弹起的时候触发 // document.onkeyup = function() &#123;//         console.log(&#x27;我弹起了&#x27;);//     &#125;document.addEventListener(&#x27;keyup&#x27;, function() &#123;    console.log(&#x27;我弹起了&#x27;);&#125;)//3. keypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊document.addEventListener(&#x27;keypress&#x27;, function() &#123;        console.log(&#x27;我按下了press&#x27;);    &#125;)    //2. keydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊document.addEventListener(&#x27;keydown&#x27;, function() &#123;        console.log(&#x27;我按下了down&#x27;);    &#125;)    // 4. 三个事件的执行顺序  keydown -- keypress -- keyup\n\nASCII 表![Snipaste_2020-09-13_15-32-28](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-13_15-32-28.png)\n键盘事件对象\n\n\n键盘事件对象\n说明\n\n\n\nkeyCode\n返回该键的 ASCII 值\n\n\n注意：  onkeydown 和 onkeyup  不区分字母大小写，onkeypress 区分字母大小写。\n// 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值// 1. 我们的keyup 和keydown事件不区分字母大小写  a 和 A 得到的都是65// 2. 我们的keypress 事件 区分字母大小写  a  97 和 A 得到的是65document.addEventListener(&#x27;keyup&#x27;, function(e) &#123;    // console.log(e);    console.log(&#x27;up:&#x27; + e.keyCode);    // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键    if (e.keyCode === 65) &#123;        alert(&#x27;您按下的a键&#x27;);    &#125; else &#123;        alert(&#x27;您没有按下a键&#x27;)    &#125;&#125;)document.addEventListener(&#x27;keypress&#x27;, function(e) &#123;    // console.log(e);    console.log(&#x27;press:&#x27; + e.keyCode);&#125;)\n\n案例：模拟京东按键输入内容当我们按下 s 键， 光标就定位到搜索框 \n&lt;input type=&quot;text&quot;&gt;&lt;script&gt;    // 核心思路： 检测用户是否按下了s 键，如果按下s 键，就把光标定位到搜索框里面    // 使用键盘事件对象里面的keyCode 判断用户按下的是否是s键    // 搜索框获得焦点： 使用 js 里面的 focus() 方法    var search = document.querySelector(&#x27;input&#x27;);    document.addEventListener(&#x27;keyup&#x27;, function(e) &#123;        // console.log(e.keyCode);        if (e.keyCode === 83) &#123;            search.focus();        &#125;    &#125;)&lt;/script&gt;\n\n案例：模拟京东快递单号查询要求：当我们在文本框中输入内容时，文本框上面自动显示大字号的内容。 \n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-13_15-35-00.png)\n    &lt;div class=&quot;search&quot;&gt;        &lt;div class=&quot;con&quot;&gt;123&lt;/div&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;请输入您的快递单号&quot; class=&quot;jd&quot;&gt;    &lt;/div&gt;    &lt;script&gt;// 快递单号输入内容时， 上面的大号字体盒子（con）显示(这里面的字号更大）// 表单检测用户输入： 给表单添加键盘事件// 同时把快递单号里面的值（value）获取过来赋值给 con盒子（innerText）做为内容// 如果快递单号里面内容为空，则隐藏大号字体盒子(con)盒子        var con = document.querySelector(&#x27;.con&#x27;);        var jd_input = document.querySelector(&#x27;.jd&#x27;);        jd_input.addEventListener(&#x27;keyup&#x27;, function() &#123;                // console.log(&#x27;输入内容啦&#x27;);                if (this.value == &#x27;&#x27;) &#123;                    con.style.display = &#x27;none&#x27;;                &#125; else &#123;                    con.style.display = &#x27;block&#x27;;                    con.innerText = this.value;                &#125;            &#125;)            // 当我们失去焦点，就隐藏这个con盒子        jd_input.addEventListener(&#x27;blur&#x27;, function() &#123;                con.style.display = &#x27;none&#x27;;            &#125;)            // 当我们获得焦点，就显示这个con盒子        jd_input.addEventListener(&#x27;focus&#x27;, function() &#123;            if (this.value !== &#x27;&#x27;) &#123;                con.style.display = &#x27;block&#x27;;            &#125;        &#125;)\n\nBOM 浏览器对象模型BOM 概述什么是 BOMBOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心 对象是 window。 \nBOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。 \nBOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏 览器标准的一部分。\nDOM\n\n文档对象模型\nDOM 就是把「文档」当做一个「对象」来看待\nDOM 的顶级对象是 document\nDOM 主要学习的是操作页面元素\nDOM 是 W3C 标准规范\n\nBOM\n\n浏览器对象模型\n把「浏览器」当做一个「对象」来看待\nBOM 的顶级对象是 window\nBOM 学习的是浏览器窗口交互的一些对象\nBOM 是浏览器厂商在各自浏览器上定义的，兼容性较差\n\nBOM 的构成BOM 比 DOM 更大，它包含 DOM。 \n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-13_22-15-52.png)\nwindow 对象是浏览器的顶级对象，它具有双重角色。 \n\n它是 JS 访问浏览器窗口的一个接口。 \n它是一个全局对象。定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法。\n\n在调用的时候可以省略 window，前面学习的对话框都属于 window 对象方法，如 alert()、prompt() 等。 \n注意：window下的一个特殊属性 window.name\nwindow 对象的常见事件窗口加载事件window.onload = function()&#123;&#125; 或者  window.addEventListener(&quot;load&quot;,function()&#123;&#125;); \n\n window.onload 是窗口 (页面）加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。 \n注意：\n\n有了 window.onload 就可以把 JS 代码写到页面元素的上方，因为 onload 是等页面内容全部加载完毕， 再去执行处理函数。 \nwindow.onload 传统注册事件方式 只能写一次，如果有多个，会以最后一个 window.onload 为准。 \n如果使用 addEventListener 则没有限制 \n\ndocument.addEventListener(&#x27;DOMContentLoaded&#x27;,function()&#123;&#125;) \n\nDOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。\nIe9以上才支持。\n如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用 户的体验，此时用 DOMContentLoaded 事件比较合适。\n        // window.onload = function() &#123;        //     var btn = document.querySelector(&#x27;button&#x27;);        //     btn.addEventListener(&#x27;click&#x27;, function() &#123;        //         alert(&#x27;点击我&#x27;);        //     &#125;)        // &#125;        // window.onload = function() &#123;        //     alert(22);        // &#125;        window.addEventListener(&#x27;load&#x27;, function() &#123;            var btn = document.querySelector(&#x27;button&#x27;);            btn.addEventListener(&#x27;click&#x27;, function() &#123;                alert(&#x27;点击我&#x27;);            &#125;)        &#125;)        window.addEventListener(&#x27;load&#x27;, function() &#123;            alert(22);        &#125;)        document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() &#123;                alert(33);            &#125;)// load 等页面内容全部加载完毕，包含页面dom元素 图片 flash  css 等等// DOMContentLoaded 是DOM 加载完毕，不包含图片 falsh css 等就可以执行 加载速度比 load更快一些&lt;body&gt;    &lt;button&gt;点击&lt;/button&gt;&lt;/body&gt;\n\n调整窗口大小事件window.onresize = function()&#123;&#125; window.addEventListener(&quot;resize&quot;,function()&#123;&#125;); \n\nwindow.onresize 是调整窗口大小加载事件,  当触发时就调用的处理函数。 \n注意： \n\n只要窗口大小发生像素变化，就会触发这个事件。 \n我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度 \n\nwindow.addEventListener(&#x27;load&#x27;, function() &#123;    var div = document.querySelector(&#x27;div&#x27;);    window.addEventListener(&#x27;resize&#x27;, function() &#123;        console.log(window.innerWidth);        console.log(&#x27;变化了&#x27;);        if (window.innerWidth &lt;= 800) &#123;            div.style.display = &#x27;none&#x27;;        &#125; else &#123;            div.style.display = &#x27;block&#x27;;        &#125;    &#125;)&#125;)\n\n定时器两种定时器window 对象给我们提供了 2 个非常好用的方法-定时器。 \n\nsetTimeout() \nsetInterval()\n\nsetTimeout() 定时器window.setTimeout(调用函数, [延迟的毫秒数]); \n\nsetTimeout() 方法用于设置一个定时器，该定时器在定时器到期后执行调用函数。\n注意：\n\nwindow 可以省略\n这个调用函数可以直接写函数，或者写函数名或者采取字符串 ‘函数名()’ 三种形式。第三种不推荐\n延迟的毫秒数省略默认是 0，如果写，必须是毫秒\n因为定时器可能有很多，所以我们经常给定时器赋值一个标识符\n\nsetTimeout()  这个调用函数我们也称为回调函数 callback\n普通函数是按照代码顺序直接调用。\n而这个函数，需要等待时间，时间到了才去调用这个函数，因此称为回调函数。 \n简单理解： 回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。 \n以前我们讲的   element.onclick = function(){}   或者 element.addEventListener(“click”, fn);   里面的 函数也是回调函数\n// 1. setTimeout // 语法规范：  window.setTimeout(调用函数, 延时时间);// 1. 这个window在调用的时候可以省略// 2. 这个延时时间单位是毫秒 但是可以省略，如果省略默认的是0// 3. 这个调用函数可以直接写函数 还可以写 函数名 还有一个写法 &#x27;函数名()&#x27;// 4. 页面中可能有很多的定时器，我们经常给定时器加标识符 （名字)// setTimeout(function() &#123;//     console.log(&#x27;时间到了&#x27;);// &#125;, 2000);function callback() &#123;    console.log(&#x27;爆炸了&#x27;);&#125;var timer1 = setTimeout(callback, 3000);var timer2 = setTimeout(callback, 5000);// setTimeout(&#x27;callback()&#x27;, 3000); // 我们不提倡这个写法\n\n案例：5秒后自动关闭的广告\n核心思路：5秒之后，就把这个广告隐藏起来\n用定时器setTimeout  \n\n&lt;img src=&quot;images/ad.jpg&quot; alt=&quot;&quot; class=&quot;ad&quot;&gt;&lt;script&gt;    var ad = document.querySelector(&#x27;.ad&#x27;);    setTimeout(function() &#123;        ad.style.display = &#x27;none&#x27;;    &#125;, 5000);&lt;/script&gt;\n\n停止 setTimeout() 定时器window.clearTimeout(timeoutID) \n\nclearTimeout () 方法取消了先前通过调用 setTimeout() 建立的定时器。 \n注意：\n\nwindow 可以省略\n里面的参数就是定时器的标识符\n\n&lt;button&gt;点击停止定时器&lt;/button&gt;&lt;script&gt;    var btn = document.querySelector(&#x27;button&#x27;);    var timer = setTimeout(function() &#123;        console.log(&#x27;爆炸了&#x27;);    &#125;, 5000);    btn.addEventListener(&#x27;click&#x27;, function() &#123;        clearTimeout(timer);    &#125;)&lt;/script&gt;\n\nsetInterval() 定时器window.setInterval(回调函数, [间隔的毫秒数]); \n\nsetInterval() 方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。\n注意：\n\nwindow 可以省略\n这个调用函数可以直接写函数，或者写函数名或者采取字符串 ‘函数名()’ 三种形式 \n间隔的毫秒数省略默认是 0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数\n因为定时器可能有很多，所以我们经常给定时器赋值一个标识符 \n第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次\n\n案例：倒计时![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-13_22-58-32.png)\n\n这个倒计时是不断变化的，因此需要定时器来自动变化（setInterval）\n三个黑色盒子里面分别存放时分秒\n三个黑色盒子利用innerHTML 放入计算的小时分钟秒数\n第一次执行也是间隔毫秒数，因此刚刷新页面会有空白\n最好采取封装函数的方式，这样可以先调用一次这个函数，防止刚开始刷新页面有空白问题\n\n&lt;div&gt;    &lt;span class=&quot;hour&quot;&gt;1&lt;/span&gt;    &lt;span class=&quot;minute&quot;&gt;2&lt;/span&gt;    &lt;span class=&quot;second&quot;&gt;3&lt;/span&gt;&lt;/div&gt;&lt;script&gt;    // 1. 获取元素   var hour = document.querySelector(&#x27;.hour&#x27;); // 小时的黑色盒子  var minute = document.querySelector(&#x27;.minute&#x27;); // 分钟的黑色盒子  var second = document.querySelector(&#x27;.second&#x27;); // 秒数的黑色盒子  var inputTime = +new Date(&#x27;2019-5-1 18:00:00&#x27;); // 返回的是用户输入时间总的毫秒数    countDown(); // 我们先调用一次这个函数，防止第一次刷新页面有空白     // 2. 开启定时器    setInterval(countDown, 1000);    function countDown() &#123;        var nowTime = +new Date(); // 返回的是当前时间总的毫秒数        var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数         var h = parseInt(times / 60 / 60 % 24); //时        h = h &lt; 10 ? &#x27;0&#x27; + h : h;        hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子        var m = parseInt(times / 60 % 60); // 分        m = m &lt; 10 ? &#x27;0&#x27; + m : m;        minute.innerHTML = m;        var s = parseInt(times % 60); // 当前的秒        s = s &lt; 10 ? &#x27;0&#x27; + s : s;        second.innerHTML = s;    &#125;&lt;/script&gt;\n\n停止 setInterval() 定时器window.clearInterval(intervalID);\n\nclearInterval()方法取消了先前通过调用 setInterval() 建立的定时器。\n注意：\n\nwindow 可以省略。 \n里面的参数就是定时器的标识符 。 \n\n&lt;button class=&quot;begin&quot;&gt;开启定时器&lt;/button&gt;&lt;button class=&quot;stop&quot;&gt;停止定时器&lt;/button&gt;&lt;script&gt;    var begin = document.querySelector(&#x27;.begin&#x27;);    var stop = document.querySelector(&#x27;.stop&#x27;);    var timer = null; // 全局变量  null是一个空对象    begin.addEventListener(&#x27;click&#x27;, function() &#123;        timer = setInterval(function() &#123;            console.log(&#x27;ni hao ma&#x27;);        &#125;, 1000);    &#125;)    stop.addEventListener(&#x27;click&#x27;, function() &#123;        clearInterval(timer);    &#125;)&lt;/script&gt;\n\n案例：发送短信点击按钮后，该按钮60秒之内不能再次点击，防止重复发送短信。\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-13_23-10-55.png)\n\n 按钮点击之后，会禁用 disabled 为true\n 同时按钮里面的内容会变化， 注意 button 里面的内容通过 innerHTML修改\n 里面秒数是有变化的，因此需要用到定时器\n 定义一个变量，在定时器里面，不断递减\n 如果变量为0 说明到了时间，我们需要停止定时器，并且复原按钮初始状态\n\n手机号码： &lt;input type=&quot;number&quot;&gt; &lt;button&gt;发送&lt;/button&gt;&lt;script&gt;    // 按钮点击之后，会禁用 disabled 为true     // 同时按钮里面的内容会变化， 注意 button 里面的内容通过 innerHTML修改    // 里面秒数是有变化的，因此需要用到定时器    // 定义一个变量，在定时器里面，不断递减    // 如果变量为0 说明到了时间，我们需要停止定时器，并且复原按钮初始状态    var btn = document.querySelector(&#x27;button&#x27;);    var time = 3; // 定义剩下的秒数    btn.addEventListener(&#x27;click&#x27;, function() &#123;        btn.disabled = true;        var timer = setInterval(function() &#123;            if (time == 0) &#123;                // 清除定时器和复原按钮                clearInterval(timer);                btn.disabled = false;                btn.innerHTML = &#x27;发送&#x27;;            &#125; else &#123;                btn.innerHTML = &#x27;还剩下&#x27; + time + &#x27;秒&#x27;;                time--;            &#125;        &#125;, 1000);    &#125;)&lt;/script&gt;\n\nthisthis的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this 的最终指向的是那个调用它的对象。\n现阶段，我们先了解一下几个this指向：\n\n全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）\n方法调用中谁调用this指向谁\n构造函数中this指向构造函数的实例\n\n&lt;button&gt;点击&lt;/button&gt;&lt;script&gt;    // this 指向问题 一般情况下this的最终指向的是那个调用它的对象    // 1. 全局作用域或者普通函数中this指向全局对象window（ 注意定时器里面的this指向window）    console.log(this);    function fn() &#123;        console.log(this);    &#125;    window.fn();    window.setTimeout(function() &#123;        console.log(this);    &#125;, 1000);    // 2. 方法调用中谁调用this指向谁    var o = &#123;        sayHi: function() &#123;            console.log(this); // this指向的是 o 这个对象        &#125;    &#125;    o.sayHi();    var btn = document.querySelector(&#x27;button&#x27;);    // btn.onclick = function() &#123;    //     console.log(this); // this指向的是btn这个按钮对象    // &#125;    btn.addEventListener(&#x27;click&#x27;, function() &#123;            console.log(this); // this指向的是btn这个按钮对象        &#125;)        // 3. 构造函数中this指向构造函数的实例    function Fun() &#123;        console.log(this); // this 指向的是fun 实例对象    &#125;    var fun = new Fun();&lt;/script&gt;\n\nJS 执行队列JS 是单线程JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。这是因为 Javascript 这门脚 本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对 某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。 \n单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\n以下代码执行的结果是什么？ \nconsole.log(1);    setTimeout(function () &#123;      console.log(3); &#125;, 1000);    console.log(2); \t\t//  1  2   3\n\n同步和异步为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创 建多个线程。于是，JS 中出现了同步和异步。 \n同步\n前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做 法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。 \n异步\n你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做 饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。 \n他们的本质区别： 这条流水线上各个流程的执行顺序不同。 \n那么以下代码执行的结果又是什么？\nconsole.log(1);    setTimeout(function () &#123;      console.log(3); &#125;, 0);    console.log(2);\t\t\t//  1  2  3\n\n同步任务\n同步任务都在主线程上执行，形成一个执行栈。\n异步任务\nJS 的异步是通过回调函数实现的。 \n一般而言，异步任务有以下三种类型: \n\n普通事件，如 click、resize 等\n资源加载，如 load、error 等\n定时器，包括 setInterval、setTimeout 等\n\n异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）。\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-13_23-42-16.png)\nJS 执行机制\n先执行执行栈中的同步任务\n异步任务（回调函数）放入任务队列中\n一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任 务结束等待状态，进入执行栈，开始执行\n\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-13_23-43-41.png)\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-13_23-44-06.png)\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-13_23-46-59.png)\n由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop）。 \nlocation 对象什么是 location 对象window 对象给我们提供了一个 location 属性用于获取或设置窗体的 URL，并且可以用于解析 URL 。 因为 这个属性返回的是一个对象，所以我们将这个属性也称为 location 对象。 \nURL统一资源定位符 (Uniform Resource Locator, URL) 是互联网上标准资源的地址。互联网上的每个文件都有 一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。\nURL 的一般语法格式为： \nprotocol://host[:port]/path/[?query]#fragmenthttp://www.itcast.cn/index.html?name=andy&amp;age=18#link\n\n\n\n\n组成\n说明\n\n\n\nprotocol\n通信协议，常用的http、ftp、maito 等\n\n\nhost\n主机（域名）www.baidu.com\n\n\nport\n端口号。可选，省略时使用方案的默认端口，如 http 的默认端口为 80\n\n\npath\n路径。由零或多个 ‘/‘ 符号隔开的字符串，一般用来表示主机上的一个目录或文件地址\n\n\nquery\n参数。以键值对的形式，通过 &amp; 符号分隔开来\n\n\nfragment\n片段。# 后面内容，常见于链接 锚点\n\n\nlocation 对象的属性\n\n\nlocation 对象属性\n返回值\n\n\n\nlocation.href\n获取或者设置整个 URL\n\n\nlocation.host\n返回主机（域名）www.baidu.com\n\n\nlocation.port\n返回端口号，如果未写返回空字符串\n\n\nlocation.pathname\n返回路径\n\n\nlocation.search\n返回参数\n\n\nlocation.hash\n返回片段 #后面内容，常见于链接 锚点\n\n\n重点记住： href 和 search \n案例： 5秒钟之后自动跳转页面\n利用定时器做倒计时效果\n时间到了，就跳转页面。 使用 location.href \n\n&lt;button&gt;点击&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt;    var btn = document.querySelector(&#x27;button&#x27;);    var div = document.querySelector(&#x27;div&#x27;);    btn.addEventListener(&#x27;click&#x27;, function() &#123;        // console.log(location.href);        location.href = &#x27;http://www.itcast.cn&#x27;;    &#125;)    var timer = 5;    setInterval(function() &#123;        if (timer == 0) &#123;            location.href = &#x27;http://www.itcast.cn&#x27;;        &#125; else &#123;            div.innerHTML = &#x27;您将在&#x27; + timer + &#x27;秒钟之后跳转到首页&#x27;;            timer--;        &#125;    &#125;, 1000);&lt;/script&gt;\n\n案例： 获取 URL 参数数据主要练习数据在不同页面中的传递。 \n\n第一个登录页面，里面有提交表单， action 提交到 index.html页面\n第二个页面，可以使用第一个页面的参数，这样实现了一个数据不同页面之间的传递效果\n第二个页面之所以可以使用第一个页面的数据，是利用了URL 里面的 location.search参数\n在第二个页面中，需要把这个参数提取\n第一步去掉？  利用 substr\n第二步 利用=号分割 键 和 值     split(‘=‘)\n第一个数组就是键   第二个数组就是值\n\n// 第一个页面&lt;form action=&quot;index.html&quot;&gt;        用户名： &lt;input type=&quot;text&quot; name=&quot;uname&quot;&gt;        &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt;// 第二个页面    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        console.log(location.search); // ?uname=andy        // 1.先去掉？  substr(&#x27;起始的位置&#x27;，截取几个字符);        var params = location.search.substr(1); // uname=andy        console.log(params);        // 2. 利用=把字符串分割为数组 split(&#x27;=&#x27;);        var arr = params.split(&#x27;=&#x27;);        console.log(arr); // [&quot;uname&quot;, &quot;ANDY&quot;]        var div = document.querySelector(&#x27;div&#x27;);        // 3.把数据写入div中        div.innerHTML = arr[1] + &#x27;欢迎您&#x27;;    &lt;/script&gt;\n\nlocation 对象的方法\n\n\nlocation 对象方法\n返回值\n\n\n\nlocation.assign()\n跟 href 一样，可以跳转页面（也称为重定向页面）\n\n\nlocation.replace()\n替换当前页面，因为不记录历史，所以不能后退页面\n\n\nlocation.reload()\n重新加载页面，相当于刷新按钮或者 f5 如果参数为 true，强制刷新 Ctrl+f5\n\n\n&lt;button&gt;点击&lt;/button&gt;&lt;script&gt;    var btn = document.querySelector(&#x27;button&#x27;);    btn.addEventListener(&#x27;click&#x27;, function() &#123;        // 记录浏览历史，所以可以实现后退功能        // location.assign(&#x27;http://www.itcast.cn&#x27;);        // 不记录浏览历史，所以不可以实现后退功能        // location.replace(&#x27;http://www.itcast.cn&#x27;);        location.reload(true);    &#125;)&lt;/script&gt;\n\nnavigator 对象navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客 户机发送服务器的 user-agent 头部的值。\n下面前端代码可以判断用户那个终端打开页面，实现跳转\nif((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) &#123;     window.location.href = &quot;&quot;;     //手机 &#125; else &#123;     window.location.href = &quot;&quot;;     //电脑 &#125; \n\n&lt;script&gt;       if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) &#123;            window.location.href = &quot;../H5/index.html&quot;; //手机        &#125;&lt;/script&gt;\n\nhistory 对象window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中） 访问过的 URL。 \n\n\n\nhistory 对象方法\n作用\n\n\n\nback()\n可以后退功能\n\n\nforward()\n前进功能\n\n\ngo(参数)\n前进后退功能，参数如果是 1，前进 1 个页面，如果是 -1 后退一个页面\n\n\nhistory 对象一般在实际开发中比较少用，但是会在一些 OA 办公系统中见到。\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-14_14-22-11.png)\nPC 端网页特效元素偏移量 offset 系列offset 概述offset 翻译过来就是偏移量， 我们使用 offset 系列相关属性可以动态的得到该元素的位置（偏移）、大小等。 \n\n获得元素距离带有定位父元素的位置\n获得元素自身的大小（宽度高度）\n注意： 返回的数值都不带单位 \n\noffset 系列常用属性：\n\n\n\noffset系列属性\n作用\n\n\n\nelement.offsetParent\n返回作为该元素带有定位的父级元素，如果父级都没有定位，则返回 body\n\n\nelement.offsetTop\n返回元素相对带有定位父元素上方的偏移\n\n\nelement.offsetLeft\n返回元素相对带有定位父元素左边框的偏移\n\n\nelement.offsetWidth\n返回作为该元素带有定位的父级元素，如果父级都没有定位，则返回 body\n\n\nelement.offsetHeight\n返回作为该元素带有定位的父级元素，如果父级都没有定位，则返回 body\n\n\noffset 与 style 区别offset\n\n offset 可以得到任意样式表中的样式值\n offset 系列获得的数值是没有单位的\n offsetWidth 包含padding+border+width\n offsetWidth 等属性是只读属性，只能获取不能赋值\n 所以，我们想要获取元素大小位置，用offset更合适\n\nstyle\n\nstyle 只能得到行内样式表中的样式值\nstyle.width 获得的是带有单位的字符串\nstyle.width 获得不包含padding和border 的值\nstyle.width 是可读写属性，可以获取也可以赋值\n所以，我们想要给元素更改值，则需要用style改变\n\noffset 翻译过来就是偏移量， 我们使用 offset 系列相关属性可以动态的得到该元素的位置（偏移）、大小等。 \n\n获得元素距离带有定位父元素的位置\n获得元素自身的大小（宽度高度）  \n\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-14_14-32-26.png)\n案例：获取鼠标在盒子内的坐标\n我们在盒子内点击，想要得到鼠标距离盒子左右的距离\n首先得到鼠标在页面中的坐标（e.pageX, e.pageY）\n其次得到盒子在页面中的距离 ( box.offsetLeft, box.offsetTop) \n用鼠标距离页面的坐标减去盒子在页面中的距离，得到 鼠标在盒子内的坐标\n如果想要移动一下鼠标，就要获取最新的坐标，使用鼠标移动事件 mousemove\n\n&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt;    // 我们在盒子内点击， 想要得到鼠标距离盒子左右的距离。    // 首先得到鼠标在页面中的坐标（ e.pageX, e.pageY）    // 其次得到盒子在页面中的距离(box.offsetLeft, box.offsetTop)    // 用鼠标距离页面的坐标减去盒子在页面中的距离， 得到 鼠标在盒子内的坐标    var box = document.querySelector(&#x27;.box&#x27;);    box.addEventListener(&#x27;mousemove&#x27;, function(e) &#123;        // console.log(e.pageX);        // console.log(e.pageY);        // console.log(box.offsetLeft);        var x = e.pageX - this.offsetLeft;        var y = e.pageY - this.offsetTop;        this.innerHTML = &#x27;x坐标是&#x27; + x + &#x27; y坐标是&#x27; + y;    &#125;)&lt;/script&gt;\n\n案例：模态框拖拽弹出框，我们也称为模态框。 \n\n点击弹出层， 会弹出模态框， 并且显示灰色半透明的遮挡层 \n点击关闭按钮，可以关闭模态框，并且同时关闭灰色半透明遮挡层 \n鼠标放到模态框最上面一行，可以按住鼠标拖拽模态框在页面中移动 \n鼠标松开，可以停止拖动模态框移动\n\n案例分析：\n\n点击弹出层， 模态框和遮挡层就会显示出来 display:block; \n点击关闭按钮，模态框和遮挡层就会隐藏起来 display:none; \n在页面中拖拽的原理：鼠标按下并且移动，之后松开鼠标\n触发事件是鼠标按下 mousedown， 鼠标移动mousemove 鼠标松开 mouseup\n拖拽过程:  鼠标移动过程中，获得最新的值赋值给模态框的left和top值，这样模态框可以跟着鼠标走了\n鼠标按下触发的事件源是 最上面一行，就是  id 为 title\n鼠标的坐标 减去 鼠标在盒子内的坐标， 才是模态框真正的位置\n鼠标按下，我们要得到鼠标在盒子的坐标\n鼠标移动，就让模态框的坐标设置为： 鼠标坐标减去盒子坐标即可，注意移动事件写到按下事件里面\n鼠标松开，就停止拖拽，就是可以让鼠标移动事件解除\n\n// 1. 获取元素var login = document.querySelector(&#x27;.login&#x27;);var mask = document.querySelector(&#x27;.login-bg&#x27;);var link = document.querySelector(&#x27;#link&#x27;);var closeBtn = document.querySelector(&#x27;#closeBtn&#x27;);var title = document.querySelector(&#x27;#title&#x27;);// 2. 点击弹出层这个链接 link  让mask 和login 显示出来link.addEventListener(&#x27;click&#x27;, function() &#123;        mask.style.display = &#x27;block&#x27;;        login.style.display = &#x27;block&#x27;;    &#125;)    // 3. 点击 closeBtn 就隐藏 mask 和 login closeBtn.addEventListener(&#x27;click&#x27;, function() &#123;        mask.style.display = &#x27;none&#x27;;        login.style.display = &#x27;none&#x27;;    &#125;)    // 4. 开始拖拽    // (1) 当我们鼠标按下， 就获得鼠标在盒子内的坐标title.addEventListener(&#x27;mousedown&#x27;, function(e) &#123;    var x = e.pageX - login.offsetLeft;    var y = e.pageY - login.offsetTop;    // (2) 鼠标移动的时候，把鼠标在页面中的坐标，减去 鼠标在盒子内的坐标就是模态框的left和top值    document.addEventListener(&#x27;mousemove&#x27;, move)    function move(e) &#123;        login.style.left = e.pageX - x + &#x27;px&#x27;;        login.style.top = e.pageY - y + &#x27;px&#x27;;    &#125;    // (3) 鼠标弹起，就让鼠标移动事件移除    document.addEventListener(&#x27;mouseup&#x27;, function() &#123;        document.removeEventListener(&#x27;mousemove&#x27;, move);    &#125;)&#125;)\n\n案例：仿京东放大镜\n整个案例可以分为三个功能模块\n鼠标经过小图片盒子， 黄色的遮挡层和大图片盒子显示，离开隐藏2个盒子功能\n黄色的遮挡层跟随鼠标功能\n移动黄色遮挡层，大图片跟随移动功能\n\n① 鼠标经过小图片盒子，黄色的遮挡层和大图片盒子显示，离开隐藏2个盒子功能\n② 就是显示与隐藏\n① 黄色的遮挡层跟随鼠标功能\n② 把鼠标坐标给遮挡层不合适。因为遮挡层坐标以父盒子为准\n③ 首先是获得鼠标在盒子的坐标\n④ 之后把数值给遮挡层做为left 和top值\n⑤ 此时用到鼠标移动事件，但是还是在小图片盒子内移动\n⑥ 发现，遮挡层位置不对，需要再减去盒子自身高度和宽度的一半\n⑦ 遮挡层不能超出小图片盒子范围\n⑧ 如果小于零，就把坐标设置为0 \n⑨ 如果大于遮挡层最大的移动距离，就把坐标设置为最大的移动距离\n⑩ 遮挡层的最大移动距离： 小图片盒子宽度 减去 遮挡层盒子宽度\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-16_16-02-50.png)\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-16_16-03-10.png)\nwindow.addEventListener(&#x27;load&#x27;, function() &#123;    var preview_img = document.querySelector(&#x27;.preview_img&#x27;);    var mask = document.querySelector(&#x27;.mask&#x27;);    var big = document.querySelector(&#x27;.big&#x27;);    // 1. 当我们鼠标经过 preview_img 就显示和隐藏 mask 遮挡层 和 big 大盒子    preview_img.addEventListener(&#x27;mouseover&#x27;, function() &#123;        mask.style.display = &#x27;block&#x27;;        big.style.display = &#x27;block&#x27;;    &#125;)    preview_img.addEventListener(&#x27;mouseout&#x27;, function() &#123;            mask.style.display = &#x27;none&#x27;;            big.style.display = &#x27;none&#x27;;        &#125;)        // 2. 鼠标移动的时候，让黄色的盒子跟着鼠标来走    preview_img.addEventListener(&#x27;mousemove&#x27;, function(e) &#123;        // (1). 先计算出鼠标在盒子内的坐标        var x = e.pageX - this.offsetLeft;        var y = e.pageY - this.offsetTop;        // console.log(x, y);        // (2) 减去盒子高度 300的一半 是 150 就是我们mask 的最终 left 和top值了        // (3) 我们mask 移动的距离        var maskX = x - mask.offsetWidth / 2;        var maskY = y - mask.offsetHeight / 2;        // (4) 如果x 坐标小于了0 就让他停在0 的位置        // 遮挡层的最大移动距离        var maskMax = preview_img.offsetWidth - mask.offsetWidth;        if (maskX &lt;= 0) &#123;            maskX = 0;        &#125; else if (maskX &gt;= maskMax) &#123;            maskX = maskMax;        &#125;        if (maskY &lt;= 0) &#123;            maskY = 0;        &#125; else if (maskY &gt;= maskMax) &#123;            maskY = maskMax;        &#125;        mask.style.left = maskX + &#x27;px&#x27;;        mask.style.top = maskY + &#x27;px&#x27;;        // 3. 大图片的移动距离 = 遮挡层移动距离 * 大图片最大移动距离 / 遮挡层的最大移动距离        // 大图        var bigIMg = document.querySelector(&#x27;.bigImg&#x27;);        // 大图片最大移动距离        var bigMax = bigIMg.offsetWidth - big.offsetWidth;        // 大图片的移动距离 X Y        var bigX = maskX * bigMax / maskMax;        var bigY = maskY * bigMax / maskMax;        bigIMg.style.left = -bigX + &#x27;px&#x27;;        bigIMg.style.top = -bigY + &#x27;px&#x27;;    &#125;)&#125;)\n\n元素可视区 client 系列client 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client 系列 的相关属性可以动态的得到该元素的边框大小、元素大小等。\n\n\n\nclient系列属性\n作用\n\n\n\nelement.clientTop\n返回元素上边框的大小\n\n\nelement.clientLeft\n返回元素左边框的大小\n\n\nelement.clientWidth\n返回自身包括 padding、内容区的宽度，不含边框，返回数值不带单位\n\n\nelement.clientHeight\n返回自身包括 padding、内容区的高度，不含边框，返回数值不带单位\n\n\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-16_16-21-38.png)\n&lt;div&gt;&lt;/div&gt;&lt;script&gt;    // client 宽度 和我们offsetWidth 最大的区别就是 不包含边框    var div = document.querySelector(&#x27;div&#x27;);    console.log(div.clientWidth);&lt;/script&gt;\n\n案例： 淘宝 flexible.js 源码分析立即执行函数  (function() {})()  或者 (function(){}()) \n主要作用： 创建一个独立的作用域。 避免了命名冲突问题。\n// 1.立即执行函数: 不需要调用，立马能够自己执行的函数        function fn() &#123;            console.log(1);        &#125;        fn();        // 2. 写法 也可以传递参数进来        // 1.(function() &#123;&#125;)()    或者  2. (function()&#123;&#125;());        (function(a, b) &#123;            console.log(a + b);            var num = 10;        &#125;)(1, 2); // 第二个小括号可以看做是调用函数        (function sum(a, b) &#123;            console.log(a + b);            var num = 10; // 局部变量        &#125;(2, 3));// 3. 立即执行函数最大的作用就是 独立创建了一个作用域, 里面所有的变量都是局部变量 不会有命名冲突的情况\n\n下面三种情况都会刷新页面都会触发 load 事件：\n\na标签的超链接 \nF5或者刷新按钮（强制刷新） \n前进后退按钮\n\n但是火狐中有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的 状态；实际上是将整个页面都保存在了内存里。\n所以此时后退按钮不能刷新页面。 \n此时可以使用 pageshow事件来触发。，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页 面中，pageshow会在load事件触发后触发；根据事件对象中的persisted来判断是否是缓存中的页面触发的 pageshow事件，注意这个事件给window添加。\n元素滚动 scroll 系列元素 scroll 系列属性scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。 \n\n\n\nscroll 系列属性\n作用\n\n\n\nelement.scrollTop\n返回被卷去的上侧距离，返回数值不带单位\n\n\nelement.scrollLeft\n返回被卷去的左侧距离，返回数值不带单位\n\n\nelement.scrollWidth\n返回自身实际的宽度，不含边框，返回数值不带单位\n\n\nelement.scrollHeight\n返回自身实际的高度，不含边框，返回数值不带单位\n\n\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-16_16-27-28.png)\n&lt;div&gt;我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容&lt;/div&gt;&lt;script&gt;        // scroll 系列        var div = document.querySelector(&#x27;div&#x27;);        console.log(div.scrollHeight);        console.log(div.clientHeight);        // scroll滚动事件当我们滚动条发生变化会触发的事件        div.addEventListener(&#x27;scroll&#x27;, function() &#123;            console.log(div.scrollTop);        &#125;)&lt;/script&gt;\n\n页面被卷去的头部如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏 掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll 事件。\n案例：仿淘宝固定右侧侧边栏\n原先侧边栏是绝对定位 \n\n当页面滚动到一定位置，侧边栏改为固定定位 \n\n页面继续滚动，会让 返回顶部显示出来\n\n\n案例分析：\n\n需要用到页面滚动事件 scroll  因为是页面滚动，所以事件源是 document\n滚动到某个位置，就是判断页面被卷去的上部值\n页面被卷去的头部：可以通过window.pageYOffset 获得  如果是被卷去的左侧 window.pageXOffset\n注意，元素被卷去的头部是 element.scrollTop  , 如果是页面被卷去的头部 则是 window.pageYOffset\n其实这个值 可以通过盒子的 offsetTop 可以得到，如果大于等于这个值，就可以让盒子固定定位了\n\n&lt;div class=&quot;slider-bar&quot;&gt;    &lt;span class=&quot;goBack&quot;&gt;返回顶部&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;header w&quot;&gt;头部区域&lt;/div&gt;&lt;div class=&quot;banner w&quot;&gt;banner区域&lt;/div&gt;&lt;div class=&quot;main w&quot;&gt;主体部分&lt;/div&gt;&lt;script&gt;    //1. 获取元素    var sliderbar = document.querySelector(&#x27;.slider-bar&#x27;);    var banner = document.querySelector(&#x27;.banner&#x27;);    // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面    var bannerTop = banner.offsetTop        // 当我们侧边栏固定定位之后应该变化的数值    var sliderbarTop = sliderbar.offsetTop - bannerTop;    // 获取main 主体元素    var main = document.querySelector(&#x27;.main&#x27;);    var goBack = document.querySelector(&#x27;.goBack&#x27;);    var mainTop = main.offsetTop;    // 2. 页面滚动事件 scroll    document.addEventListener(&#x27;scroll&#x27;, function() &#123;        // console.log(11);        // window.pageYOffset 页面被卷去的头部        // console.log(window.pageYOffset);        // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位        if (window.pageYOffset &gt;= bannerTop) &#123;            sliderbar.style.position = &#x27;fixed&#x27;;            sliderbar.style.top = sliderbarTop + &#x27;px&#x27;;        &#125; else &#123;            sliderbar.style.position = &#x27;absolute&#x27;;            sliderbar.style.top = &#x27;300px&#x27;;        &#125;        // 4. 当我们页面滚动到main盒子，就显示 goback模块        if (window.pageYOffset &gt;= mainTop) &#123;            goBack.style.display = &#x27;block&#x27;;        &#125; else &#123;            goBack.style.display = &#x27;none&#x27;;        &#125;    &#125;)&lt;/script&gt;\n\n页面被卷去的头部兼容性解决方案需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法： \n\n声明了 DTD，使用 document.documentElement.scrollTop \n未声明 DTD，使用  document.body.scrollTop \n新方法 window.pageYOffset 和 window.pageXOffset，IE9 开始支持\n\n function getScroll() &#123;     return &#123;       left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0,       top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0     &#125;;  &#125;  使用的时候  getScroll().left\n\n三大系列总结\n\n\n三大系列大小对比\n作用\n\n\n\nelement.offsetWidth\n返回自身包括 padding、边框、内容区的宽度，返回数值不带单位\n\n\nelement.clientWidth\n返回自身包括 padding、内容区的宽度，不含边框，返回数值不带单位\n\n\nelement.scrollWidth\n返回自身实际的宽度、不含边框，返回数值不带单位\n\n\n![](C:\\Users\\Xia\\Desktop\\web api笔记\\images\\Snipaste_2020-09-16_16-45-43.png)\n他们主要用法： \n\noffset系列 经常用于获得元素位置    offsetLeft  offsetTop \nclient 经常用于获取元素大小  clientWidth  clientHeight \nscroll 经常用于获取滚动距离  scrollTop  scrollLeft    \n注意页面滚动的距离通过 window.pageXOffset  获得 \n\nmouseenter 和mouseover的区别mouseenter 鼠标事件\n当鼠标移动到元素上时就会触发 mouseenter 事件\n类似 mouseover，它们两者之间的差别是\nmouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。 mouseenter  只会经过自身盒子触发\n之所以这样，就是因为mouseenter不会冒泡\n跟mouseenter搭配 鼠标离开 mouseleave  同样不会冒泡\n\n    &lt;style&gt;        .father &#123;            width: 300px;            height: 300px;            background-color: pink;            margin: 100px auto;        &#125;              .son &#123;            width: 200px;            height: 200px;            background-color: purple;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;father&quot;&gt;        &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        var father = document.querySelector(&#x27;.father&#x27;);        var son = document.querySelector(&#x27;.son&#x27;);        father.addEventListener(&#x27;mouseenter&#x27;, function() &#123;            console.log(11);        &#125;)    &lt;/script&gt;\n\n动画函数封装动画实现原理核心原理：通过定时器 setInterval() 不断移动盒子位置。\n实现步骤： \n\n获得盒子当前位置 \n让盒子在当前位置加上1个移动距离 \n利用定时器不断重复这个操作 \n加一个结束定时器的条件 \n注意此元素需要添加定位，才能使用element.style.left\n\n    &lt;style&gt;        div &#123;            position: absolute;            left: 0;            width: 100px;            height: 100px;            background-color: pink;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        // 动画原理        // 1. 获得盒子当前位置          // 2. 让盒子在当前位置加上1个移动距离        // 3. 利用定时器不断重复这个操作        // 4. 加一个结束定时器的条件        // 5. 注意此元素需要添加定位， 才能使用element.style.left        var div = document.querySelector(&#x27;div&#x27;);        var timer = setInterval(function() &#123;            if (div.offsetLeft &gt;= 400) &#123;                // 停止动画 本质是停止定时器                clearInterval(timer);            &#125;            div.style.left = div.offsetLeft + 1 + &#x27;px&#x27;;        &#125;, 30);    &lt;/script&gt;\n\n动画函数简单封装注意函数需要传递2个参数，动画对象和移动到的距离。\n&lt;div&gt;&lt;/div&gt;&lt;span&gt;夏雨荷&lt;/span&gt;&lt;script&gt;    // 简单动画函数封装obj目标对象 target 目标位置    function animate(obj, target) &#123;        var timer = setInterval(function() &#123;            if (obj.offsetLeft &gt;= target) &#123;                // 停止动画 本质是停止定时器                clearInterval(timer);            &#125;            obj.style.left = obj.offsetLeft + 1 + &#x27;px&#x27;;        &#125;, 30);    &#125;    var div = document.querySelector(&#x27;div&#x27;);    var span = document.querySelector(&#x27;span&#x27;);    // 调用函数    animate(div, 300);    animate(span, 200);&lt;/script&gt;\n\n动画函数给不同元素记录不同定时器如果多个元素都使用这个动画函数，每次都要var 声明定时器。我们可以给不同的元素使用不同的定时器（自 己专门用自己的定时器）。\n核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。\n&lt;button&gt;点击夏雨荷才走&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;span&gt;夏雨荷&lt;/span&gt;&lt;script&gt;    // var obj = &#123;&#125;;    // obj.name = &#x27;andy&#x27;;    // 简单动画函数封装obj目标对象 target 目标位置    // 给不同的元素指定了不同的定时器    function animate(obj, target) &#123;        // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器        // 解决方案就是 让我们元素只有一个定时器执行        // 先清除以前的定时器，只保留当前的一个定时器执行        clearInterval(obj.timer);        obj.timer = setInterval(function() &#123;            if (obj.offsetLeft &gt;= target) &#123;                // 停止动画 本质是停止定时器                clearInterval(obj.timer);            &#125;            obj.style.left = obj.offsetLeft + 1 + &#x27;px&#x27;;        &#125;, 30);    &#125;    var div = document.querySelector(&#x27;div&#x27;);    var span = document.querySelector(&#x27;span&#x27;);    var btn = document.querySelector(&#x27;button&#x27;);    // 调用函数    animate(div, 300);    btn.addEventListener(&#x27;click&#x27;, function() &#123;        animate(span, 200);    &#125;)&lt;/script&gt;\n\n缓动效果原理缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来思路： \n\n   让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。 \n   核心算法： (目标值 - 现在的位置 )   /   10    做为每次移动的距离 步长 \n   停止的条件是： 让当前盒子位置等于目标位置就停止定时器   \n   注意步长值需要取整\n\n&lt;button&gt;点击夏雨荷才走&lt;/button&gt;&lt;span&gt;夏雨荷&lt;/span&gt;&lt;script&gt;    // 缓动动画函数封装obj目标对象 target 目标位置    // 思路：    // 1. 让盒子每次移动的距离慢慢变小， 速度就会慢慢落下来。    // 2. 核心算法：(目标值 - 现在的位置) / 10 做为每次移动的距离 步长    // 3. 停止的条件是： 让当前盒子位置等于目标位置就停止定时器    function animate(obj, target) &#123;        // 先清除以前的定时器，只保留当前的一个定时器执行        clearInterval(obj.timer);        obj.timer = setInterval(function() &#123;            // 步长值写到定时器的里面            var step = (target - obj.offsetLeft) / 10;            if (obj.offsetLeft == target) &#123;                // 停止动画 本质是停止定时器                clearInterval(obj.timer);            &#125;            // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10            obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;;        &#125;, 15);    &#125;    var span = document.querySelector(&#x27;span&#x27;);    var btn = document.querySelector(&#x27;button&#x27;);    btn.addEventListener(&#x27;click&#x27;, function() &#123;            // 调用函数            animate(span, 500);        &#125;)        // 匀速动画 就是 盒子是当前的位置 +  固定的值 10         // 缓动动画就是  盒子当前的位置 + 变化的值(目标值 - 现在的位置) / 10）\n\n动画函数多个目标值之间移动可以让动画函数从 800 移动到 500。 \n当我们点击按钮时候，判断步长是正值还是负值 \n\n如果是正值，则步长 往大了取整 \n如果是负值，则步长 向小了取整\n\n&lt;button class=&quot;btn500&quot;&gt;点击夏雨荷到500&lt;/button&gt;&lt;button class=&quot;btn800&quot;&gt;点击夏雨荷到800&lt;/button&gt;&lt;span&gt;夏雨荷&lt;/span&gt;&lt;script&gt;    // 缓动动画函数封装obj目标对象 target 目标位置    // 思路：    // 1. 让盒子每次移动的距离慢慢变小， 速度就会慢慢落下来。    // 2. 核心算法：(目标值 - 现在的位置) / 10 做为每次移动的距离 步长    // 3. 停止的条件是： 让当前盒子位置等于目标位置就停止定时器    function animate(obj, target) &#123;        // 先清除以前的定时器，只保留当前的一个定时器执行        clearInterval(obj.timer);        obj.timer = setInterval(function() &#123;            // 步长值写到定时器的里面            // 把我们步长值改为整数 不要出现小数的问题            // var step = Math.ceil((target - obj.offsetLeft) / 10);            var step = (target - obj.offsetLeft) / 10;            step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);            if (obj.offsetLeft == target) &#123;                // 停止动画 本质是停止定时器                clearInterval(obj.timer);            &#125;            // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10            obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;;        &#125;, 15);    &#125;    var span = document.querySelector(&#x27;span&#x27;);    var btn500 = document.querySelector(&#x27;.btn500&#x27;);    var btn800 = document.querySelector(&#x27;.btn800&#x27;);    btn500.addEventListener(&#x27;click&#x27;, function() &#123;        // 调用函数        animate(span, 500);    &#125;)    btn800.addEventListener(&#x27;click&#x27;, function() &#123;            // 调用函数            animate(span, 800);        &#125;)        // 匀速动画 就是 盒子是当前的位置 +  固定的值 10         // 缓动动画就是  盒子当前的位置 + 变化的值(目标值 - 现在的位置) / 10）&lt;/script&gt;\n\n动画函数添加回调函数回调函数原理：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后 ，再执行传进去的这个函数，这个过程就叫做回调。 \n回调函数写的位置：定时器结束的位置。 \n&lt;button class=&quot;btn500&quot;&gt;点击夏雨荷到500&lt;/button&gt;&lt;button class=&quot;btn800&quot;&gt;点击夏雨荷到800&lt;/button&gt;&lt;span&gt;夏雨荷&lt;/span&gt;&lt;script&gt;    // 缓动动画函数封装obj目标对象 target 目标位置    // 思路：    // 1. 让盒子每次移动的距离慢慢变小， 速度就会慢慢落下来。    // 2. 核心算法：(目标值 - 现在的位置) / 10 做为每次移动的距离 步长    // 3. 停止的条件是： 让当前盒子位置等于目标位置就停止定时器    function animate(obj, target, callback) &#123;        // console.log(callback);  callback = function() &#123;&#125;  调用的时候 callback()        // 先清除以前的定时器，只保留当前的一个定时器执行        clearInterval(obj.timer);        obj.timer = setInterval(function() &#123;            // 步长值写到定时器的里面            // 把我们步长值改为整数 不要出现小数的问题            // var step = Math.ceil((target - obj.offsetLeft) / 10);            var step = (target - obj.offsetLeft) / 10;            step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);            if (obj.offsetLeft == target) &#123;                // 停止动画 本质是停止定时器                clearInterval(obj.timer);                // 回调函数写到定时器结束里面                if (callback) &#123;                    // 调用函数                    callback();                &#125;            &#125;            // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10            obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;;        &#125;, 15);    &#125;    var span = document.querySelector(&#x27;span&#x27;);    var btn500 = document.querySelector(&#x27;.btn500&#x27;);    var btn800 = document.querySelector(&#x27;.btn800&#x27;);    btn500.addEventListener(&#x27;click&#x27;, function() &#123;        // 调用函数        animate(span, 500);    &#125;)    btn800.addEventListener(&#x27;click&#x27;, function() &#123;            // 调用函数            animate(span, 800, function() &#123;                // alert(&#x27;你好吗&#x27;);                span.style.backgroundColor = &#x27;red&#x27;;            &#125;);        &#125;)        // 匀速动画 就是 盒子是当前的位置 +  固定的值 10         // 缓动动画就是  盒子当前的位置 + 变化的值(目标值 - 现在的位置) / 10）\n\n动画函数封装到单独JS文件里面因为以后经常使用这个动画函数，可以单独封装到一个JS文件里面，使用的时候引用这个JS文件即可。 \n\n单独新建一个JS文件 \nHTML文件引入 JS 文件\n\n动画函数JS代码：\nfunction animate(obj, target, callback) &#123;    // console.log(callback);  callback = function() &#123;&#125;  调用的时候 callback()    // 先清除以前的定时器，只保留当前的一个定时器执行    clearInterval(obj.timer);    obj.timer = setInterval(function() &#123;        // 步长值写到定时器的里面        // 把我们步长值改为整数 不要出现小数的问题        // var step = Math.ceil((target - obj.offsetLeft) / 10);        var step = (target - obj.offsetLeft) / 10;        step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);        if (obj.offsetLeft == target) &#123;            // 停止动画 本质是停止定时器            clearInterval(obj.timer);            // 回调函数写到定时器结束里面            // if (callback) &#123;            //     // 调用函数            //     callback();            // &#125;            callback &amp;&amp; callback();        &#125;        // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10        obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;;    &#125;, 15);&#125;\n\n案例：\n    &lt;style&gt;        .sliderbar &#123;            position: fixed;            right: 0;            bottom: 100px;            width: 40px;            height: 40px;            text-align: center;            line-height: 40px;            cursor: pointer;            color: #fff;        &#125;        .con &#123;            position: absolute;            left: 0;            top: 0;            width: 200px;            height: 40px;            background-color: purple;            z-index: -1;        &#125;    &lt;/style&gt;    &lt;script src=&quot;animate.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;sliderbar&quot;&gt;        &lt;span&gt;←&lt;/span&gt;        &lt;div class=&quot;con&quot;&gt;问题反馈&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        // 1. 获取元素        var sliderbar = document.querySelector(&#x27;.sliderbar&#x27;);        var con = document.querySelector(&#x27;.con&#x27;);        // 当我们鼠标经过 sliderbar 就会让 con这个盒子滑动到左侧        // 当我们鼠标离开 sliderbar 就会让 con这个盒子滑动到右侧        sliderbar.addEventListener(&#x27;mouseenter&#x27;, function() &#123;            // animate(obj, target, callback);            animate(con, -160, function() &#123;                // 当我们动画执行完毕，就把 ← 改为 →                sliderbar.children[0].innerHTML = &#x27;→&#x27;;            &#125;);        &#125;)        sliderbar.addEventListener(&#x27;mouseleave&#x27;, function() &#123;            // animate(obj, target, callback);            animate(con, 0, function() &#123;                sliderbar.children[0].innerHTML = &#x27;←&#x27;;            &#125;);        &#125;)    &lt;/script&gt;\n\n常见网页特效案例案例：网页轮播图web API 视频 第六天的案例\n节流阀防止轮播图按钮连续点击造成播放过快。 \n节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。 \n核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。\n开始设置一个变量 var flag = true; \nIf(flag) {flag = false; do something}       关闭水龙头 \n利用回调函数 动画执行完毕， flag = true     打开水龙头 \n案例：返回顶部滚动窗口至文档中的特定位置。\nwindow.scroll(x, y) \n注意，里面的x和y 不跟单位，直接写数字 \n\n带有动画的返回顶部\n此时可以继续使用我们封装的动画函数\n只需要把所有的left 相关的值改为跟页面垂直滚动距离相关就可以了\n页面滚动了多少，可以通过 window.pageYOffset 得到\n最后是页面滚动，使用 window.scroll(x,y) \n\n&lt;div class=&quot;slider-bar&quot;&gt;    &lt;span class=&quot;goBack&quot;&gt;返回顶部&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;header w&quot;&gt;头部区域&lt;/div&gt;&lt;div class=&quot;banner w&quot;&gt;banner区域&lt;/div&gt;&lt;div class=&quot;main w&quot;&gt;主体部分&lt;/div&gt;&lt;script&gt;    //1. 获取元素    var sliderbar = document.querySelector(&#x27;.slider-bar&#x27;);    var banner = document.querySelector(&#x27;.banner&#x27;);    // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面    var bannerTop = banner.offsetTop        // 当我们侧边栏固定定位之后应该变化的数值    var sliderbarTop = sliderbar.offsetTop - bannerTop;    // 获取main 主体元素    var main = document.querySelector(&#x27;.main&#x27;);    var goBack = document.querySelector(&#x27;.goBack&#x27;);    var mainTop = main.offsetTop;    // 2. 页面滚动事件 scroll    document.addEventListener(&#x27;scroll&#x27;, function() &#123;            // console.log(11);            // window.pageYOffset 页面被卷去的头部            // console.log(window.pageYOffset);            // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位            if (window.pageYOffset &gt;= bannerTop) &#123;                sliderbar.style.position = &#x27;fixed&#x27;;                sliderbar.style.top = sliderbarTop + &#x27;px&#x27;;            &#125; else &#123;                sliderbar.style.position = &#x27;absolute&#x27;;                sliderbar.style.top = &#x27;300px&#x27;;            &#125;            // 4. 当我们页面滚动到main盒子，就显示 goback模块            if (window.pageYOffset &gt;= mainTop) &#123;                goBack.style.display = &#x27;block&#x27;;            &#125; else &#123;                goBack.style.display = &#x27;none&#x27;;            &#125;        &#125;)        // 3. 当我们点击了返回顶部模块，就让窗口滚动的页面的最上方    goBack.addEventListener(&#x27;click&#x27;, function() &#123;        // 里面的x和y 不跟单位的 直接写数字即可        // window.scroll(0, 0);        // 因为是窗口滚动 所以对象是window        animate(window, 0);    &#125;);    // 动画函数    function animate(obj, target, callback) &#123;        // console.log(callback);  callback = function() &#123;&#125;  调用的时候 callback()        // 先清除以前的定时器，只保留当前的一个定时器执行        clearInterval(obj.timer);        obj.timer = setInterval(function() &#123;            // 步长值写到定时器的里面            // 把我们步长值改为整数 不要出现小数的问题            // var step = Math.ceil((target - obj.offsetLeft) / 10);            var step = (target - window.pageYOffset) / 10;            step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);            if (window.pageYOffset == target) &#123;                // 停止动画 本质是停止定时器                clearInterval(obj.timer);                // 回调函数写到定时器结束里面                // if (callback) &#123;                //     // 调用函数                //     callback();                // &#125;                callback &amp;&amp; callback();            &#125;            // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10            // obj.style.left = window.pageYOffset + step + &#x27;px&#x27;;            window.scroll(0, window.pageYOffset + step);        &#125;, 15);    &#125;&lt;/script&gt;\n\n案例：筋头云案例鼠标经过某个小li， 筋斗云跟这到当前小li位置 \n鼠标离开这个小li， 筋斗云复原为原来的位置 \n鼠标点击了某个小li， 筋斗云就会留在点击这个小li 的位置 \n\n利用动画函数做动画效果\n原先筋斗云的起始位置是0\n鼠标经过某个小li， 把当前小li 的 offsetLeft 位置 做为目标值即可\n鼠标离开某个小li， 就把目标值设为 0\n如果点击了某个小li， 就把li当前的位置存储起来，做为筋斗云的起始位置\n\nfunction animate(obj, target, callback) &#123;    // console.log(callback);  callback = function() &#123;&#125;  调用的时候 callback()    // 先清除以前的定时器，只保留当前的一个定时器执行    clearInterval(obj.timer);    obj.timer = setInterval(function() &#123;        // 步长值写到定时器的里面        // 把我们步长值改为整数 不要出现小数的问题        // var step = Math.ceil((target - obj.offsetLeft) / 10);        var step = (target - obj.offsetLeft) / 10;        step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);        if (obj.offsetLeft == target) &#123;            // 停止动画 本质是停止定时器            clearInterval(obj.timer);            // 回调函数写到定时器结束里面            // if (callback) &#123;            //     // 调用函数            //     callback();            // &#125;            callback &amp;&amp; callback();        &#125;        // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10        obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;;    &#125;, 15);&#125;\n\n移动端网页特效","categories":["黑马前端"],"tags":["JS"]}]